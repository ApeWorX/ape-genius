# Accounts

Accounts in Ape come from [AccountAPI](../methoddocs/api.html#ape.api.accounts.AccountAPI) implementations (e.g. from plugins).
There are typically two types of accounts:

1. Test accounts
2. Live network accounts

Test accounts are useful for local network testing and debugging contracts.
Live network accounts are for interacting with live blockchains and should be secured.

To learn more about Ethereum accounts, see [the Ethereum documentation](https://ethereum.org/en/developers/docs/accounts/).

## Test Accounts

Ape ships with pytest fixtures to assist in writing your tests.

### Use test accounts in tests

Pre-funded test accounts are accessible via the [accounts fixture](./testing.html#accounts-fixture).

```python
def test_my_contract_method(accounts):
    sender = accounts[0]
    ...
```

### Use test accounts outside of tests

To access the same prefunded accounts in your scripts or console, use the root `accounts` object and the [test_accounts](../methoddocs/managers.html#ape.managers.accounts.AccountManager.test_accounts) property:

```{eval-rst}
.. doctest::

  >>> from ape import accounts

  >>> sender = accounts.test_accounts[0]

```

You can configure your test accounts using your `ape-config.yaml` file:

```yaml
test:
  mnemonic: test test test test test test test test test test test junk
  number_of_accounts: 5
```

```{warning}
NEVER put a seed phrase with real funds here.
```

The accounts generated from this seed are solely for testing and debugging purposes.

### Creating new test accounts

You can create a new test account by doing the following:

```{eval-rst}
.. doctest::

  >>> from ape import accounts

  >>> account = accounts.test_accounts.generate_test_account()
```

```{note}
Creating a new test account means it will be unfunded by default.
```

Learn more about test accounts from the [testing guide](./testing.html#accounts-fixture).

If your testing provider supports this feature, it is possible to directly set the balances of any address by performing the following action:

```python
account.balance += int(1e18)  # Gives `account` 1 Ether
```

### Default Sender Support

In order to eliminate the usage of sender in contract calls, you can use `use_sender` context manager.

```python
with accounts.use_sender(0): # Use first account from test mnemonic
  contract.myFunction(1)

with accounts.use_sender("<address>"): # Impersonate an account
  contract.myFunction(1)

with accounts.use_sender(a): # a is a `TestAccountAPI` object
  contract.myFunction(1)
```

## Live Network Accounts

When using live networks, you need to get your accounts into Ape.
To get your accounts in Ape, you must use an `accounts` plugin.
Ape ships with a keyfile-based account plugin, but you can use any account plugin such as `ape-ledger`, `ape-trezor`, or a third-party plugin.

### Keyfile Accounts

Ape ships with a keyfile-based account plugin that lets you import and generate accounts.
The premise of the plugin is that accounts are stored locally on your computer in the `$HOME/.ape/accounts` directory following the `keyfile` structure.
Under-the-hood, this structure comes from the [eth-keyfile library](https://github.com/ethereum/eth-keyfile) via the [eth-account](https://eth-account.readthedocs.io/en/stable/eth_account.html) package.
When Ape creates the keyfile, either from import or account-generation (described below!), it prompts you for a passphrase to use for encrypting the keyfile, similarly to how you would use a password in browser-based wallets.
The keyfile stores the private key in an encrypted-at-rest state, which maximizes security of the locally-stored key material.

The `ape-accounts` core plugin lets you use keyfile-based account to sign messages and transactions.
When signing a message or transaction using an account from `ape-accounts`, you will be prompted to enter the passphrase you specified when importing or generating that account.

All the available CLI commands for this account's plugin can be found [here](../commands/accounts.html).

#### Generating New Accounts

You can [generate](../commands/accounts.html#accounts-generate) an account:

```bash
ape accounts generate <ALIAS>
```

Ape will prompt you for entropy which is used to increase randomness when creating your account.
Ape will then prompt you whether you want to show your mnemonic.
If you do not want to see your mnemonic you can select `n`.
Alternatively, you can use the `--hide-mnemonic` option to skip the prompt.

```bash
ape accounts generate <ALIAS> --hide-mnemonic
```

If you elected to show your mnemonic Ape will then show you your newly generated mnemonic.
Ape will then prompt you for a passphrase which you will need to enter twice to confirm.
This passphrase is used to encrypt your account on disk, for extra security.
You will be prompted for it each time you load your account, so make sure to remember it.
After entering the passphrase Ape will then show you your new account address, HDPath, and account alias.
If you want to use a custom HDPath, use the `--hd-path` option:

```bash
ape accounts generate <ALIAS> --hd-path <HDPATH>
```

If you do not use the `--hd-path` option, Ape will use the default HDPath of (Ethereum network, first account).
If you want to use a custom mnemonic phrase word length, use the `--word-count` option:

```bash
ape accounts generate <ALIAS> --word-count <WORDCOUNT>
```

If you do not use the `--word-count` option, Ape will use the default word count of 12.
You can use all of these together or separately to control the way Ape creates and displays your account information.

This same functionality is also scriptable with the same inputs as the `generate` command:

```python
from ape_accounts import generate_account

account, mnemonic = generate_account("my-account", "mySecureP@ssphrase")

print(f'Save your mnemonic: {mnemonic}')
print(f'Your new account address is: {account.address}')
```

See the [documentation for `generate_account()`](../methoddocs/ape_accounts.html#ape_accounts.generate_account) for more options.

#### Importing Existing Accounts

If you already have an account and wish to import it into Ape (say, from Metamask), you can use the [import command](../commands/accounts.html#accounts-import):

```bash
ape accounts import <ALIAS>
```

It will prompt you for the private key.
If you need help exporting your private key from Metamask, see [this guide](https://metamask.zendesk.com/hc/en-us/articles/360015289632-How-to-export-an-account-s-private-key).
You can also import accounts from mnemonic seed by using the `--use-mnemonic` flag:

```bash
ape accounts import <ALIAS> --use-mnemonic
```

It will then prompt you for the [mnemonic seed](https://en.bitcoin.it/wiki/Seed_phrase).
If you need help finding your mnemonic seed (Secret Recovery Phrase) in Metamask, see [this guide](https://metamask.zendesk.com/hc/en-us/articles/360015290032-How-to-reveal-your-Secret-Recovery-Phrase).
In addition, you can also use a custom HDPath by using the `--hd-path` option:

```bash
ape accounts import <ALIAS> --use-mnemonic --hd-path <HDPATH>
```

If you use the `--hd-path` option, you will need to pass the [HDPath](https://help.myetherwallet.com/en/articles/5867305-hd-wallets-and-derivation-paths) you'd like to use as an argument in the command.
If you do not use the `--hd-path` option, Ape will use the default HDPath of (Ethereum network, first account).

You can import an account programmatically using a seed phrase [using `import_account_from_mnemonic()`](../methoddocs/ape_accounts.html#ape_accounts.import_account_from_mnemonic):

```python
from ape_accounts import import_account_from_mnemonic

alias = "my-account"
passphrase = "my$ecurePassphrase"
mnemonic = "test test test test test test test test test test test junk"

account = import_account_from_mnemonic(alias, passphrase, mnemonic)

print(f'Your imported account address is: {account.address}')
```

Or using a raw private key [using `import_account_from_private_key()`](../methoddocs/ape_accounts.html#ape_accounts.import_account_from_private_key):

```python
import os
from ape_accounts import import_account_from_private_key

alias = "my-account"
passphrase = "my SecurePassphrase"
private_key = os.urandom(32).hex()

account = import_account_from_private_key(alias, passphrase, private_key)

print(f'Your imported account address is: {account.address}')
```

#### Exporting Accounts

You can also [export](../commands/accounts.html#accounts-export) the private key of an account:

```bash
ape accounts export <ALIAS>
```

Ape will ask you for the password to the account and then give you the private key of that account.
You can then use that private key with [import](../commands/accounts.html#accounts-import).
You can alternatively load the private key into [Metamask wallet](https://metamask.zendesk.com/hc/en-us/articles/360015489331-How-to-import-an-account#h_01G01W07NV7Q94M7P1EBD5BYM4).
Then, in your scripts, you can [load](../methoddocs/managers.html#ape.managers.accounts.AccountManager.load) an account:

```python
from ape import accounts

account = accounts.load("<ALIAS>")
```

### Default Sender Support

In order to reduce repetition of adding `sender` in your contract calls, you can use `use_sender` context manager.

```python
with accounts.use_sender(0):
  contract.myFunction(1)

with accounts.use_sender("<address>"):
  contract.myFunction(1)

with accounts.use_sender("<alias>"):
  contract.myFunction(1)

with accounts.use_sender(a): # a is a `AccountAPI` object
  contract.myFunction(1)
```

## Signing Messages

You can sign messages with your accounts in Ape.
To do this, use the [sign_message](../methoddocs/api.html#ape.api.accounts.AccountAPI.sign_message) API.

```python
from ape import accounts
from eth_account.messages import encode_defunct

account = accounts.load("<ALIAS>")
message = encode_defunct(text="Hello Apes!")
signature = account.sign_message(message)
```

```{note}
Ape's `sign_message` API intentionally accepts `Any` as the message argument type.
```

Account plugins decide what data-types to support.
Most Ethereum account plugins, such as `ape-account`, are able to sign messages like the example above.
However, you can also provide other types, such as a `str` directly:

```python
from ape import accounts

account = accounts.load("<ALIAS>")
signature = account.sign_message("Hello Apes!")
```

### EIP-712

Some account plugins are able to sign EIP-712 structured message types by utilizing the `eip712` package.
Here is an example with custom EIP-712 classes:

```python
from ape import accounts
from eip712.messages import EIP712Message, EIP712Type

class Person(EIP712Type):
    name: "string"
    wallet: "address"

class Mail(EIP712Message):
    _chainId_: "uint256" = 1
    _name_: "string" = "Ether Mail"
    _verifyingContract_: "address" = "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC"
    _version_: "string" = "1"

    sender: Person
    receiver: Person

alice = Person(name="Alice", wallet="0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826")
bob = Person("Bob", "0xB0B0b0b0b0b0B000000000000000000000000000")
message = Mail(sender=alice, receiver=bob)

account = accounts.load("<ALIAS>")
account.sign_message(message)
```

### Verifying Signature

Verify the signatures on your signed messages by using the [recover_signer](../methoddocs/types.html#ape.types.signatures.recover_signer) function or the [check_signature](../methoddocs/api.html#ape.api.accounts.AccountAPI.check_signature) function:

```python
from ape import accounts
from ape.types.signatures import recover_signer
from eth_account.messages import encode_defunct

account = accounts.load("<ALIAS>")
message = encode_defunct(text="Hello Apes!")
signature = account.sign_message(message)

# Validate the signature by recovering the signer and asserting it is equal to the sender.
recovered_signer = recover_signer(message, signature)
assert recovered_signer == account.address

# NOTE: You can also use the `check_signature` method on an account, which returns a bool.
assert account.check_signature(message, signature)
```

## Automation

If you use your keyfile accounts in automation, such as CI/CD, you may need to programmatically unlock them and enable auto-sign.
To do this, use a special environment variable for the account's passphrase:

```bash
export APE_ACCOUNTS_<alias>_PASSPHRASE="a"
```

Where `<alias>` is the name of the account you want to use.
Now, you can use your account to make any transactions without subsequently providing your passphrase.

```py
from ape import accounts
from eth_account.messages import encode_defunct

account = accounts.load("<ALIAS>")
account.set_autosign(True)

# Now, you will not be prompted to sign messages or transactions
message = encode_defunct(text="Hello Apes!")
signature = account.sign_message(message)
```

```{note}
Alternatively, you may use the `passphrase=` kwarg on methods `account.set_autosign()` and `account.unlock()`, but we highly recommend using the environment variable approach to avoid accidentally leaking your passphrase.
```

## Hardware Wallets

Because of the plugin system in Ape, we are able to support other types of accounts including hardware wallet accounts.
Check out these plugins:

- [ape-ledger](https://github.com/ApeWorX/ape-ledger)
- [ape-trezor](https://github.com/ApeWorX/ape-trezor)

To install one of these plugins, do the following:

```bash
ape plugins install ledger
```
# CLIs

Ape uses the [click framework](https://click.palletsprojects.com/en/8.1.x/) for handling all CLI functionality.
There are CLIs found in a couple areas in the Ape framework:

1. Plugins
2. Scripts

Both plugins and scripts utilize `click` for their CLIs.

For plugins, CLIs are an option for extending the framework.
You can read more about plugin development and CLIs in the [developing plugins guide](./developing_plugins.html).

Scripts utilize CLIs as an option for users to develop their scripts.
You can read more about scripting and CLIs in the [scripting guide](./scripts.html).

This guide is for showcasing utilities that ship with Ape to assist in your CLI development endeavors.

## Ape Context Decorator

The [@ape_cli_context](../methoddocs/cli.html#ape.cli.options.ape_cli_context) gives you access to all the root Ape objects (`accounts`, `networks` etc.), the ape logger, and an [abort](../methoddocs/cli.html#ape.cli.options.ApeCliContextObject.abort) method for stopping execution of your CLI gracefully.
Here is an example using all of those features from the `cli_ctx`:

```python
import click
from ape.cli import ape_cli_context


@click.command()
@ape_cli_context()
def cmd(cli_ctx):
    cli_ctx.logger.info("Test")
    account = cli_ctx.account_manager.load("metamask")
    cli_ctx.abort(f"Bad account: {account.address}")
```

In Ape, it is easy to extend the CLI context object and use the extended version in your CLIs:

```python
from ape.cli import ApeCliContextObject, ape_cli_context
import click

class MyManager:
   """My custom manager."""

class CustomContext(ApeCliContextObject):
   my_manager: MyManager = MyManager()
   """Add new managers to your custom context"""
   
   @property
   def signer(self):
      """Utilize existing managers in your custom context."""
      return self.account_manager.load("my_account")

@click.command()
@ape_cli_context(obj_type=CustomContext)
def cli(cli_ctx):
    # Access your manager.
    print(cli_ctx.my_manager)
    # Access other Ape managers.
    print(cli_ctx.account_manager)
```

## Network Tools

The [@network_option()](../methoddocs/cli.html#ape.cli.options.network_option) allows you to select an ecosystem, network, and provider.
To specify the network option, use values like:

```shell
--network ethereum
--network ethereum:sepolia
--network ethereum:mainnet:alchemy
--network ::foundry
```

To use default values automatically, omit sections of the choice, but leave the semi-colons for parsing.
For example, `::test` means to use the default ecosystem and network and the `test` provider.

Use `ecosystem`, `network`, and `provider` argument names in your command implementation to access their corresponding class instances:

```python
import click
from ape.cli import network_option

@click.command()
@network_option()
def cmd(provider):
   # This command only needs the provider.
   click.echo(provider.name)

@click.command()
@network_option()
def cmd_2(ecosystem, network, provider):
   # This command uses all parts of the parsed network choice.
   click.echo(ecosystem.name)
   click.echo(network.name)
   click.echo(provider.name)
```

The [ConnectedProviderCommand](../methoddocs/cli.html#ape.cli.commands.ConnectedProviderCommand) automatically uses the `--network` option and connects to the network before any of your code executes and then disconnects afterward.
This is useful if your script or command requires a provider connection in order for it to run.
Additionally, specify `ecosystem`, `network`, or `provider` in your command function if you need any of those instances in your `ConnectedProviderCommand`, just like when using `network_option`.

```python
import click
from ape.cli import ConnectedProviderCommand

@click.group()
def cli():
    pass

 @cli.command(cls=ConnectedProviderCommand)
def cmd_1(network, provider):
   click.echo(network.name)
   click.echo(provider.is_connected)  # True

 @cli.command(cls=ConnectedProviderCommand)
def cmd_2(provider):
   click.echo(provider.is_connected)  # True

 @cli.command(cls=ConnectedProviderCommand)
def cmd_3():
   click.echo("Using params from ConnectedProviderCommand is optional")
```

## Account Tools

Use the [@account_option()](../methoddocs/cli.html#ape.cli.options.account_option) for adding an option to your CLIs to select an account.
This option does several things:

1. If you only have a single account in Ape (from both test accounts _and_ other accounts), it will use that account as the default.
   (this case is rare, as most people have more than one test account by default).
2. If you have more than one account, it will prompt you to select the account to use.
3. You can pass in an account alias or index to the option flag to have it use that account.
4. It allows you to specify test accounts by using a choice of `TEST::{index_of_test_account}`.

Thus, if you use this option, no matter what, your script will have an account to use by the time the script starts.
Here is an example:

```python
import click
from ape.cli import account_option


@click.command()
@account_option()
def cmd(account):
    # Will prompt the user to select an account if needed.
    click.echo(account.alias)
```

And when invoking the command from the CLI, it would look like the following:
(where `<prefix>` is either `ape run` for scripts or `ape <custom-plugin-cmd>` for plugins)

```shell
<prefix> cmd  # Use the default account.
<prefix> cmd --account 0  # Use first account that would show up in `select_account()`.
<prefix> cmd --account metamask  # Use account with alias "metamask".
<prefix> cmd --account TEST::0  # Use the test account at index 0.
```

Alternatively, you can call the [select_account()](../methoddocs/cli.html#ape.cli.choices.select_account) directly to have more control of when the account gets selected:

```python
import click
from ape.cli import select_account


@click.command()
def cmd():
   account = select_account("Select an account to use")
   click.echo(f"You selected {account.address}.")
```

Similarly, there are a couple custom arguments for aliases alone that are useful when making CLIs for account creation.
If you use [@existing_alias_argument()](../methoddocs/cli.html#ape.cli.arguments.existing_alias_argument) and specify an alias does not already exist, it will error.
And visa-versa when using [@non_existing_alias_argument()](../methoddocs/cli.html#ape.cli.arguments.non_existing_alias_argument).

```python
import click
from ape.cli import existing_alias_argument, non_existing_alias_argument


@click.command()
@existing_alias_argument()
def delete_account(alias):
    # We know the alias is an existing account at this point.
    click.echo(alias)


@click.command()
@non_existing_alias_argument()
def create_account(alias):
    # We know the alias is not yet used in Ape at this point.
    click.echo(alias)
```

You can control additional filtering of the accounts by using the `account_type` kwarg.
Use `account_type` to filter the choices by specific types of [AccountAPI](../methoddocs/api.html#ape.api.accounts.AccountAPI), or you can give it a list of already known accounts, or you can provide a callable-filter that takes an account and returns a boolean.

```python
import click
from ape import accounts
from ape.cli import existing_alias_argument, select_account
from ape_accounts.accounts import KeyfileAccount

# NOTE: This is just an example and not anything specific or recommended.
APPLICATION_PREFIX = "<FOO_BAR>"

@click.command()
@existing_alias_argument(account_type=KeyfileAccount)
def cli_0(alias):
   pass

@click.command()
@existing_alias_argument(account_type=lambda a: a.alias.startswith(APPLICATION_PREFIX))
def cli_1(alias):
   pass

# Select from the given accounts directly.
my_accounts = [accounts.load("me"), accounts.load("me2")]
selected_account = select_account(account_type=my_accounts)
```

## Contract File Paths

Does your CLI interact with contract source files?
(Think `ape compile`).

If so, use the `@contract_file_paths_argument()` decorator in your CLI.

```python
from pathlib import Path
import click

from ape.cli import contract_file_paths_argument

@click.command()
@contract_file_paths_argument()
def cli(file_paths: set[Path]):
   # Loop through all source files given (or all source files in the project).
    for path in file_paths:
        click.echo(f"Source found: {path}")
```

When using the `@contract_file_paths_argument()` decorator, you can pass any number of source files as arguments.
When not passing any source file(s), `@contract_file_paths_argument()` defaults to all sources in the local project.
That is why `ape compile` compiles the full project and `ape compile MySource.vy` only compiles `MySource.vy` (and whatever else it needs / imports).
Use `@contract_file_paths_argument()` for any similar use-case involving contract source files.
# Compile

Compile your project using the following command:

```bash
ape compile
```

Configure the location Ape looks for contracts by editing the `contracts_folder` key in your project's `ape-config.yaml` file:

```yaml
contracts_folder: src  # Default is 'contracts/'
```

## The JSON Compiler

Ape ships with a compiler that is able to compile `.json` files.
This compiler is useful for the following:

1. **Interfaces**: If you know the address of an existing contract, you can include its ABI in your project and create a contract wrapper around it:

```python
from ape import project

# Comes from a file named `MyInterface.json` in the contracts/ folder.
my_interface = project.MyInterface
address = "0x1234556b5Ed9202110D7Ecd637A4581db8b9879F"

# Instantiate a deployed contract using the local interface.
contract = my_interface.at(address)

# Call a method named `my_method` found in the local contract ABI.
contract.my_method()
```

2. **Pre-existing Contract Types**: If you have a contract type JSON that was compiled elsewhere, you can include it in your project.
   This is useful if you are unable or unwilling to install a compiler.

3. **Raw Compiler Output**: If you have an artifact with binary compiled elsewhere, you can include it in your project.
   This is useful if you want to use contracts from much larger projects as dependency for your test cases.

```{warning}
You may have to adjust name and source ID similarly to raw contract-type output.
```

## Other Compiler Plugins

If your project includes Solidity (`.sol`) or Vyper (`.vy`) files, you will have to install additional compilers.
To include additional compilers in your project, you can add the plugins to the `plugins` list in your `ape-config.yaml` or install them using the CLI.
For information on how to configure plugins in your project, follow [this guide](./installing_plugins.html).

## Exclude Files

You can configure files to be excluded from compilation.
By default, Ape excludes known non-contract files such as `package.json`, `package-lock.json`, `tsconfig.json`, or `.DS_Store`.
To append file-globs to the exclusions list, edit your `compile:exclude` config like this:

```yaml
compile:
  exclude:
    - "examples"  # Exclude all files in the examples/ directory
    - "*Mock.sol"  # Exclude all files ending in Mock.sol
    - r"(?!.*_mock\.vy$)"  # You can also use regex instead of globs (prefix with `r`).
```

You can also exclude files using the `--config-override` CLI option:

```shell
ape compile --config-override '{"compile": {"exclude": ["*Mock.sol"]}}'
```

## Dependencies

In Ape, compiler plugins typically let you have dependencies.
See [this guide](./dependencies.html) to learn more about configuring dependencies in Ape.

To always compile dependencies in Ape during the `ape compile` command, use the CLI flag `--include-dependencies`:

```shell
ape compile --include-dependencies
```

Alternatively, configure it to always happen:

```yaml
compile:
  use_dependencies: true
```

## Settings

Generally, configure compiler plugins using your `ape-config.yaml` file.

For example, when using the `vyper` plugin, you can configure settings under the `vyper` key:

```yaml
vyper:
  version: 0.3.10
```

When using the CLI, you can also specify settings using the `--config-override`.
This is not limited to compiler settings; you can include other settings, such as `"contracts_folder"`, which affects compiling.

```shell
ape compile --config-override '{"contracts_folder": "other_contracts", "vyper": {"evm_version": "paris"}, "solidity": {"evm_version": "paris"}}'
```

Finally, you can also configure settings in Python code:

```python
from pathlib import Path
from ape import compilers

settings = {"vyper": {"version": "0.3.7"}, "solidity": {"version": "0.8.0"}}
compilers.compile(
   ["path/to/contract.vy", "path/to/contract.sol"], settings=settings
)

# Or, more explicitly:
vyper = compilers.get_compiler("vyper", settings=settings["vyper"])
vyper.compile([Path("path/to/contract.vy")])

solidity = compilers.get_compiler("solidity", settings=settings["solidity"])
solidity.compile([Path("path/to/contract.sol")])
```

## Compile Source Code

Instead of compiling project source files, you can compile code (str) directly:

```python
from ape import accounts, compilers

CODE = """
   ... source code here
"""

container = compilers.compile_source(
   "vyper",
   CODE,
   settings={"vyper": {"version": "0.3.7"}}, 
   contractName="MyContract",
)

owner = accounts.test_accounts[0]

instance = container.deploy(sender=owner)
```

## Output Extra

Sometimes, there are extra output styles you may want.
For example, to output minified ABI JSONs, use the following config:

```yaml
compile:
  output_extra:
     - ABI
```

Then, after compiling, you should notice minified ABI json files in your `.build/abi` folder.
This is useful if hosting these files on a web-server.

To see the full list of supported output-extra, see [the OutpuExtra enum documentation](../methoddocs/ape_compile.html#ape_compile.OutputExtras).
# Configure Ape

You can configure Ape using a `pyproject.toml` file and the prefix `tool.ape` or any configuration file named `ape-config.[yaml|yml|json]`.
There are two locations you can place config files.

1. In the root of your project
2. In your `$HOME/.ape` directory (global)

Project settings take precedence, but global settings allow you to configure preferences across all projects, such as your default mainnet provider (e.g. Alchemy versus running your own node).

This guide serves as an index of some settings you can include in any `ape-config.yaml` file.
This guide is **PURPOSELY** alphabetized to facilitate easier look-up of keys.
Plugins for Ape may define their own configs.

Most of the features in this guide are documented more-fully elsewhere in the user-guides.

However, here is a list of common-use cases requiring the `ape-config.yaml` file to help you:

1. Setting up a custom node RPC: See the [node](#node) section.
2. Setting up project dependencies: See the [dependencies](#dependencies) section.
3. Declaring your project's plugins: See the [plugins](#plugins) section.

**Environment Variables**: `ape-config.yaml` files support environment-variable expansion.
Simply include environment variables (with the `$` prefix) in your config file and Ape will automatically expand them.

```toml
[tool.ape.plugin]
secret_rpc = "$MY_SECRET_RPC"
```

Or the equivalent YAML:

```yaml
plugin:
  secret_rpc: $MY_SECRET_RPC
```

This helps keep your secrets out of Ape!

## Base Path

Change the base path if it is different than your project root.
For example, imagine a project structure like:

```
project
└── src/
    └── contracts/
        └── MyContract.sol
```

In this case, you want to configure Ape like:

```toml
[tool.ape]
base_path = "src"
```

Or the equivalent YAML:

```yaml
base_path: src
```

This way, `MyContract.vy`'s source ID will be `"contracts/Factory.vy"` and not `"src/contracts/Factory.vy"`.
Some dependencies, such as python-based ones like `snekmate`, use this structure.

## Contracts Folder

Specify a different path to your `contracts/` directory.
This is useful when using a different naming convention, such as `src/` rather than `contracts/`.

```toml
[tool.ape]
contracts_folder = "src"
```

Or the equivalent YAML:

```yaml
contracts_folder: src
```

You can also use an absolute path.
This is useful for projects that compile contracts outside their directory.

```yaml
contracts_folder: "~/GlobalContracts"
```

## Default Ecosystem

You can change the default ecosystem by including the following:

```toml
[tool.ape]
default_ecosystem = "fantom"
```

Or the equivalent YAML:

```yaml
default_ecosystem: fantom
```

The default ecosystem is `ethereum`.

## Dependencies

Configure dependencies for your ape project.
To learn more about dependencies, see [this guide](./dependencies.html).

A simple example of configuring dependencies looks like this:

```toml
[[tool.ape.dependencies]]
name = "openzeppelin"
github = "OpenZeppelin/openzeppelin-contracts"
version = "4.4.2"
```

Or the equivalent YAML:

```yaml
dependencies:
  - name: openzeppelin
    github: OpenZeppelin/openzeppelin-contracts
    version: 4.4.2
```

## Deployments

Set deployments that were made outside of Ape in your `ape-config.yaml` to create past-deployment-based contract instances in Ape:
(See [this example](./contracts.html#from-previous-deployment) for more information on this feature).

Config example:

```toml
[[tool.ape.deployments.ethereum.mainnet]]
contract_type = "MyContract"
address = "0x5FbDB2315678afecb367f032d93F642f64180aa3"

[[tool.ape.deployments.ethereum.sepolia]]
contract_type = "MyContract"
address = "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512"
```

Or the equivalent YAML:

```yaml
deployments:
  ethereum:
    mainnet:
      - contract_type: MyContract
        address: 0x5FbDB2315678afecb367f032d93F642f64180aa3
    sepolia:
      - contract_type: MyContract
        address: 0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512
```

When connected to Ethereum mainnet, reference the deployment by doing:

```python
from ape import project

contract = project.MyContract.deployments[0]
```

```{note}
Ape does not add or edit deployments in your `ape-config.yaml` file.
```

## Node

When using the `node` provider, you can customize its settings.
For example, to change the URI for an Ethereum network, do:

```toml
[tool.ape.node.ethereum.mainnet]
uri = "http://localhost:5030"
```

Or the equivalent YAML:

```yaml
node:
  ethereum:
    mainnet:
      uri: http://localhost:5030
```

Now, the `ape-node` core plugin will use the URL `http://localhost:5030` to connect and make requests.

```{warning}
Instead of using `ape-node` to connect to an Infura or Alchemy node, use the [ape-infura](https://github.com/ApeWorX/ape-infura) or [ape-alchemy](https://github.com/ApeWorX/ape-alchemy) provider plugins instead, which have their own way of managing API keys via environment variables.
```

For more information on networking as a whole, see [this guide](./networks.html).

## Networks

Set default network and network providers:

```toml
[tool.ape.ethereum]
default_network = "mainnet-fork"

[tool.ape.ethereum.mainnet_fork]
default_provider = "hardhat"
```

Or the equivalent YAML:

```yaml
ethereum:
  default_network: mainnet-fork
  mainnet_fork:
    default_provider: hardhat
```

Set the gas limit for a given network:

```yaml
ethereum:
  default_network: mainnet-fork
  mainnet_fork:
    gas_limit: max
```

You may use one of:

- `"auto"` - gas limit is estimated for each transaction
- `"max"` - the maximum block gas limit is used
- A number or numeric string, base 10 or 16 (e.g. `1234`, `"1234"`, `0x1234`, `"0x1234"`)
- An object with key `"auto"` for specifying an estimate-multiplier for transaction insurance

To use the auto-multiplier, make your config like this:

```yaml
ethereum:
  mainnet:
    gas_limit:
      auto:
        multiplier: 1.2  # Multiply 1.2 times the result of eth_estimateGas
```

For the local network configuration, the default is `"max"`. Otherwise, it is `"auto"`.

## Plugins

Set which `ape` plugins you want to always use.

```{note}
The `ape-` prefix is not needed and shouldn't be included here.
```

```toml
[[tool.ape.plugins]]
name = "solidity"
version = "0.1.0b2"

[[tool.ape.plugins]]
name = "ens"
```

Or the equivalent YAML:

```yaml
plugins:
  - name: solidity # ape-solidity plugin
    version: 0.1.0b2
  - name: ens
```

Install these plugins by running command:

```bash
ape plugins install .
```

## Request Headers

For Ape's HTTP usage, such as requests made via `web3.py`, optionally specify extra request headers.

```yaml
request_headers:
  # NOTE: Only using Content-Type as an example; can be any header key/value.
  Content-Type: application/json
```

You can also specify request headers at the ecosystem, network, and provider levels:

```yaml
# NOTE: All the headers are the same only for demo purposes.
# You can use headers you want for any of these config locations.
ethereum:
  # Apply to all requests made to ethereum networks.
  request_headers:
    Content-Type: application/json
  
  mainnet:
    # Apply to all requests made to ethereum:mainnet (using any provider)
    request_headers:
      Content-Type: application/json
  
node:
  # Apply to any request using the `node` provider.
  request_headers:
    Content-Type: application/json
```

To learn more about how request headers work in Ape, see [this section of the Networking guide](./networks.html#request-headers).

## Testing

Configure your test accounts:

```yaml
test:
  mnemonic: test test test test test test test test test test test junk
  number_of_accounts: 5
```

## Plugin Settings

To configure a plugin, use the name of the plugin followed by any of the plugin's settings.
For example, to configure the `ape-solidity` plugin, you would do:

```yaml
solidity:
  evm_version: paris  # Or any other setting defined in `ape-solidity`.
```

## Non-plugin settings

Projects can use their own settings.
Meaning, you can put whatever data you want in an `ape-config.yaml` file and read it in Ape.

```{note}
These types of settings lack sophisticated Pydantic validation and are limited in that respect.
Simple validation, however, will occur, such as if it the value `isnumeric()`, it will be converted to an int, or if the value is a boolean name it will convert it to a `bool`.
```

```yaml
my_project_key:
  my_string: "my_value"
  my_int: 123
  my_bool: True
```

Then, to access it (or any setting for that matter):

```python
from ape import project

my_str = project.config.my_project_key.my_string  #  "my_value"
my_int = project.config.my_project_key.my_int  #  123
my_bool = project.config.my_project_key.my_bool  #  True
```
# Console

Ape provides an [IPython](https://ipython.readthedocs.io/) interactive console with useful pre-defined locals to interact with your project.

```bash
ape console --network ethereum:mainnet

In [1]: chain.blocks.head.timestamp
Out[1]: 1647323479
```

```{warning}
Contract changes are not reflected in the active console session.
If you need to make changes to your contract, you must re-start your console session for the compiler to handle the changes.
```

## Ape Namespace

Your console comes with pre-initialized root ape objects in your namespace.

|    Name    |                                                   Class                                                    |
| :--------: | :--------------------------------------------------------------------------------------------------------: |
| `accounts` |       [AccountManager](../methoddocs/managers.html?highlight=accounts#module-ape.managers.accounts)        |
| `networks` |       [NetworkManager](../methoddocs/managers.html?highlight=networks#module-ape.managers.networks)        |
|  `chain`   |           [ChainManager](../methoddocs/managers.html?highlight=chain#module-ape.managers.chain)            |
| `project`  |    [ProjectManager](../methoddocs/managers.html?highlight=project#module-ape.managers.project.manager)     |
|  `query`   |           [QueryManager](../methoddocs/managers.html?highlight=query#module-ape.managers.query)            |
| `convert`  | [convert](../methoddocs/managers.html?highlight=query#ape.managers.converters.AddressAPIConverter.convert) |
|   `ape`    |                                       [ape](../methoddocs/ape.html)                                        |

You can access them as if they are already initialized:

First, launch the console:

```bash
ape console
```

Then, type the name of the item and you will see its Python representation:

```python
In [1]: networks
Out[1]: <NetworkManager active_provider=<test chain_id=61>>
```

```{note}
To change the network of the active console, use the `--network` option.
```

Follow [this guide](./networks.html) for more information on networks in Ape.

## Namespace Extras

You can also create scripts to be included in the console namespace by adding a file (`ape_console_extras.py`) to your root project directory. All non-internal symbols from this file will be included in the console namespace. Internal symbols are prefixed by an underscore (`_`).

An example file might look something like this:

```python
from ape import networks
from eth_utils import encode_hex, decode_hex

def latest(key):
    return getattr(networks.active_provider.get_block("latest"), key)
```

Then both imported util functions and `latest()` will be available when you launch the console.

```python
In [1]: latest('number')
Out[1]: 14388241

In [2]: encode_hex(latest('hash'))
Out[2]: '0x68f768988e9bd4be971d527f72483f321975fa52aff9692b6d0e0af71fb77aaf'
```

### Init Function

If you include a function named `ape_init_extras`, it will be executed with the symbols from the existing namespace being provided as keyword arguments. This allows you to alter the scripts namespace using locals already included in the Ape namespace. If you return a `dict`, these values will be added to the console namespace. For example, you could set up an initialized Web3.py object by using one from an existing Ape Provider.

```python
def ape_init_extras(chain):
    return {"web3": chain.provider.web3}
```

Then `web3` will be available to use immediately.

```python
In [1]: web3.eth.chain_id
Out[1]: 1
```

### Global Extras

You can also add an `ape_console_extras.py` file to the global ape data directory (`$HOME/.ape/ape_console_extras.py`) and it will execute regardless of what project context you are in. This may be useful for variables and utility functions you use across all of your projects.

## Configure

To automatically use other IPython extensions, add them to your `ape-config.yaml` file:

```yaml
console:
  plugins:
    # A plugin that lets you modify Python modules without having close/reopen your console.
    - autoreload
```

## Magic Commands

The `ape-console` plugin ships with custom [magics](https://ipython.readthedocs.io/en/stable/interactive/magics.html#line-magics) that are available when running the `ape console` command or loading the `ape_console.plugin` IPython extension manually.
When starting an embedded console (from `-I` in `ape run` or `ape test`), you will have to load the extension manually.
To do this, run the following from _any_ `IPython` environment:

```shell
In [1]: %load_ext ape_console.plugin
```

Or add the `ape_console.plugin` extension to your `IPython` config.

Otherwise, when launching `ape console`, the magics are automatically available.

### %ape

The `%ape` magic invokes the CLI in your `ape-console` session:

```shell
In [1]: %ape
Usage: cli [OPTIONS] COMMAND [ARGS]...

Options:
  -v, --verbosity LVL  One of ERROR, WARNING, SUCCESS, INFO, or DEBUG
  --version            Show the version and exit.
  --config             Show configuration options (using `ape-config.yaml`)
  -h, --help           Show this message and exit.

Commands:
  accounts  Manage local accounts
  cache     Query from caching database
  compile   Compile select contract source files
  console   Load the console
  init      Initialize an ape project
  networks  Manage networks
  plugins   Manage ape plugins
  run       Run scripts from the `scripts/` folder
  test      Launches pytest and runs the tests for a project

Out[1]: <Result okay>
```

Run any CLI command this way without exiting your session.

### %bal

The `%bal` magic outputs a human-readable balance on an account, contract, address, or account alias.

```shell
In [1]: account = accounts.load("metamask0")

In [2]: %bal account
Out[2]: '0.00040634 ETH'

In [3]: %bal metamask0
Out[3]: '0.00040634 ETH'

In [4]: %bal 0xE3747e6341E0d3430e6Ea9e2346cdDCc2F8a4b5b
Out[4]: '0.00040634 ETH'
```

## Executing Code

You can also use the `ape console` to execute programs directly from strings.
This is similar to the `python -c|--code` option except it will display the output cell.
Anything available in `ape console` is also available in `ape console --code`.

```shell
ape console -c 'project.name'
Out[1]: 'my-project'
ape console -c 'x = 3\nx + 1'
Out[1]: 4
ape console -c 'networks.active_provider.name'
Out[1]: 'test'
```
# Contracts

You can interact with contracts pythonically using ape!
First, we need to obtain a contract instance.
One way to do this is to deploy a contract.
The other way is to initialize an already-deployed contract using its address.

## From Deploy

Deploy contracts from your project using the `project` root-level object.
You deploy contracts using Python functions such as [AccountAPI.deploy](../methoddocs/api.html#ape.api.accounts.AccountAPI.deploy) or [ContractContainer.deploy](../methoddocs/contracts.html#ape.contracts.base.ContractContainer.deploy).

```{note}
You can run Ape's deploy functions anywhere you run Python!
```

You need both an account and a contract in order to deploy a contract, as the deployment process requires a transaction to submit the contract data to the blockchain.
To learn about accounts and how to use them, see the [Accounts Guide](./accounts.html).
You also need the contract.
You can access contract types from Ape's root-level `project` object (e.g. `project.MyContract`) and their types are [ContractContainer](../methoddocs/contracts.html#ape.contracts.base.ContractContainer).

Let's assume you have a Vyper contract like this:

```vyper
contract MySmartContract:
    owner: public(address)
    balance: public(uint256)

    @public
    @payable
    @public
    def __init__(arg1: uint256, arg2: address):
        self.owner = arg2
        self.balance = arg1
```

Before you can deploy this contract, you must ensure it was compiled.
To learn about compiling in Ape, please see [this guide](./compile.html).

After it is compiled, you can deploy it.
Here is a basic example of Python code to deploy a contract:

```python
from ape import accounts, project

# You need an account to deploy, as it requires a transaction.
account = accounts.load("<ALIAS>")  # NOTE: <ALIAS> refers to your account alias!
contract = project.MyContract.deploy(1, account, sender=account)

# NOTE: You can also do it this way:
contract2 = account.deploy(project.MyContract, 1, account)
```

The arguments to the constructor (`1, account`) can be in Python form.
Ape will automatically convert values in your transactions, thus allowing you to provide higher-level objects or abstractions as input types.
That is why, as you can see, the second argument is an `AccountAPI` object for the type `address` in the contract.

Notice in the example, we use `project.MyContract` to access the contract type.
To avoid naming collisions with other properties on the `project` object, you can alternatively use the [get_contract()](../methoddocs/managers.html#ape.managers.project.manager.ProjectManager.get_contract) method to retrieve contract containers.

```python
from ape import project

contract = project.get_contract("MyContract")  # Same as `project.MyContract`.
```

Notice when deploying, we have to specify the `sender=` kwarg because `deploy` operations are transactions.
To learn more about contract interaction via transactions, see the [Contract Interaction](#contract-interaction) section below and the [guide on transactions](./transactions.html).

### Deploy Scripts

Often time, the deployment process may be unique or complex.
Or possibly, you need to run the deploy-logic from CI or in a repeatable fashion.
Or perhaps, you just want to avoid having to invoking Python directly.
In those cases, you can use Ape's scripting system to save time and store your deployment logic.
Simply copy your Python logic into an Ape script and run it via:

```shell
ape run <my-deploy-script>
```

Learn how to do this and scripting in its entirety by reviewing [the scripting user-guide](./scripts.html).

**There is no root `ape` command to deploy contracts; only the scripting-system, the `console`, or merely using Ape as a Python library**.

If your deployment process is simple or only needs to happen once, it is easy to use `ape console` to achieve a deployment.
More information on how to use `ape console` can be found [here](./console.html).

### Publishing

You can also publish the contract source code to an explorer upon deployment using the `publish=` kwarg on the deploy methods.
More information on publishing contracts can be found in [this guide](./publishing.html).

## From Project Contract Address

You can also use the [at() method](../methoddocs/contracts.html#ape.contracts.base.ContractContainer.at) from the same top-level project manager when you know the address of an already-deployed contract:

```python
from ape import project

contract = project.MyContract.at("0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45")
```

## From Any Address

If you already know the address of a contract, you can create instances of it using the `Contract` top-level factory:

```python
from ape import Contract

contract = Contract("0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45")
```

It will fetch the `contract-type` using the explorer plugin from the active network, such as [ape-etherscan](https://github.com/ApeWorX/ape-etherscan).

If you have the [ENS plugin](https://github.com/ApeWorX/ape-ens) installed, you can use `.eth` domain names as the argument:

```python
from ape import Contract

contract = Contract("v2.registry.ychad.eth")
```

## From ABIs

You can load contracts using their ABIs:

```python
from ape import Contract

address = "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45"

# Using a JSON str:
contract = Contract(
    address, abi='[{"name":"foo","type":"fallback", "stateMutability":"nonpayable"}]'
)

# Using a JSON file path:
contract = Contract(address, abi="abi.json")

# Using a Python dictionary from JSON:
contract = Contract(
    address,
    abi=[{"name":"foo","type":"fallback", "stateMutability":"nonpayable"}]
)
```

This will create the Contract instance from the given ABI.

## From Previous Deployment

Ape keeps track of your deployments for you so you can always refer back to a version that you deployed previously.
On live networks, this history of deployments is saved; on local networks, this history lasts for the duration of your script.

Let's say you previously deployed a smart contract called `MyContract` on the rinkeby test network.
You could then refer back to it like so:

```python
from ape import project, chain

def main():
  my_contract = chain.contracts.get_deployments(project.MyContract)[-1]
```

or

```python
from ape import project

def main():
  my_contract = project.MyContract.deployments[-1]
```

`my_contract` will be of type `ContractInstance`.
`get_deployments` returns a list of deployments you made of that contract type.

## Contract Interaction

Then, after you have a contract instance, you can call methods on the contract.
For example, let's say you have a Vyper contract containing some functions:

```python
wdAmount: public(uint256)

@pure
@external
def get_static_list() -> DynArray[uint256, 3]:
    return [1, 2, 3]

@external
def set_number(num: uint256):
    assert msg.sender == self.owner, "!authorized"
    self.prevNumber = self.myNumber
    self.myNumber = num

@external
@payable
def withdraw():
    self.wdAmount = msg.value
```

Notice the contract has an external pure method, an external method that modifies state, and an external payable method that also modifies state using the given `msg.value`.
In EVM languages, methods that modify state require a transaction to execute because they cost money.
Modifying the storage of a contract requires gas and thus requires a sender with enough funding.
Methods that accept value are `payable` (e.g. `msg.value` in Vyper); provide additional value (e.g. Ether) to these methods.
Contract calls, on the other hand, are read-operations and do not cost anything.
Calls are never payable.
Thus, calls do not require specifying a `sender=` in Ape.

At the RPC level, Ethereum calls are performed using the `eth_call` RPC and transactions are performed using the `eth_sendTransaction` or `eth_sendRawTransaction` RPCs.

The following sub-sections show how, using Ape, we can invoke or call the methods defined above.

### Transactions

The following example demonstrates invoking a contract's method in Ape as a transaction.
Remember: transactions cost money, whether they are payable or not.
Payable transactions cost more money, because the contract-logic requires additional value (e.g. Ether) to be forwarded with the call.

Before continuing, take note that there is a [separate guide](./transactions.html) which fully covers transactions in Ape at a more granular level.
For this guide, assume we are using the default transaction type in Ape for Ethereum-based networks.

```python
from ape import accounts, Contract

account = accounts.load("<ALIAS>")
contract = Contract("0x...")  # Assume is deployed version of code above

# Transaction: Invoke the `set_number()` function, which costs Ether
receipt = contract.set_number(sender=account)
assert not receipt.failed

# The receipt contains data such as `gas_used`.
print(receipt.gas_used)
```

To provider additional value to a payable method, use the `value=` kwarg:

```python
receipt = contract.withdraw(sender=account, value=123)
print(receipt.gas_used)

# NOTE: You can also use "smart" values such as `"0.1 ether"` or `"100 gwei"`:
_ = contract.withdraw(sender=account, value="0.1 ether")
_ = contract.withdraw(sender=account, value="100 gwei")
_ = contract.withdraw(sender=account, value="1 wei")
```

Notice that transacting returns a [ReceiptAPI](../methoddocs/api.html#ape.api.transactions.ReceiptAPI) object which contains all the receipt data, such as `gas_used`.

```{note}
If you need the `return_value` from a transaction, you have to either treat transaction as a call (see the section below!) or use a provider with tracing-features enabled (such as `ape-foundry` or `ape-node`) and access the [return_value](../methoddocs/api.html#ape.api.transactions.ReceiptAPI.return_value) property on the receipt.
```

```python
assert receipt.return_value == 123
```

Transactions may also fail, known as a "revert".
When a transaction reverts, Ape (by default) raises a subclass of `TransactionError`, which is a Python exception.
To learn more reverts, see the [reverts guide](./reverts.html).

For more general information on transactions in the Ape framework, see [this guide](./transactions.html).

### Calls

In the Vyper code at the beginning of this section, the function `get_static_list()` is decorated as `@pure` indicating that it's read-only.
(Also in Vyper, `@view` methods are read-only).
Since `get_static_list()` is read-only, we can successfully call it without a `sender=` kwarg; no funds are required.
Here is an example of making a call by checking the result of `get_static_list()`:

```python
from ape import accounts, Contract

account = accounts.load("<ALIAS>")
contract = Contract("0x...")

# CALL: A sender is not required for calls!
assert contract.get_static_list() == [1, 2, 3]
```

### Calling Transactions and Transacting Calls

You can treat transactions as calls and vice-versa.

For example, let's say we have a Solidity function:

```solidity
function addBalance(uint256 new_bal) external returns(uint256) {
    balances[msg.sender] = new_bal;
    return balances[msg.sender];
}
```

To simulate the transaction without actually modifying any state, use the `.call` method from the contract transaction handler:

```python
from ape import Contract

contract = Contract("0x...")

result = contract.addBalance.call(123)
assert result == "123"  # The return value gets forwarded from the contract.
```

Similarly, you may want to measure a call as if it were a transaction, in which case you can use the `.transact` attribute on the contract call handler:

Given the Solidity function:

```solidity
function getModifiedBalance() external view returns(uint256) {
    return balances[msg.sender] + 123;
}
```

You can treat it like a transaction by doing:

```python
from ape import accounts, Contract

account = accounts.load("<ALIAS>")
contract = Contract("0x...")

receipt = contract.getModifiedBalance.transact(sender=account)
assert not receipt.failed  # Transactions return `ReceiptAPI` objects.
print(receipt.gas_used)  # Analyze receipt gas from calls.
```

### Default, Fallback, and Direct Calls

To directly call an address, such as invoking a contract's `fallback` or `receive` method, call a contract instance directly:

```python
from ape import Contract, accounts

sender = accounts.load("<ALIAS>")  # NOTE: <ALIAS> refers to your account alias!
contract = Contract("0x123...")

# Call the contract's fallback method.
receipt = contract(sender=sender, gas=40000, data="0x123")
```

### Private Transactions

If you are using a provider that allows private mempool transactions, you are able to use the `private=True` kwarg to publish your transaction into a private mempool.
For example, EVM providers likely will use the `eth_sendPrivateTransaction` RPC to achieve this.

To send a private transaction, do the following:

```python
receipt = contract.set_number(sender=dev, private=True)
```

The `private=True` is available on all contract interactions.

## Decoding and Encoding Inputs

If you want to separately decode and encode inputs without sending a transaction or making a call, you can achieve this with Ape.
If you know the method you want to use when decoding or encoding, you can call methods `encode_input()` or `decode_input()` on the method handler from a contract:

```python
from ape import Contract

# HexBytes(0x3fb5c1cb00000000000000000000000000000000000000000000000000000000000000de)
contract = Contract("0x...")
bytes_value = contract.my_method.encode_input(0, 1, 2)
```

In the example above, the bytes value returned contains the method ID selector prefix `3fb5c1c`.
Alternatively, you can decode input:

```python
from eth_pydantic_types import HexBytes
from ape import Contract

contract = Contract("0x...")
selector_str, input_dict = contract.my_method.decode_input(HexBytes("0x123..."))
```

In the example above, `selector_str` is the string version of the method ID, e.g. `my_method(unit256,uint256)`.
The input dict is a mapping of input names to their decoded values, e.g `{"foo": 2, "owner": "0x123..."}`.
If an input does not have a name, its key is its stringified input index.

If you don't know the method's ABI and you have calldata, you can use a `ContractInstance` or `ContractContainer` directly:

```python
import ape

# Fetch a contract
contract = ape.Contract("0x...")

# Alternative, use a contract container from ape.project
# contract = ape.project.MyContract

# Only works if unique amount of args.
bytes_value = contract.encode_input(0, 1, 2, 4, 5)
method_id, input_dict = contract.decode_input(bytes_value)
```

## Contract Interface Introspection

There may be times you need to figure out ABI selectors and method or event identifiers for a contract.
A contract instance provides properties to make this easy.
For instance, if you have a 4-byte hex method ID, you can return the ABI type for that method:

```python
import ape

usdc = ape.Contract("0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48")

# ABI type for a hex method ID
assert usdc.identifier_lookup['0x70a08231'].selector == 'balanceOf(address)'

# Also, selectors from method and event signatures
assert usdc.selector_identifiers["balances(address)"] == "0x27e235e3"

# Or dump all selectors and IDs
for identifier, abi_type in usdc.identifier_lookup.items():
    print(identifier, abi_type)
    # 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef type='event' name='Transfer' inputs=...
    # ...
```

These include methods and error IDs, as well as event topics.

## Multi-Call and Multi-Transaction

The `ape_ethereum` core plugin comes with a `multicall` module containing tools for interacting with the [multicall3 smart contract](https://github.com/mds1/multicall).
Multicall allows you to group function calls and transactions into a single call or transaction.

Here is an example of how you can use the multicall module:

```python
import ape
from ape_ethereum import multicall

ADDRESSES = ("0xF4b8A02D4e8D76070bD7092B54D2cBbe90fa72e9", "0x80067013d7F7aF4e86b3890489AcAFe79F31a4Cb")
POOLS = [ape.project.IPool.at(a) for a in ADDRESSES]

def main():
    # Use multi-call.
    call = multicall.Call()
    for pool in POOLS:
        call.add(pool.getReserves)

    print(list(call()))

    # Use multi-transaction.
    tx = multicall.Transaction()
    for pool in POOLS:
        tx.add(pool.ApplyDiscount, 123)

    acct = ape.accounts.load("signer")
    for result in tx(sender=acct):
        print(result)
```
# Querying Data

Ape has advanced features for querying large amounts of on-chain data.
Ape provides this support through a number of standardized methods for working with data,
routed through our query management system, which incorporates data from many sources in
your set of installed plugins.

## Getting Block Data

Use `ape console`:

```bash
ape console --network ethereum:mainnet:infura
```

Run a few queries:

```python
In [1]: df = chain.blocks.query("*", stop_block=20)
In [2]: chain.blocks[-2].transactions  # List of transactions in block
```

## Getting Account Transaction Data

Each account within ape will also fetch and store transactional data that you can query.
To work with an account's transaction data, you can do stuff like this:

```python
from ape import accounts, chain

chain.history["example.eth"].query("value").sum()  # All value sent by this address
acct = accounts.load("my-acct")
tx = acct.history[-1]  # Last txn `acct` made
acct.history.query("total_fees_paid").sum()  # Sum of ether paid for fees by `acct`
```

## Getting Contract Event Data

On a deployed contract, you can query event history.

For example, we have a contract with a `FooHappened` event that you want to query from.
This is how you would query the args from an event:

```python
In [1]: df = contract_instance.FooHappened.query("*", start_block=-1)
```

where `contract_instance` is the return value of `owner.deploy(MyContract)`

See [this guide](../userguides/contracts.html) for more information how to deploy or load contracts.

## Using the Cache

```{note}
This is in Beta release.
This functionality is in constant development and many features are in planning stages.
Use the cache plugin to store provider data in a sqlite database.
```

To use the cache, first you must initialize it for each network you plan on caching data for:

```bash
ape cache init --network <ecosystem-name>:<network-name>
```

```{note}
Caching only works for permanently available networks. 
It will not work with local development networks.
```

For example, to initialize the cache database for the Ethereum mainnet network, you would do the following:

```bash
ape cache init --network ethereum:mainnet
```

This creates a SQLite database file in ape's data folder inside your home directory.

You can query the cache database directly, for debugging purposes.
The cache database has the following tables:

| Table Name        | Dataclass base |
| ----------------- | -------------- |
| `blocks`          | `BlockAPI`     |
| `transactions`    | `ReceiptAPI`   |
| `contract_events` | `ContractLog`  |
# Dependencies

Ape downloads and caches dependencies in the `.ape/packages` folder.
There are three sub-folders in `.ape/packages` for dependencies:

1. `projects/` - contains the raw project files for each dependency in subsequent `/<name>/<version-id>` directories (where `<name>` refers to the path-ified full-name of the dependency, e.g. `"OpenZeppelin_openzeppelin-contracts"`, and `<version-id>` refers to the version or branch of the package).
   This location is where local project compilation looks for additional sources from import statements.
2. `manifests/` - much like your local projects' `.build/__local__.json`, this is where dependencies cache their manifests.
   When you compile a dependency, the contract types are stored in the dependency manifest's JSON file.
3. `api/` - for caching the API data placed in `dependencies:` config or `ape pm install` commands, allowing dependency usage and management from anywhere in the file system.

```{note}
You can install dependencies that don't compile out-of-the-box.
Sometimes, dependencies are only collections of source files not meant to compile on their own but instead be used in projects via import statements.
You can change the settings of a dependency using `config_override:` to compile dependencies after installed, if needed, and the `api/` cache always refers to the latest used during installation or compilation.
```

## Types of Dependencies

There are few dependency types that come with Ape.
The following section highlights how to use each of them and what their differences are.

### GitHub

You can use dependencies from GitHub.
For example, a common dependency for Solidity projects is [Open Zeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts).
To use Open Zeppelin version 4.4.2 in your Ape Solidity project, add the following to your `ape-config.yaml` file:

```yaml
dependencies:
  - name: OpenZeppelin
    github: OpenZeppelin/openzeppelin-contracts
    version: 4.4.2
```

Then, follow the guide below about `remappings` to use the dependency.

```{warning}
**An important WARNING about the `version:` key for GitHub dependencies:**
The `version:` config first attempts to use an official GitHub release, but if the release is not found, it will check the release tags.
```

If you know the version is not available as an official release, bypass the original check by using the `ref:` key.
The `ref:` key is also used for installing branches.

For example, to install a version available as a `git` tag, do the following:

```yaml
dependencies:
  - name: Uniswap
    github: Uniswap/v3-core
    ref: v1.0.0
```

The `ref:` config installs the code from that reference; the `version:` config uses the official GitHub release API, and then only if that fails will it check the `git` references.
Often times, the `v` prefix is required when using tags.
However, if cloning the tag fails, `ape` will retry with a `v` prefix.
Bypass the original failing attempt by including a `v` in your dependency config.

**By knowing if the release is from the version API or only available via tag, and whether the version is v-prefixed or not, you save Ape some time and complexity when installing dependencies.**

### PyPI

You can use dependencies from [PyPI](https://pypi.org/) by using the `pypi:` key.

```yaml
dependencies:
   - pypi: snekmate
     config_override:
       base_path: src
       contracts_folder: snekmate
```

When using the `pypi:` key, dependencies are downloaded and extracted from PyPI using an HTTP requests library.

You can also specify the `python:` key for already-installed dependencies:

```yaml
dependencies:
   - python: snekmate
     config_override:
       contracts_folder: .
```

Using `python:` requires the package to be installed in your `sys.path` (site-packages) folder, generally via `pip` or some other tool.
The `contracts_folder` override, in this case, is often needed because the site-package does not have the root source-folder included.
Additionally, `python:` specified dependencies may also be lacking project-configuration files, such as the `ape-config.yaml`.
Compilers such as `vyper` encourage users to use `pip` to publish and install smart-contract dependencies (other vyper files), but some features in Ape may be limited if the dependency is not also specified in your config somewhere.

If wanting to use a dependency from `PyPI`, we recommend using the `pypi:` key instead of the `python:` key.
However, the `python:` key works great if you already used `pip` to install the dependency, especially if the dependency is not available on `PyPI`.

### Local

You can use already-downloaded projects as dependencies by referencing them as local dependencies.

```yaml
dependencies:
  - name: MyDependency
    local: local/path/to/MyDependency
```

This is helpful when:

- Working on multiple packages at once.
- When there is not a suitable `DependencyAPI` implementation available for downloading your dependency.
- Testing the framework.

You can also reference local project manifests and use those as dependencies.
To do this, use a local value pointing to the manifest file, like this:

```yaml
dependencies:
  - name: MyDependency
    local: ./my-dependency.json
    version: 1.0.0
```

### NPM

You can use dependencies from NPM.
This is generally not recommended.
However, sometimes it is the only way to use a dependency.

To use a dependency from NPM, you must have already run `npm install` and that package must be present in your local `node_modules` folder.
Then, add the following to your config so that Ape can find the dependency:

```yaml
dependencies:
  - name: MyDependency
    npm: "@myorg/mydependency"
    version: v1.3.0
```

## Package Management CLI

You can also install and / or compile dependencies using the `pm` CLI.

### list

To list information about installed dependencies, run:

```shell
ape pm list
```

You should see information like:

```shell
NAME                                 VERSION  INSTALLED  COMPILED
OpenZeppelin/openzeppelin-contracts  4.9.3    True       False
```

### install

To install all dependencies in your project, run:

```shell
ape pm install
```

If the dependencies are already cached and you want to re-install them, use the `--force` flag:

```shell
ape pm install --force
```

To install a dependency that is not in your config, you can specify it directly along with `--name` and `--version`:

```shell
ape pm install gh:OpenZeppelin/openzeppelin-contracts --name openzeppelin --version "4.6.0"
```

```{note}
The `gh:` prefix is used because this dependency is from GitHub.
For `npm` dependencies, you use an `npm:` prefix.
For local dependencies, you give it a path to the local dependency.
`--version` is not required when using a local dependency.
```

To change the config of a dependency when installing, use the `--config-override` CLI option:

```shell
ape pm install gh:OpenZeppelin/openzeppelin-contracts \
  --name openzeppelin \
  --version "4.6.0" \
  --config-override '{"solidity": {"version": "0.8.12"}}'
```

You can also use Python to install dependencies, using `**kwargs` as the same fields you put in your `dependencies:` config:

```python
from ape import project

project.dependencies.install(
   github="OpenZeppelin/openzeppelin-contracts", name="openzeppelin", version="4.4.2"
)
```

### uninstall

Remove previously installed packages using the `uninstall` command, providing it either the dependency's name or package_id:

```shell
ape pm uninstall OpenZeppelin
```

```shell
ape pm uninstall OpenZeppelin/openzeppelin-contracts
```

If there is a single version installed, the command will remove the single version.
If multiple versions are installed, pass additional arguments specifying the version(s) to be removed:

```shell
ape pm uninstall OpenZeppelin 4.5.0 4.6.0
```

To skip the confirmation prompts, use the `--yes` flag (abbreviated as `-y`):

```shell
ape pm uninstall OpenZeppelin all --yes
```

```{note}
Additionally, use the `all` special version key to delete all versions.
```

### compile

Dependencies are not compiled when they are installed.
Dependencies are only compiled if you need them to be.
This is because often times a dependency will not compile in Ape on its own but its contract types can still be used in your project.
However, when working with dependency contracts directly, they will need to be compiled.
Ape compiles them as soon as you request the contracts from them, so it generally happens on the backend automatically.
**However**, you may want to recompile the dependencies, like when using a new compiler version or settings.
You can use the CLI to recompile.

```shell
ape pm compile OpenZeppelin --version 4.6.0 --force
```

```{note}
You only need to specify a version if you have more than one version of a dependency installed.
Otherwise, you just give it the name.
```

To compile all dependencies in your local project, run the command with no arguments while in your project:

```shell
ape pm compile
```

Alternatively, you can compile dependencies along with your project's contracts by using the `--include-dependencies` flag in `ape-compile`:

```shell
ape compile --include-dependencies
```

## Misc

The following guidelines are applicable to **ALL** dependency types.

### Config Override

To use any extra config item for a dependency, such as configurations for compilers needed during compiling, use the `config_override` setting:

```yaml
dependencies:
  - name: dependency
    github: org-name/dependency-project-name
    config_override:
       solidity:
         evm_version: paris
```

This is the same as if these values were in an `ape-config.yaml` file in the project directly.

You can also specify `--config-override` in the `ape pm install` command to try different settings more adhoc:

```shell
ape pm install --config-override '{"solidity": {"evm_version": "paris"}}'
```

### Custom Contracts Folder

You can set the name of the dependency's contracts folder using the `config_override` key, e.g.:

```yaml
dependencies:
  - name: DappToolsERC20
    github: dapphub/erc20
    ref: dappnix
    config_override:
      contracts_folder: src
```

### File Exclusions

To ignore files from a dependency project, use the `exclude` setting in the `config_override:compile` section to specify glob patterns:

```yaml
dependencies:
  - name: dependency-project-name
    github: org-name/dependency-project-name
    config_override:
      compile:
        exclude:
          - package.json    # Ignore package.json files.
          - mocks/**/*      # Ignore all files in the 'mocks' directory
```

### Solidity Import Remapping

A common use-case for dependencies involves the Solidity plugin.
By default, the `ape-solidity` plugin knows to look at installed dependencies for potential remapping-values and will use those when it notices you are importing them.
For example, if you are using dependencies like:

```yaml
dependencies:
  - name: OpenZeppelin
    github: OpenZeppelin/openzeppelin-contracts
    version: 4.4.2
```

And your source files import from `openzeppelin` this way:

```solidity
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
```

Ape knows how to resolve the `@openzeppelin` value and find the correct source.

If you want to override this behavior or add new remappings that are not dependencies, you can add them to your `ape-config.yaml` under the `solidity:` key.
For example, let's say you have downloaded `openzeppelin` somewhere and do not have it installed in Ape.
You can map to your local install of `openzeppelin` this way:

```yaml
solidity:
  import_remapping:
    - "@openzeppelin=path/to/openzeppelin"
```

### Compiling Dependencies

Sometimes, you may need to access types (such as contract types) from dependencies.
You can achieve this using the project manager:

```python
from ape import accounts, project

# NOTE: This will compile the dependency
dependency_project = project.dependencies["my_dependency"]["1.0.0"]
dependency_contract = dependency_project.DependencyContractType 
my_account = accounts.load("alias")
deployed_contract = my_account.deploy(dependency_contract, "argument")
print(deployed_contract.address)
```

If you would like to always compile dependencies during `ape compile` rather than only have them get compiled upon asking for contract types, you can use the config option `include_dependencies` from the `compile` config:

```yaml
compile:
  include_dependencies: true
```

Alternatively, use the `--include-dependencies` CLI flag:

```shell
ape compile --include-dependencies
```
# Developing Plugins

Your plugin project can be any type of python project, so long as its package name starts with `ape-` (such as `ape-ethereum`).
The module and plugin directory name must start with `ape_` (such as `ape_ethereum`).
To create an `ape` plugin, implement one or more API classes from the `ape.api` namespace and/or add key
`ape_cli_subcommands` to your entry-points list in your project's `setup.py`, depending on what type of plugin you want to create.
This guide is intended to assist in both of those use cases.

The following is a list of example plugins to use as a reference when developing plugins:

- [the Solidity plugin](https://github.com/apeworx/ape-solidity), an example `CompilerAPI`
- [the Infura plugin](https://github.com/apeworx/ape-infura), an example `ProviderAPI`
- [the Trezor plugin](https://github.com/apeworx/ape-trezor), an example `AccountAPI`
- [the Tokenlists plugin](https://github.com/apeworx/ape-tokens), an example CLI Extension

## Initialize a Plugin Project

As previously mentioned, a plugin project is merely a python project.
However, you can optionally use this [project template](https://github.com/ApeWorX/project-template) for initializing your plugin.

```{note}
This template is primarily designed for plugins built within the ApeWorX team organization; not everything may apply.
```

It is okay to delete anything that does not work or that you don't find helpful.
The template may be good to follow if you want to keep your plugin of similar quality to plugins developed by the ApeWorX team.

## Implementing API Classes

API classes (classes from the `ape.api` namespace) are primarily composed of abstract methods and properties that plugins must implement.
A benefit of the plugin system is that each plugin can implement these however they need, so long as they conform to the API interface.
Two plugins with the same API may do entirely different things and yet be interchangeable in their usage.

To implement an API, import its class and use it as a base-class in your implementation class.

```{warning}
The plugin will fail to work properly if you do not implement all the abstract methods.
```

```python
from ape.api import ProviderAPI
from web3 import Web3, HTTPProvider


class MyProvider(ProviderAPI):
    _web3: Web3 = None  # type: ignore
    
    def connect(self):
        self._web3  = Web3(HTTPProvider(str("https://localhost:1337")))

    """Implement rest of abstract methods"""
```

### Registering API Classes

Once you have finished implementing your API classes, you need to register them using the [@plugins.register](../methoddocs/plugins.html#ape.plugins.register) method decorator.

```python
from ape import plugins

# Here, we register our provider plugin so we can use it in 'ape'.
@plugins.register(plugins.ProviderPlugin)
def providers():
    # NOTE: By keeping this import local, we avoid slower plugin load times.
    from ape_my_plugin.provider import MyProvider
    
    # NOTE: 'MyProvider' defined in a prior code-block.
    yield "ethereum", "local", MyProvider
```

This decorator hooks into ape core and ties everything together by looking for all local installed site-packages that start with `ape_`.
Then, it will loop through these potential `ape` plugins and see which ones have created a plugin type registration.
If the plugin type registration is found, then `ape` knows this package is a plugin and attempts to process it according to its registration interface.

```{warning}
Ensure your plugin's `__init__.py` file imports quickly by keeping all expensive imports in the hook functions locally.
This helps Ape register plugins faster, which is required when checking for API implementations.
```

### CLI Plugins

The `ape` CLI is built using the python package [click](https://palletsprojects.com/p/click/).
To create a CLI plugin, create any type of `click` command (such as a `click.group` or a `click.command`).

`_cli.py`:

```python
import click

@click.group
def cli():
    """My custom commands."""


@cli.command()
def my_sub_cmd():
    """My subcommand."""
```

Then, register it using `entrypoints`, which is a built-in python registry of items declared in `setup.py`.

`setup.py`:

```python
...
entry_points={
    "ape_cli_subcommands": [
        "ape_myplugin=ape_myplugin._cli:cli",
    ],
},
...
```

```{note}
Typically, a `_cli.py` module is used instead of a `__init__.py` module for the location of the Click CLI group because it is logically separate from the Python module loading process.
```

If you try to define them together and use `ape` as a library as well, there is a race condition in the loading process that will prevent the CLI plugin from working.

For common `click` usages, use the `ape.cli` namespace.
For example, use the [@existing_alias_argument() decorator](../methoddocs/cli.html#ape.cli.arguments.existing_alias_argument)) when you need a CLI argument for specifying an existing account alias:
Follow [this guide](./clis.html) to learn more about what you can do with the utilities found in `ape.cli`.

```python
import click
from ape.cli import existing_alias_argument

@click.command()
@existing_alias_argument()
def my_cmd(alias):
  click.echo(f"{alias} is an existing account!")
```

## Using Plugins

Once you have finished implementing and registering your API classes, they will now be part of `ape`. For example,
if you implemented the `AccountAPI`, you can now use accounts created from this plugin. The top-level `ape` manager
classes are indifferent about the source of the plugin.

```python
from ape import accounts

# The manager can load accounts from any account-based plugin.
my_ledger_account = accounts.load("ledger_0")  # Created using the 'ape-ledger' plugin
my_trezor_account = accounts.load("trezor_0")  # Created using the 'ape-trezor' plugin
```

Similarly, if you implemented a `ProviderAPI`, that provider is now accessible in the CLI via the `--network` option:

```bash
ape console my_script --network ethereum:local:my_provider_plugin
```

```{note}
The `--network` option is available on the commands `test` and `console` as well as any CLI command that uses the [network option decorator](../methoddocs/cli.html?highlight=network_option#ape.cli.options.network_option).
```

To learn more about networks in Ape, follow [this guide](./networks.html).

When creating the CLI-based plugins, you should see your CLI command as a top-level command in the `ape --help` output:

```
Commands:
  ...
  my-plugin  Utilities for my plugin
  ...
```

To edit the description of the CLI command (or group), you can either set the `short_help` kwarg or use a doc-str on the command:

```python
import click


@click.command(short_help="Utilities for my plugin")
def cli():
    pass

""" Or """

@click.command()
def cli():
    """Utilities for my plugin"""
```

## Logging

Use Ape's logger in your plugin by importing it from the `ape.logging` module or by using it off the CLI context (from using the `@ape_cli_context` decorator).

### Import the logger from the logging module

```python
from ape.logging import logger

logger.info("This is a log message")
```

### Use the logger from the `@ape_cli_context`

```python
from ape.cli import ape_cli_context

@ape_cli_context()
def my_command(cli_ctx):
  cli_ctx.logger.info("my log message")
```
# Forking Networks

You can fork live networks in Ape.
To do so, ensure you are using a provider plugin with forking features.
Some options are:

1. [ApeWorX/ape-foundry](https://github.com/ApeWorX/ape-foundry)
2. [ApeWorX/ape-hardhat](https://github.com/ApeWorX/ape-hardhat)

You can install one of these plugins by doing:

```shell
ape plugins install <foundry|hardhat>
```

Ensure you have also configured your upstream network (the network you are forking).
For example, if forking `ethereum:mainnet` and using `alchemy`, set `alchemy` as the default mainnet provider:

```yaml
ethereum:
  mainnet:
    default_provider: alchemy
```

Now, you can start and connect to your forked-network:

```yaml
ape console --network ethereum:mainnet-fork:foundry
```

Learn more about setting up networks in the [the networks guide](./networks.html).

## Forking Plugin Networks

You can also fork L2 plugin networks.
For example, to fork a network such as Optimism, install the `ape-optimism` plugin:

```shell
ape plugins install optimism
```

Then, just like you did for `ethereum`, configure `optimism`'s default mainnet provider:

```yaml
optimism:
  mainnet:
    default_provider: alchemy
```

Now, you can start and connect to your forked-network:

```yaml
ape console --network optimism:mainnet-fork:foundry
```

## Configure Default

If you want to change the default network from `local` to your forked network, add the following config:

```yaml
<ecosystem-name>:
  default_network: <network-name>_fork
```

Where `ecosystem-name` is the ecosystem containing the network and `network-name` is the network you are forking.

## Forked Context

If you are already connected to a live network wish to temporarily fork it, use the [fork() context manager](../methoddocs/managers.html#ape.managers.networks.NetworkManager.fork):

```python
from ape import networks

def main():
    with networks.ethereum.mainnet.use_provider("alchemy") as alchemy:
        print(alchemy.name)
        with networks.fork(provider_name="foundry") as foundry:
            print(foundry.name)
```

Learn more about the fork context manager [here](./networks.html#forked-context).
# Plugins

Plugins are core to Ape's architecture.
Here are some plugin examples in Ape:

- `CompilerAPI`: For supporting various languages, like Vyper or Solidity.
- `ProviderAPI`: For connecting the blockchain, such as Alchemy, Geth, or a local Hardhat node.
- `EcosystemAPI`: A suite of networks, such as Ethereum, Fantom, or Starknet.
- CLI plugins: Extending the `click` CLI in Ape.

## Core Plugins

Ape ships with core plugins to help Ape work out-of-the-box.
To see the core plugins that come with Ape, run the following command:

```bash
ape plugins list --all
```

Normally, the `ape plugins list` command shows you all the plugins you have installed.
However, when you include the `--all` flag, it shows the core plugins and the available plugins as well.

```{note}
The available plugins list is trusted and from the ApeWorX organization, however you can install third-party plugins from other sources as well.
```

## Installing Plugins

To add plugins to your project, edit your `ape-config.yaml` file:

```yaml
plugins:
  - name: solidity
    version: 0.6.0
  - name: hardhat
  - name: ens
  - name: etherscan
    version: ">=0.6.2,<0.7"
```

The `name` field is required.
Additionally, you may specify a `version` with or without constraints.

To install the plugins listed in your project, run the following command from the project's root directory:

```bash
ape plugins install .
```

To install plugins individually, run the following command:

```bash
ape plugins install vyper "solidity>=0.6,<0.7"
```

To install a plugin from a branch that is not yet released, you can use a `git+` prefixed value for the version:

```yaml
plugins:
  - name: foobar
    version: git+https://github.com/<owner-of-plugin>/ape-foobar.git@<branch/name>
```

Or from the CLI like:

```shell
ape plugins install "foobar@git+https://github.com/<owner-of-plugin>/ape-foobar.git@<branch/name>"
```

Also, you may omit the `foobar@` prefix and allow Ape to deduce the name:

```shell
ape plugins install "git+https://github.com/<owner-of-plugin>/ape-foobar.git@<branch/name>"
```

## Plugin Versions

By default, `ape plugins` commands install plugins within your current Ape version specification.
For example, if you have Ape 0.6.5 installed and you install `ape-tokens` without specifying a version, it defaults to `ape-tokens>=0.6.0,<0.7` so it is compatible does not change your Ape version.
To upgrade plugins to a new minor version, you have to first update Ape.

We provide an easy way to update your entire Ape ecosystem using the command:

```shell
ape plugins update
```

Now, both Ape and all the plugins will maximally update.
Alternatively, you use the `change-version` command to install a specific version of everything at once:

```shell
ape plugins change-version 0.6.0
```

## Plugin Types

There are many types of plugins available, including compilers, providers, networks, and CLI-based plugins.
To learn more about the different types of plugins, see the [Developing a Plugin Guide](./developing_plugins.html).
# Logging

Ape provides a logger and uses it to show messages throughout the execution of its modules.
Every CLI command comes with the logger in Ape, even custom user scripts (unless they change the behavior of `--verbosity`).

The following log levels are available with Ape:

| Log Level | Numeric Value | Purpose                        | Color  |
| --------- | ------------- | ------------------------------ | ------ |
| DEBUG     | 10            | Debug stuff                    | Blue   |
| INFO      | 20            | General information            | Blue   |
| SUCCESS   | 21            | To mark a successful operation | Green  |
| WARNING   | 30            | Indicates a potential issue    | Yellow |
| ERROR     | 40            | An error occurred              | Red    |

```{note}
`SUCCESS` is a non-standard verbosity level custom to the framework.
It is shown during `INFO` but not shown if set to `WARNING` or above.
```

## CLI Logging

If you are running into issues and wish to see more information logged, you likely want to run your command with `--verbosity DEBUG` or `-v debug`:

```bash
ape --verbosity DEBUG my_cmd  # long form
ape -v debug my_cmd           # short form
```

This will output HTTP requests and anything else with a `DEBUG` logging verbosity in Ape.

Alternatively, you may wish to log less and show important logs, such as `ERROR` logs.
To do this, use the `ERROR` verbosity:

```bash
ape my_cmd -v ERROR 
```

*NOTE*: You can put the verbosity flag anywhere in your CLI command for _most_ commands.

## Python Logging

You can also import and use the logger in your own Python scripts or commands:

```python
from ape.logging import logger, LogLevel

def main():
    logger.info("You have entered `main()`.")
    logger.set_level(LogLevel.WARNING)
```
# Networks

When interacting with a blockchain, you will have to select an ecosystem (e.g. Ethereum, Arbitrum, or Fantom), a network (e.g. Mainnet or Sepolia) and a provider (e.g. Eth-Tester, Node (Geth), or Alchemy).
The `ape-ethereum` ecosystem and network(s) plugin comes with Ape and can be used for handling EVM-like behavior.
Networks are part of ecosystems and typically defined in plugins or custom-network configurations.
However, Ape works out-of-the-box (in a limited way) with any network defined in the [evmchains](https://github.com/ApeWorX/evmchains) library.

## Selecting a Network

Before discussing how to add custom networks or install L2 network plugins, you need to know how to specify the network choice.
No matter what type of network you are using in Ape, you specify the network using a "network choice" triplet value:

```python
"<ecosystem-name>:<network-name>:<provider-name>"
```

Where `ecosystem-name` refers to the ecosystem, e.g. `ethereum`, `polygon`, `fantom`, or any valid ecosystem plugin name.
The `network-name` refers to a network such as `mainnet`, `local`, or something else defined by your ecosystem or custom network config.
And `provider-name` refers to the provider plugin in Ape, such as `node` for a generic node or `foundry` if the network is more Anvil-based, or a different plugin altogether.

Commonly, the network triplet value is specified via the `--network` option in Ape CLI commands.
The following is a list of common Ape commands that can use the `--network` option:

```bash
ape test --network ethereum:local:foundry
ape console --network arbitrum:testnet:alchemy # NOTICE: All networks, even from other ecosystems, use this.
```

To see all networks that work with the `--network` flag (besides those _only_ defined in `evmchains`), run the command:

```shell
ape networks list
```

You can also use the `--network` option on scripts that use the `main()` method approach or scripts that implement that `ConnectedProviderCommand` command type.
See [the scripting guide](./scripts.html) to learn more about scripts and how to add the network option.

Also, you can omit values to use defaults.
For example, the default ecosystem is `ethereum` and the default network is `local`, so you can do:

```bash
ape run <custom-cmd> --network ::foundry
```

as a short-cut for `ethereum:local:foundry`.
(note: `<custom-command>` refers to the name of a script that uses the network option or is a `ConnectedProviderCommand`.
See the [scripting guide](./scripts.html) for more information).

Next, we will talk about how to add additional networks to your Ape environment.

## L2 Networks

Common L2 networks, such as Arbitrum, Polygon, Optimism, or Fantom, have ApeWorX-maintained (trusted) plugins that override the Ethereum ecosystem API class and change any defaults that are needed.
You can install these plugins by doing:

```shell
ape plugins install arbitrum polygon optimism fantom
```

Each plugin does different things.
In general, L2 plugins are very small and override the Ethereum ecosystem class.
Here are some examples of changes L2 plugins make that allow improved support for these networks:

1. Networks that don't support EIP-1559 transactions use Static-fee transaction types by default whereas `ape-ethereum` will use EIP-1559 transactions by default.
2. Some networks, such as `ape-arbitrum`, have unique transaction types (and receipt types!) that are handled in the plugin.
   This logic does not have to live in the base `ape-ethereum` plugin but can live in the network's custom plugin.
3. Fee token information: When displaying gas reports or other data, network plugins can use the correct fee-token symbols, such as Polygon MATIC.

Here is a list of all L2 network plugins supported by Ape:

| Name              | GitHub                                                                    |
| ----------------- | ------------------------------------------------------------------------- |
| ape-arbitrum      | [ApeWorX/ape-arbitrum](https://github.com/ApeWorX/ape-arbitrum)           |
| ape-avalanche     | [ApeWorX/ape-avalanche](https://github.com/ApeWorX/ape-avalanche)         |
| ape-base          | [ApeWorX/ape-base](https://github.com/ApeWorX/ape-base)                   |
| ape-blast         | [ApeWorX/ape-base](https://github.com/ApeWorX/ape-blast)                  |
| ape-bsc           | [ApeWorX/ape-base](https://github.com/ApeWorX/ape-bsc)                    |
| ape-fantom        | [ApeWorX/ape-fantom](https://github.com/ApeWorX/ape-fantom)               |
| ape-optimism      | [ApeWorX/ape-optimism](https://github.com/ApeWorX/ape-optimism)           |
| ape-polygon       | [ApeWorX/ape-polygon](https://github.com/ApeWorX/ape-polygon)             |
| ape-polygon-zkevm | [ApeWorX/ape-polygon-zkevm](https://github.com/ApeWorX/ape-polygon-zkevm) |

```{note}
If you are connecting an L2 network or any other network that does not have a plugin, you can use the custom network support, which is described in the [next section](#custom-network-connection).
```

Once you have the L2 network plugin installed, you can configure its node's URI by setting the values in the `node` core plugin via your `ape-config.yaml` file:

```yaml
node:
  <ecosystem-name>:
    <network-name>:
      uri: https://path.to.node.example.com
```

To see proper ecosystem and network names needed for configuration, run the command:

```shell
ape networks list
```

In the remainder of this guide, any example below using Ethereum, you can replace with an L2 ecosystem's name and network combination.

## evmchains Networks

If a network is in the [evmchains](https://github.com/ApeWorX/evmchains) library, it will work in Ape automatically, even without a plugin or any custom configuration for that network.

```shell
ape console --network moonbeam
```

This works because the `moonbeam` network data is available in the `evmchains` library, and Ape is able to look it up.

```{warning}
Support for networks from evm-chains alone may be limited and require additional configuration to work in production use-cases.
```

## Custom Network Connection

You can add custom networks to Ape without creating a plugin.
The two ways to do this are:

1. Create custom network configurations in your `ape-config.yaml` file (typically your global one).
2. Use the `--network` flag with a raw URI string.

### Custom Networks By Config

The most familiar way to use custom networks (non-plugin-based networks) in Ape is to use the `networks: custom` configuration.
Generally, you want to use the global `ape-config.yaml`, which is located in your `$HOME/.ape/` directory.
By configuring networks globally, you can share them across all your projects.
More information about configuring Ape (in general) can be found [here](./contracts.html).

To add custom networks to your `ape-config.yaml` file, follow this pattern:

```yaml
networks:
  custom:
     - name: mainnet                   # Required
       chain_id: 109                   # Required
       ecosystem: shibarium            # The ecosystem name, can either be new or an existing
       base_ecosystem_plugin: polygon  # The ecosystem base-class, defaults to the default ecosystem
       default_provider: node          # Default is the generic node provider
```

The following paragraphs explain the different parameters of the custom network config.

**name**: The `name` of the network is the same identifier you use in the network triplet for the "network" (second) section.
Read more on the network option [here](#selecting-a-network).

**chain_id**: The chain ID is required for config-based custom networks.
It ensures you are on the correct network when making transactions and is very important!

**ecosystem**: Specify your custom network's ecosystem.
This can either be an existing ecosystem or a new name entirely.
Recall, you refer to your network via the network-triplet `ecosystem:network:provider` option-str.
The ecosystem class is largely responsible for decoding and encoding data to-and-fro the blockchain but also contains all the networks.
More information about the EcosystemAPI can be found [here](../methoddocs/api.html#ape.api.networks.EcosystemAPI).
If your custom network is part of a new ecosystem, such as Shibarium, use the name of the new ecosystem, e.g. `"shibarium"`.
You may want to also adjust the `base_ecosystem_plugin` config to change the base-class used.

**base_ecosystem_plugin**: The plugin that defines the base-class to your custom ecosystem containing your custom network(s).
If your custom network's ecosystem matches closer to another L2 instead of Ethereum, use that ecosystem name as your `base_ecosystem_plugin` in your custom network config.
For example, take note that `"ethereum"` assumes EIP-1559 exists (unless configured otherwise).
If your custom network is closer to Fantom, Polygon, Avalanche, or any other L2, you may want to consider using one of those plugins as the `base_ecosystem_plugin` to your custom network.
Alternatively, you can configure your custom network the same way you configure any other network in the config (see [this section](#block-time-transaction-type-and-more-config)).

**default_provider**: The default provider is the provider class used for making the connection to your custom network, unless you specify a different provider (hence the `default_`).
Generally, you won't change this and can use the default EVM node provider.
Many provider plugins won't function here, such as `ape-infura` or `ape-alchemy`.
If you are using one of their networks, it is best to edit and use the plugins directly.
If you are using a developer-node remotely, such as a custom Anvil node, you can specify the default provider to be `foundry` instead.
However, take care in making sure you set up Foundry to correctly connect to your node.
Likewise, when using the default Ethereum node provider, you will need to tell it the RPC URL.

#### RPC URL

To configure the RPC URL for a custom network, use the configuration of the provider.
For example, if the RPC URL is `https://apenet.example.com/rpc`, configure it by doing:

```yaml
default_ecosystem: shibarium

networks:
  custom:
    - name: mainnet
      ecosystem: shibarium
      base_ecosystem_plugin: polygon  # Closest base class.
      chain_id: 109  # This must be correct or txns will fail.

node:
  shibarium:
    mainnet:
      uri: https://www.shibrpc.com
```

Now, when using `ethereum:apenet:node`, it will connect to the RPC URL `https://apenet.example.com/rpc`.

#### Forking Custom Networks

You can fork custom networks using providers that support forking, such as `ape-foundry` or `ape-hardhat`.
To fork a custom network, first ensure the custom network is set-up by following the sections above.
Once you can successfully connect to a custom network in Ape, you can fork it.

To fork the network, launch an Ape command with the `--network` option with your custom network name suffixed with `-fork` and use one of the forking providers (such as `ape-foundry`):

```
ape <cmd> --network shibarium:puppynet-fork:foundry
```

Configure the forked network in the plugin the same way you configure other forked networks:

```yaml
foundry:
  fork:
    shibarium:
      puppynet:
        block_number: 500
```

#### Explorer URL

To configure explorer URLs for your custom network, use the explorer's plugin config.
For example, let's say you added the following network:

```yaml
networks:
  custom:
    - name: customnetwork
      chain_id: 31337
      default_provider: node
```

To add a corresponding entry in `ape-etherscan` (assuming you are using `ape-etherscan` as your explorer plugin), add the following to your `ape-config.yaml` file:

```yaml
etherscan:
  ethereum:
    rate_limit: 15  # Configure a rate limit that makes sense for retry logic.

    # The name of the entry is the same as your custom network!
    customnetwork:
      uri: https://custom.scan              # URL used for showing transactions
      api_uri: https://api.custom.scan/api  # URL used for making API requests.
```

```{note}
Every explorer plugin may be different in how you configure custom networks.
Consult the plugin's README to clarify.
```

#### Block time, transaction type, and more config

Configuring network properties in Ape is the same regardless of whether it is custom or not.
As you saw above, we set the RPC URL of the custom network the same as if a plugin existed for that network.
The same is true for network config properties such as `block_time`, `default_transaction_type`, `transaction_acceptance_timeout` and more.

For example, let's say I want to change the default transaction type for the `apenet` custom network (defined in examples above).
I do this the same way as if I were changing the default transaction type on mainnet.

```yaml
ethereum:
  apenet:
    default_transaction_type: 0  # Use static-fee transactions for my custom network!
```

For a full list of network configurations like this (for both custom and plugin-based networks), [see this section](#configuring-networks).

```{note}
This also works if configuring a custom ecosystem.
```

If using a custom ecosystem, use the custom ecosystem name as the top-level config key instead:

```yaml
networks:
  custom:
    - name: mainnet
      ecosystem: shibarium
      base_ecosystem_plugin: polygon  # Closest base class.
      chain_id: 109  # This must be correct or txns will fail.

shibarium:
  mainnet:
    default_transaction_type: 0  # Use static-fee transactions for Shibarium.
```

### Custom Networks by CLI

Ape also lets you connect to custom networks on-the-fly!
If you would like to connect to a URI using an existing ecosystem plugin, you can specify a URI in the provider-section for the `--network` option:

```bash
ape run script --network <ecosystem-name>:<network-name>:https://foo.bar
```

Additionally, if you want to connect to an unknown ecosystem or network, you can use the URI by itself.
This uses the default Ethereum ecosystem class.

```bash
ape run script --network https://foo.bar
```

```{warning}
The recommended approach is to use an L2 plugin when one exists, as it will integrate better in the Ape ecosystem.
```

Here are some general reason why Network plugins are recommended:

1. You may need to integrate with other plugins, such as explorer plugins for getting contract types.
2. Some chains may not implement EIP-1559 or may have forked from a specific configuration.
3. Response differences in uncommon blocks, such as the `"pending"` block or the genesis block.
4. Revert messages and exception-handling differences.
5. You can handle chain differences such as different transaction types in Arbitrum, non-EVM chains and behaviors like Starknet.

## Configuring Networks

Change network defaults using your project's `ape-config.yaml` file.
The following configuration changes the default ecosystem, network, and provider such that if you omitted the `--network` option on connected-provider commands, it would use the value `<ecosystem-name>:<network-name>:<provider-name>`.

```yaml
default_ecosystem: <ecosystem-name>

<ecosystem-name>:
  default_network: <network-name>
  <network-name>:
    default_provider: <provider-name>
```

As mentioned [above](#l2-networks), ecosystems and networks typically come from plugins and their names and values are defined in those plugins.
The ecosystem name goes in placeholder `<ecosystem-name>` and the network names go in place for `<network-name>`.

**If you are unsure of the values to place here, run the following command**:

```shell
ape networks list
```

This command lists all the ecosystem names and networks names installed currently in Ape.
Place the identical name in the config to configure that ecosystem or network.

You may also configure a specific gas limit for a given network:

```yaml
<ecosystem-name>:
  default_network: <network-name>
  <network-name>:
    gas_limit: "max"
```

You may use one of:

- `"auto"` - gas limit is estimated for each transaction
- `"max"` - the maximum block gas limit is used
- A number or numeric string, base 10 or 16 (e.g. `1234`, `"1234"`, `0x1234`, `"0x1234"`)

For the local network configuration, the default is `"max"`. Otherwise, it is `"auto"`.

## Request Headers

There are several layers of request-header configuration.
They get merged into each-other in this order, with the exception being `User-Agent`, which has an append-behavior.

- Default Ape headers (includes `User-Agent`)
- Top-level configuration for headers (using `request_headers:` key)
- Per-ecosystem configuration
- Per-network configuration
- Per-provider configuration

Use the top-level `request_headers:` config to specify headers for every request.
Use ecosystem-level specification for only requests made when connected to that ecosystem.
Network and provider configurations work similarly; they are only used when connecting to that network or provider.

Here is an example using each layer:

```yaml
request_headers:
  Top-Level: "UseThisOnEveryRequest"

ethereum:
  request_headers:
    Ecosystem-Level: "UseThisOnEveryEthereumRequest"
  
  mainnet:
    request_headers:
      Network-Level: "UseThisOnAllRequestsToEthereumMainnet"

node:
  request_headers:
    Provider-Level: "UseThisOnAllRequestsUsingNodeProvider"
```

When using `User-Agent`, it will not override Ape's default `User-Agent` nor will each layer override each-other's.
Instead, they are carefully appended to each other, allowing you to have a very customizable `User-Agent`.

## Local Network

The default network in Ape is the local network (keyword `"local"`).
It is meant for running tests and debugging contracts.
Out-of-the-box, Ape ships with two development providers you can use for the `local` network:

- [EthTester](https://github.com/ethereum/eth-tester)
- An Ephemeral Node (defaults to Geth) process

```bash
ape test --network ::test
ape test --network ::node  # Launch a local development node (geth) process
```

To learn more about testing in ape, follow [this guide](./testing.html).

## Live Networks

Use the core plugin `ape-node` to connect to local or remote nodes via URI.
The node plugin is abstract in that it represents any node.
However, it will work best when connected to a geth node.
To configure network URIs in `node`, you can use the `ape-config.yaml` file:

```yaml
node:
  # When managing or running a node, configure an IPC path globally (optional)
  ipc_path: path/to/geth.ipc

  ethereum:
    mainnet:
      # For `uri`, you can use either HTTP, WS, or IPC values.
      # **Most often, you only need HTTP!**
      uri: https://foo.node.example.com
      # uri: wss://bar.feed.example.com
      # uri: path/to/mainnet/geth.ipc
      
      # For strict HTTP connections, you can configure a http_uri directly.
      http_uri: https://foo.node.example.com

      # You can also configure a websockets URI (used by Silverback SDK).
      ws_uri: wss://bar.feed.example.com
    
      # Specify per-network IPC paths as well.
      ipc_path: path/to/mainnet/geth.ipc
```

## Network Config

There are many ways to configure your networks.
Most of the time, Ape and its L2 plugins configure the best defaults automatically.
Thus, you most likely won't need to modify these configurations.
However, you do need to configure these if you wish to stray from a network's defaults.
The following example shows how to do this.
(note: even though this example uses `ethereum:mainnet`, you can use any of the L2 networks mentioned above, as they all have these config properties).

```yaml
ethereum:
  mainnet:
    # Ethereum mainnet in Ape uses EIP-1559 by default,
    # but we can change that here. Note: most plugins
    # use type 0 by default already, so you don't need
    # to change this if using an `ape-<l2>` plugin.
    default_transaction_type: 0

    # The amount of time to wait for a transaction to be
    # accepted after sending it before raising an error.
    # Most networks use 120 seconds (2 minutes).
    transaction_acceptance_timeout: 60

    # The amount of times to retry fetching a receipt. This is useful
    # because decentralized systems may show the transaction accepted
    # on some nodes but not on others, and potentially RPC requests
    # won't return a receipt immediately after sending its transaction.
    # This config accounts for such delay. The default is `20`.
    max_receipt_retries: 10

    # Set a gas limit here, or use the default of "auto" which
    # estimates gas. Note: local networks tend to use "max" here
    # by default.
    gas_limit: auto

    # Base-fee multipliers are useful for times when the base fee changes
    # before a transaction is sent but after the base fee was derived,
    # thus causing rejection. A multiplier reduces the chance of
    # rejection. The default for live networks is `1.4` times the base fee.
    base_fee_multiplier: 1.2

    # The block time helps Ape make decisions about
    # polling chain data.
    block_time: 10
```

## Running a Network Process

To run a network with a process, use the `ape networks run` command:

```shell
ape networks run
```

By default, `ape networks run` runs a development Node (geth) process.
To use a different network, such as `hardhat` or Anvil nodes, use the `--network` flag:

```shell
ape networks run --network ethereum:local:foundry
```

## Provider Interaction

Once you are connected to a network, you now have access to a `.provider`.
The provider class is what higher level Manager classes in Ape use to interface with the blockchain.
You can call methods directly from the provider, like this:

```python
from ape import chain

block = chain.provider.get_block("latest")
```

## Provider Context Manager

Use the [ProviderContextManager](../methoddocs/api.html#ape.api.networks.ProviderContextManager) to change the network-context in Python.
When entering a network for the first time, it will connect to that network.
**You do not need to call `.connect()` or `.disconnect()` manually**.

For example, if you are using a script with a default network connection, you can change connection in the middle of the script by using the provider context manager:

```python
from ape import chain, networks

def main():
    start_provider = chain.provider.name
    with networks.ethereum.mainnet.use_provider("node") as provider:
        # We are using a different provider than the one we started with.
        assert start_provider != provider.name
```

Jump between networks to simulate multi-chain behavior.

```python
import click
from ape import networks

@click.command()
def cli():
    with networks.polygon.mainnet.use_provider("node"):
        ...
    with networks.ethereum.mainnet.use_provider("node"):
        ...
```

The argument to [use_provider()](../methoddocs/api.html#ape.api.networks.NetworkAPI.use_provider) is the name of the provider you want to use.
You can also tell Ape to use the default provider by calling method [use_default_provider()](../methoddocs/api.html#ape.api.networks.NetworkAPI.use_default_provider) instead.
This will use whatever provider is set as default for your ecosystem / network combination (via one of your `ape-config.yaml` files).

For example, let's say I have a default provider set like this:

```yaml
arbitrum:
  mainnet:
    default_provider: alchemy
```

```python
import ape

# Use the provider configured as the default for the arbitrum::mainnet network.
# In this case, it will use the "alchemy" provider.
with ape.networks.arbitrum.mainnet.use_default_provider():
    ...
```

You can also use the [parse_network_choice()](../methoddocs/managers.html#ape.managers.networks.NetworkManager.parse_network_choice) method when working with network choice strings:

```python
from ape import networks

# Same as doing `networks.ethereum.local.use_provider("test")`.
with networks.parse_network_choice("ethereum:local:test") as provider:
    print(provider)
```

**A note about disconnect**: Providers do not disconnect until the very end of your Python session.
This is so you can easily switch network contexts in a bridge or multi-chain environment, which happens in fixtures and other sessions out of Ape's control.
However, sometimes you may definitely want your temporary network session to end before continuing, in which case you can use the `disconnect_after=True` kwarg:

```python
from ape import networks

with networks.parse_network_choice("ethereum:local:foundry", disconnect_after=True) as provider:
    print(provider)
```

### Forked Context

Using the `networks.fork()` method, you can achieve similar effects to using a forked network with `disconnect_after=True`.
For example, let's say we are running the following script on the network `ethereum:mainnet`.
We can switch to a forked network by doing this:

```python
from ape import networks

def main():
    with networks.fork(provider_name="foundry"):
        ...
        # Do stuff on a local, forked version of mainnet

    # Switch back to mainnet.
```

Learn more about forking networks in the [forked-networks guide](./forking_networks.html).
# Developing Projects with Ape

Use `ape init` to create your project.
A common project structure looks like this:

```
project                             # The root project directory
├── contracts/                      # Project source files, such as '.sol' or '.vy' files
│   └── smart_contract_example.sol  # Sample of a smart contract
├── tests/                          # Project tests, ran using the 'ape test' command
│   └── test_sample.py              # Sample of a test to run against your sample contract
├── scripts/                        # Project scripts, such as deploy scripts, ran using the 'ape run   <`name>' command
│   └── deploy.py                   # Sample script to automate a deployment of an ape project
└── ape-config.yaml                 # The ape project configuration file
```

Notice that you can configure your ape project using the `ape-config.yaml` file.
See the [configuration guide](./config.html) for a more detailed explanation of settings you can adjust.

## The Local Project

After you have a local project and you are in the directory of that project, the global `project` reference in Ape will refer to this project.
You can see this by typing `project` in the `ape console`:

```python
In [1]: project
Out[1]: <ProjectManager ~/ApeProjects/ape-demo-project>
```

In this case, my terminal's current working directory is the same as a local project named `ape-demo-project`.

## Other Projects

You can reference other local projects on your computer by using the `Project` factory class (notice the capital `P`):

```python
from ape import Project

my_other_project = Project("../path/to/my/other/project")
_ = my_other_project.MyContract  # Do anything you can do to the root-level project.
```

## Project Manifests

Ape stores and caches artifacts in an [EthPM package manifest](https://eips.ethereum.org/EIPS/eip-2678).
When working with local projects, the manifests get placed in the `<project-path>/.build/__local__.json`.
However, you may obtain a manifest from a different location.
If that is the case, you can create a project directly from the manifest itself:

```python
from ape import Project

# Pass in a manifest (object or dictionary), or a path to a manifest's JSON file.
project = Project.from_manifest("path/to/manifest.json")
_ = project.MyContract  # Do anything you can do to the root-level project.
```

## Installed Python Projects

If you have installed a project using `pip` or alike and you wish to reference its project, use the `Project.from_python_library()` class method.

```python
from ape import Project

snekmate = Project.from_python_library("snekmate", config_override={"contracts_folder": "."})
```

## Dependencies

Use other projects as dependencies in Ape.
There is an extensive guide you can read on this [here](./dependencies.html).
But it is important to note that the dependency system largely is dependent on the project system.
Dependencies are just projects after all; projects containing source files you both use in your projects or compile independently.

For example, access a dependency project and treat it like any other project this way:

```python
from ape import project

dependency = project.dependencies.get_dependency("my-dependency", "1.0.0")
contract_type = dependency.project.ContractFromDependency
```
# Proxy Contracts

Ape is able to detect proxy contracts so that it uses the target interface when interacting with a contract.
The following proxies are supported in `ape-ethereum`:

| Proxy Type   | Short Description                 |
| ------------ | --------------------------------- |
| Minimal      | EIP-1167                          |
| Standard     | EIP-1967                          |
| Beacon       | EIP-1967                          |
| UUPS         | EIP-1822                          |
| Vyper        | vyper \<0.2.9 create_forwarder_to |
| Clones       | 0xsplits clones                   |
| Safe         | Formerly Gnosis Safe              |
| OpenZeppelin | OZ Upgradable                     |
| Delegate     | EIP-897                           |
| ZeroAge      | A minimal proxy                   |
| SoladyPush0  | Uses PUSH0                        |

Proxy detection occurs when attempting to retrieve contract types in Ape.
Ape uses various sources to find contract types, such as explorer APIs.
See [this guide](./contracts.html) to learn more about initializing contracts.

```python
from ape import Contract

my_contract = Contract("0x...")
```

Ape will check the address you give it and detect if it hosts a proxy contract.
In the case where it determines the address is a proxy contract, it resolves the address of the implementation (every proxy is different) and returns the interface for the implementation contract.
This allows you to still call methods as you normally do on proxy contracts.

```python
# `my_contract` address points to a proxy with no methods in the interface
# However, Ape detected the implementation type and can find methods to call that way.
my_contract.my_method(sender=account)
```
# Publishing

Publishing smart-contract packages using Ape is influenced from [EIP-2678](https://eips.ethereum.org/EIPS/eip-2678) and uses the [ethpm-types](https://github.com/ApeWorX/ethpm-types) Python package extensively (which is also managed by the ApeWorX organization).
This guide exists to walk through the steps of publishing your project.

## Compilation

First, your project must compile.

```bash
ape compile
```

To learn more about project compilation, follow [this guide](./compile.html).
Once your project has successfully compiled, you will have the start of your `PackageManifest` generated in your project's `.build/` directory.

## Tracking Deployments

If your project contains deployments that you wish to include in its package manifest, use the [project.deployments.track](../methoddocs/managers.html#ape.managers.project.manager.DeploymentManager.track) method.
Example:

```python
from ape import accounts, project

account = accounts.load("mainnet-account")

# Assume your project has a contract named 'MyContract' with constructor that accepts argument '123'.
contract = project.MyContract.deploy(123, sender=account)
project.deployments.track(contract)
```

If the contract is already deployed, you can use [Contract](../methoddocs/ape.html#ape.Contract) to get a contract instance:

```python
from ape import Contract, project

contract = Contract("0x12c17f958d2ee523a2206206994597c13d831e34")
project.deployments.track(contract)
```

For more information on accessing contract instances, follow [this guide](./contracts.html).

## Publishing to Explorer

If you want to publish your contracts to an explorer, you can use the [publish_contract](../methoddocs/api.html#ape.explorers.ExplorerAPI.publish_contract) on the `ExplorerAPI`.

```python
from ape import networks

networks.provider.network.explorer.publish_contract("0x123...")
```

If you want to automatically publish the source code upon deployment, you can use the `publish=` kwarg on the `deploy` methods:

```python
from ape import accounts, project

account = accounts.load("<ALIAS>")
account.deploy(project.MyContract, publish=True)
```
```{include} ../../README.md
```
# Reverts

Reverts occur when a transaction or call fails for any reason.
In the case of EVM networks, reverts result in funds being returned to the sender (besides network-fees) and contract state changes unwinding.
Typically, in smart-contracts, user-defined reverts occur from `assert` statements in Vyper and `require` statements in Solidity.

Here is a Vyper example of an `assert` statement:

```python
assert msg.sender == self.owner, "!authorized"
```

The string `"!authorized"` after the assertion is the revert-message that gets forwarded to the user.

In solidity, a `require` statement looks like:

```solidity
require(msg.sender == owner, "!authorized");
```

In Ape, reverts automatically become Python exceptions.
When [interacting with a contract](./contracts.html#contract-interaction) and encountering a revert, your program will crash and you will see a stacktrace showing you where the revert occurred.
For example, assume you have contract instance variable `contract` with a Vyper method called `setNumber()`, and it reverts when the user is not the owner of the contract.
Calling it may look like:

```python
receipt = contract.setNumber(123, sender=not_owner)
```

And when it fails, Ape shows a stacktrace like this:

```shell
  File "$HOME/ApeProjects/ape-project/scripts/fail.py", line 8, in main
    receipt = contract.setNumber(5, sender=not_owner)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "$HOME/ApeProjects/ape-project/contracts/VyperContract.vy", line 98, in 
setNumber
    assert msg.sender == self.owner, "!authorized"
    ^^^^^^^^^^^^^^^^^^^^^^^

ERROR: (ContractLogicError) !authorized
```

One way to handle exceptions is to simply use `try:` / `except:` blocks:

```python
from ape.exceptions import ContractLogicError

try:
    receipt = contract.setNumber(123, sender=not_owner)
except ContractLogicError as err:
    receipt = None
    print(f"The transaction failed: {err}")
# continue on!
```

If you wish to allow reverts without having Ape raise exceptions, use the `raise_on_revert=False` flag:

```python
>>> receipt = contract.setNumber(123, sender=not_owner, raise_on_revert=False)
>>> receipt.failed
True
>>> receipt.error
ContractLogicError('!authorized')
```

## Dev Messages

Dev messages allow smart-contract authors to save gas by avoiding revert-messages.
If you are using a provider that supports tracing features and a compiler that can detect `dev` messages, and you encounter a revert without a revert-message but it has a dev-message, Ape will show the dev-message:

```python
assert msg.sender == self.owner  # dev: !authorized"
```

And you will see a similar stacktrace as if you had used a revert-message.

In Solidity, it might look like this:

```solidity
require(msg.sender == owner);  // @dev !authorized
```

## Custom Errors

As of Solidity 0.8.4, custom errors have been introduced to the ABI.
In Ape, custom errors are available on contract-instances.
For example, if you have a contract like:

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;

error Unauthorized(address unauth_address);

contract MyContract {
    address payable owner = payable(msg.sender);
    function withdraw() public {
        if (msg.sender != owner)
            revert Unauthorized(msg.sender);
        owner.transfer(address(this).balance);
    }
}
```

And if you have an instance of this contract assigned to variable `contract`, you can reference the custom exception by doing:

```python
contract.Unauthorized
```

When invoking `withdraw()` with an unauthorized account using Ape, you will get an exception similar to those from `require()` statements, a subclass of `ContractLogicError`:

```python
contract.withdraw(sender=hacker)  # assuming 'hacker' refers to the account without authorization.
```

## Built-in Errors

Besides user-defined `ContractLogicError`s, there are also builtin-errors from compilers, such as bounds-checking of arrays or paying a non-payable method, etc.
These are also `ContractLogicError` sub-classes.
Sometimes, compiler plugins such as `ape-vyper` or `ape-solidity` export these error classes for you to use.

```python
from ape import accounts, Contract
from ape_vyper.exceptions import FallbackNotDefinedError

my_contract = Contract("0x...")
account = accounts.load("test-account")

try:
    my_contract(sender=account)
except FallbackNotDefinedError:
    print("fallback not defined")
```

Next, learn how to test your contracts' errors using the `ape.reverts` context-manager in the [testing guide](./testing.html#testing-transaction-reverts).
# Scripting

You can write scripts that run using the `ape run` command.
The `ape run` command will register and run Python files defined under the `scripts/` directory that do not start with an `_` underscore.

## CLI Scripts

Place scripts in your project's `scripts/` directory.
Follow [this guide](./projects.html) to learn more about the Ape project structure.
If your scripts take advantage of utilities from our [`ape.cli`](../methoddocs/cli.html#ape-cli) submodule, you can build a [Click](https://click.palletsprojects.com/) command line interface by defining a `click.Command` or `click.Group` object called `cli` in your file:
Follow [this guide](./clis.html) to learn more about what you can do with the utilities found in `ape.cli`.

```python
import click

@click.command()
def cli():
    print("Hello world!")
```

Assume we named the script `helloworld.py`.
To execute the script, run the following:

```bash
ape run helloworld
```

You can also execute scripts in subdirectories.
For example, assuming we have script `<project>/scripts/hello/helloworld.py`, we would execute it by running:

```bash
ape run hello helloworld
```

```{note}
By default, `cli` scripts do not have [`ape.cli.network_option`](../methoddocs/cli.html?highlight=options#ape.cli.options.network_option) installed, giving you more flexibility in how you define your scripts.
```

However, you can add the `network_option` or `ConnectedProviderCommand` to your scripts by importing them from the `ape.cli` namespace:

```python
import click
from ape.cli import ConnectedProviderCommand


@click.command(cls=ConnectedProviderCommand)
def cli(ecosystem, network):
    click.echo(f"You selected a provider on ecosystem '{ecosystem.name}' and {network.name}.")

@click.command(cls=ConnectedProviderCommand)
def cli(network, provider):
    click.echo(f"You are connected to network '{network.name}'.")
    click.echo(provider.chain_id)

@click.command(cls=ConnectedProviderCommand)
def cli_2():
    click.echo(f"Using any network-based argument is completely optional.")
```

Assume we saved this script as `shownet.py` and have the [ape-alchemy](https://github.com/ApeWorX/ape-alchemy) plugin installed.
Try changing the network using the `--network` option:

```bash
ape run shownet --network ethereum:mainnet:alchemy
```

### Multi-network Scripting

Because CLI-based scripts do not automatically connect to the provider before executing, they are ideal for multi-chain use-cases because they allow you to delay and manage the connection(s).
To learn more about how to control the network-context in Ape Pythonically, see [this guide](https://docs.apeworx.io/ape/stable/userguides/networks.html#provider-context-manager).

Here is an example of a multi-chain script:

```python
import click
from ape.cli import ape_cli_context

@click.command()
@ape_cli_context()
def cli(cli_ctx):
    # There is no connection yet at this point.
    testnets = {
        "ethereum": ["sepolia"],
        "polygon": ["amoy"]
    }
    nm = cli_ctx.network_manager

    for ecosystem_name, networks in testnets.items():
        ecosystem = nm.ecosystems[ecosystem_name]

        for network_name in networks:
            # Start making connections.
            network = ecosystem.get_network(network_name)

            with network.use_provider("alchemy") as provider:
                print(f"Connected to {provider.network_choice}")
```

Things to notice:

1. It uses the CLI approach _without_ `cls=ConnectedProviderCommand`; thus it is not connected before it makes the first call to `.use_provider("alchemy")`.
2. It uses the `@ape_cli_context()` decorator to get access to Ape instances such as the `network_manager`.
3. Each network is only active during the context, thus allowing you to switch contexts and control chain-hopping in scripts.
4. **You do not need to call `.connect()` on the provider yourself!**

## Main Method Scripts

You can also use the main-method approach when defining scripts.
To do this, define a method named `main()` in your script:

```python
def main():
    print("Hello world!")
```

```{note}
main-method scripts will always provide a `--network` option and run in a connected-context.
Therefore, they are not ideal for multi-chain scripts.
`main`-method scripts work best for quick, single-network, connection-based workflows.
```

To demonstrate, use the following script:

```python
from ape import networks
import click

def main():
    ecosystem_name = networks.provider.network.ecosystem.name
    network_name = networks.provider.network.name
    provider_name = networks.provider.name
    click.echo(f"You are connected to network '{ecosystem_name}:{network_name}:{provider_name}'.")
```

Suppose the name of the script is `foobar`, you can run it via:

```shell
ape run foobar
```

Without specifying `--network`, the script will connect to your default network.
Else, specify the network using the `--network` flag:

```shell
ape run foobar --network polygon:amoy:alchemy
```

You can also change networks within the script using the `ProviderContextManager` (see examples in the CLI-script section above).
For multi-chain use-cases, we recommend sticking to the CLI based scripts to avoid the initial connection `main`-method scripts make.
# Testing

Testing an ape project is important and easy.

## Pytest

Before learning how testing works in Ape, you should have an understanding of [the pytest framework](https://docs.pytest.org/en/7.4.x/) and its concepts such as fixtures, mark-decorators, and pytest plugins such as x-dist, pytest-mock, and pytest-cov.
Once you have learned about pytest, Ape testing becomes intuitive because it is built on top of pytest.
In fact, `ape-test` is itself a `pytest` plugin!

You write your smart-contracts much like you write regular Python tests.

## Test Structure

Tests must be located in a project's `tests/` directory. Each **test file** must start with `test_` and have the `.py` extension, such as `test_my_contract.py`.
Each **test method** within the file must also start with `test_`.
The following is an example test:

```python
def test_add():
    assert 1 + 1 == 2
```

```{note}
`pytest` assumes the *actual* value is on the left and the *expected* value is on the right.
```

## Test Pattern

Tests are generally divisible into three parts:

1. Set-up
2. Invocation
3. Assertion

An example of the setup-phase would be creating a `pytest.fixture` that deploys our smart contract.
(To learn more about pytest fixtures in Ape, see the `Fixtures` section below!)
For now, what you need to know is that it's a piece of code that executes before the test runs, and it is decorated with a `@pytest.fixture`.

The second phase is `Invocation`, which encompasses invoking the function we are testing.
The last phase, `Assertion`, requires enacting on the expectation about how the code should behave.
Let's assume there is an `authorized_method()` that requires the owner of the contract to make the transaction.
If the sender of the transaction is not the owner, the transaction will fail to complete and will revert.
We use `assert` statements in Ape (and `pytest`) to check that our expectations are correct.
A test passes if all the `assert` statements are `True` and it fails if any are `False`.

This is an example of how that test may look:

```python
import ape
import pytest

# SETUP PHASE
# NOTE: More on fixtures is discussed in later sections of this guide!
@pytest.fixture
def owner(accounts):
    return accounts[0]

@pytest.fixture
def my_contract(owner, project):
    return owner.deploy(project.MyContract)

def test_authorization(my_contract, owner, not_owner):
    # INVOCATION PHASE
    my_contract.set_owner(sender=owner)
    assert owner == my_contract.owner()

    # ASSERTION PHASE
    with ape.reverts("!authorized"):
        my_contract.authorized_method(sender=not_owner)
```

```{note}
Ape has built-in test and fixture isolation for all pytest scopes.
To disable isolation add the `--disable-isolation` flag when running `ape test`
```

## Fixtures

Now that we have discussed the full flow of a test, let's dive deeper into the specific parts, starting with `pytest.fixtures`.

You can define and use `pytest` fixtures in your Ape tests.
Learn more about fixtures from [this guide](https://docs.pytest.org/en/7.1.x/explanation/fixtures.html).
The syntax and functionalities of fixtures work exactly the same in Ape as it does with `pytest`.

The `ape-test` plugin comes with fixtures you will likely want to use.
The following guide explains each fixture that comes with Ape.

### accounts fixture

You have access to test accounts.
These accounts are automatically funded, and you can use them to transact in your tests.
Access each [test account](../methoddocs/api.html?highlight=testaccount#ape.api.accounts.TestAccountAPI) by index from the `accounts` fixture:

```python
def test_my_method(accounts):
    owner = accounts[0]
    receiver = accounts[1]
```

For code readability and sustainability, create your own fixtures using the `accounts` fixture:

```python
import pytest

@pytest.fixture
def owner(accounts):
    return accounts[0]


@pytest.fixture
def receiver(accounts):
    return accounts[1]


def test_my_method(owner, receiver):
    ...
```

You can configure your accounts by changing the `mnemonic`, `number_of_accounts`, and `balance` in the `test` section of your `ape-config.yaml` file:

```yaml
test:
  mnemonic: test test test test test test test test test test test junk
  number_of_accounts: 5
  balance: 100_000 ETH
```

If you are running tests against `anvil`, your generated test accounts may not correspond to the `anvil`'s default generated accounts despite using the same mnemonic. In such a case, you are able to specify a custom derivation path in `ape-config.yaml`:

```yaml
test:
  mnemonic: test test test test test test test test test test test junk
  number_of_accounts: 5
  hd_path: "m/44'/60'/0'/0/{}"
```

If you are using a provider that supports impersonating accounts, such as [Foundry](https://github.com/ApeWorX/ape-foundry), use the address as the key in the test-accounts manager:

```python
@pytest.fixture
def vitalik(accounts):
    return accounts["0xab5801a7d398351b8be11c439e05c5b3259aec9b"]
```

You can also call `accounts.impersonate_account()` for improved readability and performance.

```python
@pytest.fixture
def vitalik(accounts):
    return accounts.impersonate_account("0xab5801a7d398351b8be11c439e05c5b3259aec9b")
```

Using a fork-provider such as [Hardhat](https://github.com/ApeWorX/ape-hardhat), when using a contract instance as the sender in a transaction, it will be automatically impersonated:

```python
def test_my_method(project, accounts):
    contract = project.MyContract.deploy(sender=accounts[0])
    other_contract = project.OtherContract.deploy(sender=accounts[0])
    contract.my_method(sender=other_contract)
```

It has the same interface as the [TestAccountManager](../methoddocs/managers.html#ape.managers.accounts.TestAccountManager), (same as doing `accounts.test_accounts` in a script or the console).

### chain fixture

Use the chain fixture to access the connected provider or adjust blockchain settings.

For example, increase the pending timestamp:

```python
def test_in_future(chain):
    chain.pending_timestamp += 86000
    assert "Something"
    chain.pending_timestamp += 86000
    assert "Something else"
```

It has the same interface as the [ChainManager](../methoddocs/managers.html#ape.managers.chain.ChainManager).

### networks fixture

Use the `networks` fixture to change the active provider in tests.

```python
def test_multi_chain(networks):
    assert "Something"  # Make assertion in root network

    # NOTE: Assume have ecosystem named "foo" with network "local" and provider "bar"
    with networks.foo.local.use_provider("bar"):
        assert "Something else"
```

It has the same interface as the [NetworkManager](../methoddocs/managers.html#ape.managers.networks.NetworkManager).

### project fixture

You also have access to the `project` you are testing. You will need this to deploy your contracts in your tests.

```python
import pytest


@pytest.fixture
def owner(accounts):
    return accounts[0]


@pytest.fixture
def my_contract(project, owner):
    #           ^ use the 'project' fixture from the 'ape-test' plugin
    return owner.deploy(project.MyContract)
```

It has the same interface as the [ProjectManager](../methoddocs/managers.html#module-ape.managers.project.manager).

### Contract fixture

Use the `Contract` fixture to create contract instances:

```python
@pytest.fixture
def my_contract(Contract):
    return Contract(<address>)
```

It has the same interface as the [ChainManager](../methoddocs/managers.html#ape.managers.chain.ChainManager).

## Ape testing commands

```bash
ape test
```

To run a particular test:

```bash
ape test test_my_contract
```

Use ape test `-I` to open the interactive mode at the point of exception. This allows the user to inspect the point of failure in your tests.

```bash
ape test test_my_contract -I -s
```

## Test Providers

Out-of-the-box, your tests run using the `eth-tester` provider, which comes bundled with ape.
If you have Ethereum node software installed, you can use the `ape-node` plugin that also comes with ape.

```bash
ape test --network ethereum:local:node
```

Each testing plugin should work the same way. You will have access to the same test accounts.

Another option for testing providers is the [ape-hardhat](https://github.com/ApeWorX/ape-hardhat) plugin, which does not come with `ape` but can be installed by including it in the `plugins` list in your `ape-config.yaml` file or manually installing it using the command:

```bash
ape plugins install hardhat
```

### Mining

Test providers allow you to control mining.
For example, mine an empty block using the [mine](../methoddocs/api.html#ape.api.providers.TestProviderAPI.mine) method:

```python
from ape import chain

chain.provider.mine()
```

You can also pass it a number of blocks to mine:

```python
from ape import chain

chain.provider.mine(5)
```

By default, testing providers automatically mine after sending transactions.
However, you can disable this feature by setting the property.

```python
from ape import chain

chain.provider.auto_mine = False
# You can also re-enable
chain.provider.auto_mine = True
```

## Advanced Testing Tips

If you want to use sample projects, follow this link to [Ape Academy](https://github.com/ApeAcademy).

```
project                     # The root project directory
└── tests/                  # Project tests folder, ran using the 'ape test' command to run all tests within the folder.
    └── conftest.py         # A file to define global variable for testing
    └── test_accounts.py    # A test file, if you want to ONLY run one test file you can use 'ape test test_accounts.py' command
    └── test_mint.py        # A test file
```

Here is an example of a test function from a sample [NFT project](https://github.com/ApeAcademy/ERC721)

```python
def test_account_balance(project, owner, receiver, nft):
    quantity = 1
    nft.mint(receiver, quantity, ["0"], value=nft.PRICE() * quantity, sender=owner)
    actual = project.balanceOf(receiver)
    expect = quantity
    assert actual == expect
```

## Testing Transaction Reverts

Similar to `pytest.raises()`, you can use `ape.reverts()` to assert that contract transactions fail and revert.
To learn more about reverts in Ape, see the [reverts guide](./reverts.html).

From our earlier example we can see this in action:

```python
import ape

def test_authorization(my_contract, owner, not_owner):
    my_contract.set_owner(sender=owner)
    assert owner == my_contract.owner()

    with ape.reverts("!authorized"):
        my_contract.authorized_method(sender=not_owner)
```

`reverts()` takes two optional parameters:

### `expected_message`

This is the expected revert reason given when the transaction fails.
If the message in the `ContractLogicError` raised by the transaction failure is empty or does not match the `expected_message`, then `ape.reverts()` will raise an `AssertionError`.

You may also supply an `re.Pattern` object to assert on a message pattern, rather than on an exact match.

```python
import ape
import re

# Matches explicitly "foo" or "bar"
with ape.reverts(re.compile(r"^(foo|bar)$")):
    ...
```

### `dev_message`

This is the expected dev message corresponding to the line in the contract's source code where the error occurred.
These can be helpful in optimizing for gas usage and keeping revert reason strings shorter.

Dev messages take the form of a comment in Vyper, and should be placed on the line that may cause a transaction revert:

```python
assert x != 0  # dev: invalid value
```

Take for example:

```python
# @version 0.3.7

@external
def check_value(_value: uint256) -> bool:
    assert _value != 0  # dev: invalid value
    return True
```

We can explicitly cause a transaction revert and check the failed line by supplying an expected `dev_message`:

```python
import ape

def test_authorization(my_contract, owner):
    with ape.reverts(dev_message="dev: invalid value"):
        my_contract.check_value(sender=owner)
```

When the transaction reverts and `ContractLogicError` is raised, `ape.reverts()` will check the source contract to see if the failed line contains a message.

There are a few scenarios where `AssertionError` will be raised when using `dev_message`:

- If the line in the source contract has a different dev message or no dev message
- If the contract source cannot be obtained
- If the transaction trace cannot be obtained

Because `dev_message` relies on transaction tracing to function, you must use a provider like [ape-hardhat](https://github.com/ApeWorX/ape-hardhat) when testing with `dev_message`.

You may also supply an `re.Pattern` object to assert on a dev message pattern, rather than on an exact match.

```python
import ape

# Matches explictly "dev: foo" or "dev: bar"
with ape.reverts(dev_message=re.compile(r"^dev: (foo|bar)$")):
    ...
```

### Caveats

#### Language Support

As of `ape` version `0.5.6`, `dev_messages` assertions are available for contracts compiled with [ape-vyper](https://github.com/ApeWorX/ape-vyper), but not for those compiled with [ape-solidity](https://github.com/ApeWorX/ape-solidity) or [ape-cairo](https://github.com/ApeWorX/ape-cairo).

#### Inlining

Due to function inlining, the position of the `# dev: ...` message may sometimes be one line higher than expected:

```python
@external
def foo(_x: decimal) -> decimal:  # dev: correct location
    return sqrt(_x)  # dev: incorrect location
```

This typically only applies when trying to add dev messages to statements containing built-in function calls.

#### Non-reentrant Functions

Similarly, if you require dev assertions for non-reentrant functions you must be sure to leave the comment on the function that should not have reentry:

```python
@internal
@nonreentrant('lock')
def _foo_internal():  # dev: correct location
    pass

@external
@nonreentrant('lock')
def foo():
    self._foo_internal()  # dev: incorrect location
```

### Custom Errors

In your tests, you can make assertions about custom errors raised.
(For more information on custom errors, [see reverts guide on custom errors](./reverts.html#custom-errors).)

For example, assume a custom exception in a Solidity contract (variable `contract`) is called `Unauthorized`.
It can be accessed via `contract.Unauthorized`.
We can ensure unauthorized withdraws are disallowed by writing the following test:

```python
import ape
import pytest

@pytest.fixture
def owner(accounts):
    return accounts[0]

@pytest.fixture
def hacker(accounts):
    return accounts[1]

@pytest.fixture
def contract(owner, project):
    return owner.deploy(project.MyContract)

def test_unauthorized_withdraw(contract, hacker):
    with ape.reverts(contract.Unauthorized, unauth_address=hacker.address):
        contract.withdraw(sender=hacker)
```

You can also use custom error types from the contract container (from `ape.project` or the `project` fixture):

```python
import ape

def test_unauthorized(contract, hacker, project):
    with ape.reverts(project.MyContract.Unauthorized, unauth_address=hacker.address):
        contract.withdraw(sender=hacker)
```

You may need to use the container approach for asserting on custom errors that occur during failing `deploy` transactions because you won't have access to the contract instance yet.
Here is an example of what that may look like:

```python
import ape

def test_error_on_deploy(account, project):
    with ape.reverts(project.Token.MyCustomError):
        ape.project.HasError.deploy(sender=account)
```

Alternatively, you can attempt to use the address from the revert error to find the error type.

```{note}
The address will only exist for transactions that were published (e.g. not for failures during estimating gas), and this may only work on certain providers.
```

```python
import ape

def test_error_on_deploy(account):
    # NOTE: We are using `as rev` here to capture the revert info
    # so we can attempt to lookup the contract later.
    with ape.reverts() as rev:
        ape.project.HasError.deploy(sender=account)
    
    assert rev.value.address is not None, "Receipt never found, contract never cached"
    
    # Grab the cached instance using the error's address
    # and assert the custom error this way.
    contract = ape.Contract(rev.value.address)
    assert isinstance(rev.value, contract.MyError)
```

## Multi-chain Testing

The Ape framework supports connecting to alternative networks / providers in tests.

To run an entire test using a specific network / provider combination, use the `use_network` pytest marker:

```python
import pytest

@pytest.mark.use_network("fantom:local:test")
def test_my_fantom_test(chain):
    assert chain.provider.network.ecosystem.name == "fantom"

@pytest.mark.use_network("ethereum:local:test")
def test_my_ethereum_test(chain):
    assert chain.provider.network.ecosystem.name == "ethereum"
```

To switch networks mid-test, use the `networks` context-manager:

```python
# Switch to Fantom mid test
def test_my_multichain_test(networks):
    # The test starts in 1 ecosystem but switches to another
    assert networks.provider.network.ecosystem.name == "ethereum"

    with networks.fantom.local.use_provider("test") as provider:
        assert provider.network.ecosystem.name == "fantom"

    # You can also use the context manager like this:
    with networks.parse_network_choice("fantom:local:test") as provider:
       assert provider.network.ecosystem.name == "fantom"
```

You can also set the network context in a pytest fixture.
This is useful if certain fixtures must run in certain networks.

```python
import pytest

@pytest.fixture
def stark_contract(networks, project):
    with networks.parse_network_choice("starknet:local"):
        yield project.MyStarknetContract.deploy()

def test_starknet_thing(stark_contract, stark_account):
    # Uses the starknet connection via the stark_contract fixture
    receipt = stark_contract.my_method(sender=stark_account)
    assert not receipt.failed
```

When you exit a provider's context, Ape **does not** disconnect the provider.
When you re-enter that provider's context, Ape uses the previously-connected provider.
At the end of the tests, Ape disconnects all the providers.
Thus, you can enter and exit a provider's context as much as you need in tests.

## Gas Reporting

To include a gas report at the end of your tests, you can use the `--gas` flag.

```{note}
This feature works best when using a provider with tracing support, such as [ape-foundry](https://github.com/ApeWorX/ape-foundry).
When not using a provider with adequate tracing support, such as `EthTester`, gas reporting is limited to receipt-level data.
```

```bash
ape test --network ethereum:local:foundry --gas
```

At the end of test suite, you will see tables such as:

```sh
                            FundMe Gas

  Method           Times called    Min.    Max.    Mean   Median
 ────────────────────────────────────────────────────────────────
  fund                        8   57198   91398   82848    91398
  withdraw                    2   28307   38679   33493    33493
  changeOnStatus              2   23827   45739   34783    34783
  getSecret                   1   24564   24564   24564    24564

                     TestContract Gas

  Method      Times called    Min.    Max.    Mean   Median
 ───────────────────────────────────────────────────────────
  setNumber              1   51021   51021   51021    51021
```

The following demonstrates how to use the `ape-config.yaml` file to exclude contracts and / or methods from the gas report:

```yaml
test:
  gas:
    exclude:
      - method_name: DEBUG_*         # Exclude all methods starting with `DEBUG_`.
      - contract_name: MockToken     # Exclude all methods in contract named `MockToken`.
      - contract_name: PoolContract  # Exclude methods starting with `reset_` in `PoolContract`.
        method_name: reset_*
```

Similarly, you can exclude sources via the CLI option `--gas-exclude`.
The value `--gas-exclude` takes is a comma-separated list of colon-separated values representing the structure similar as above, except you must explicitly use `*` where meaning "all".
For example to exclude all methods starting with `DEBUG_`, you would do:

```bash
ape test --gas --gas-exclude "*:DEBUG_*".
```

To exclude all methods in the `MockToken` contract, do:

```bash
ape test --gas --gas-exclude MockToken
```

And finally, to exclude all methods starting with `reset_` in `PoolContract`, do:

```bash
ape test --gas --gas-exclude "PoolContract:reset_*"
```

## Iterative Testing

Ape has a set of flags that controls running your test suite locally in a "watch" mode,
which means watching for updates to files in your project and re-triggering the test suite.

To enable this mode, run `ape test --watch` to set up this mode using the default settings.
While in this mode, any time a `.py` file (i.e. your tests) or smart contract source file
(i.e. any files that get compiled using your installed compiler plugins) is added, removed,
or changed, then the `ape test` task will be re-triggered, based on a polling interval.

To exit this mode, press Ctrl+D (on Linux or macOS) to stop the execution and undo it.

## Contract Coverage

To get contract coverage, use the `--coverage` flag when running `ape test`:

```shell
ape test --coverage
```

```{note}
Some types of coverage require using a provider that supports transaction tracing, such as `ape-hardhat` or `ape-foundry`.
```

Without using a provider with adequate tracing support, coverage is limited to receipt-level data.

Afterwards, you should see a coverage report looking something like:

```shell
============================================= Coverage Profile =============================================
               Contract Coverage               
                                               
  Name          Stmts   Miss   Cover    Funcs  
 ───────────────────────────────────────────── 
  Contract.vy   7       1      85.71%   80.0% 
```

To generate other coverage reports such as XML or HTML, configure it like so:

```yaml
test:
  coverage:
    reports:
      terminal: False  # Disable the terminal table (True by default)
      xml: True  # Enable XML report (.build/coverage.xml)
      html: True  # Enable HTML report (.build/htmlcov)
```

To see a much more verbose coverage report, set the `terminal` field to a dictionary that includes `"verbose": true`:

```yaml
test:
  coverage:
    reports:
      terminal:
        verbose: true  # Show verbose coverage information in the terminal.
```

Then, you will see table outputs like this:

```shell
===================================== Coverage Profile ========================================
                MyContract Coverage

                         Func   Stmts   Miss    Cover
 ─────────────────────────────────────────────────────
                  __builtin__       2      0   100.0%
            _immutable_number       0      0   100.0%
                      _number       0      0   100.0%
                 foo_method()       1      0   100.0%
          foo_method(uint256)       1      0   100.0%
  foo_method(uint256,uint256)       3      0   100.0%
                  view_method       1      0   100.0%

           line=0.0%, func=0.0%
```

This is useful when trying to find the missing areas to cover.
The HTML report also supports `verbose: true` and it will show similar tables.

```{note}
You may notice methods with zero statements.
```

One example of a method with zero statements may be from an auto-generated getter method for a public variable; certain versions of Vyper do not contain source mappings for these methods.
However, Ape will still check to see if this method has been called in your tests.
To get 100% coverage, you must call these methods in your tests.

```{note}
Notice some methods use the full selector while others don't.
```

Methods that use the selector mean that their short name is shared with other methods.
This happens in Vyper from auto-generated kwarg-based methods.
Thus, the full selector is used to distinguish the methods in the coverage (and gas) reports.

Much like gas reporting, you can also exclude contracts and methods from tracking coverage using your `ape-config.yaml` file.
The following demonstrates how to do this:

```yaml
test:
  coverage:
    exclude:
      - method_name: DEBUG_*         # Exclude all methods starting with `DEBUG_`.
      - contract_name: MockToken     # Exclude all methods in contract named `MockToken`.
      - contract_name: PoolContract  # Exclude methods starting with `reset_` in `PoolContract`.
        method_name: reset_*
```
# Traces

A transaction's trace frames are the individual steps the transaction took.
Using traces, Ape is able to offer features like:

1. Showing a pretty call-tree from a transaction receipt
2. Gas reporting in `ape test`
3. Coverage tools in `ape test`

Some network providers, such as Alchemy and Foundry, implement `debug_traceTransaction` and Parity's `trace_transaction` affording tracing capabilities in Ape.

```{warning}
Without RPCs for obtaining traces, some features such as gas-reporting and coverage are limited.
```

To see a transaction trace, use the [show_trace()](../methoddocs/api.html#ape.api.transactions.ReceiptAPI.show_trace) method on a receipt API object.

Here is an example using `show_trace()` in Python code to print out a transaction's trace.

```{note}
This code runs assuming you are connected to `ethereum:mainnet` using a provider with tracing RPCs.
```

To learn more about networks in Ape, see the [networks guide](./networks.html).

```python
from ape import chain

tx = chain.provider.get_receipt('0xb7d7f1d5ce7743e821d3026647df486f517946ef1342a1ae93c96e4a8016eab7')

# Show the steps the transaction took.
tx.show_trace()
```

You should see a (less-abridged) trace like:

```
Call trace for '0xb7d7f1d5ce7743e821d3026647df486f517946ef1342a1ae93c96e4a8016eab7'
tx.origin=0x5668EAd1eDB8E2a4d724C8fb9cB5fFEabEB422dc
DSProxy.execute(_target=LoanShifterTaker, _data=0x35..0000) -> "" [1421947 gas]
└── (delegate) LoanShifterTaker.moveLoan(
      _exchangeData=[
        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE,
        ZERO_ADDRESS,
        
        ...
        # Abridged because is super long #
        ...
 

    │                   └── LendingRateOracle.getMarketBorrowRate(_asset=DAI) -> 
    │                       35000000000000000000000000 [1164 gas]
    ├── DSProxy.authority() -> DSGuard [1291 gas]
    ├── DSGuard.forbid(src=LoanShifterReceiver, dst=DSProxy, sig=0x1c..0000) [5253 gas]
    └── DefisaverLogger.Log(
          _contract=DSProxy, 
          _caller=tx.origin, 
          _logName="LoanShifter", 
          _data=0x00..0000
        ) [6057 gas]                                                                              
```

Similarly, you can use the provider directly to get a trace.
This is useful if you want to interact with the trace or change some parameters for creating the trace.

```python
from ape import chain

# Change the `debug_traceTransaction` parameter dictionary
trace = chain.provider.get_transaction_trace(
    "0x...", debug_trace_transaction_parameters={"enableMemory": False}
)

# You can still print the pretty call-trace (as we did in the example above)
print(trace)

# Interact with low-level logs for deeper analysis.
struct_logs = trace.get_raw_frames()
```

## Tracing Calls

Some network providers trace calls in addition to transactions.
EVM-based providers best achieve this by implementing the `debug_traceCall` RPC.

If you want to see the trace of call when making the call, use the `show_trace=` flag:

```python
token.balanceOf(account, show_trace=True)
```

```{warning}
If your provider does not properly support call-tracing (e.g. doesn't implement `debug_traceCall`), traces are limited to the top-level call.
```

Ape traces calls automatically when using `--gas` or `--coverage` in tests to build reports.
Learn more about testing in Ape in the [testing guide](./testing.html) and in the following sections.

## Gas Reports

To view the gas report of a transaction receipt, use the [ReceiptAPI.show_gas_report()](../methoddocs/api.html?highlight=receiptapi#ape.api.transactions.ReceiptAPI.show_gas_report) method:

```python
from ape import networks

txn_hash = "0x053cba5c12172654d894f66d5670bab6215517a94189a9ffc09bc40a589ec04d"
receipt = networks.provider.get_receipt(txn_hash)
receipt.show_gas_report()
```

It outputs tables of contracts and methods with gas usages that look like this:

```
                            DAI Gas

  Method           Times called    Min.    Max.    Mean   Median
 ────────────────────────────────────────────────────────────────
  balanceOf                   4   1302    13028   1302    1302
  allowance                   2   1377    1377    1337    1337
│ approve                     1   22414   22414   22414   22414
│ burn                        1   11946   11946   11946   11946
│ mint                        1   25845   25845   25845   25845
```
# Transactions

Regardless of how you are using `ape`, you will likely be making transactions.
There are various types of transactions you can make with `ape`. A simple example is deploying a contract.

## Transfer

One of the simplest ways to transact in Ape is to use the [the transfer method](../methoddocs/api.html?highlight=accountapi#ape.api.accounts.AccountAPI.transfer).
Transfers are transactions that send the base-currency (e.g. Ether) from one account to another.

The following is a simple guide to transferring ETH.

First, launch an ape console to your network of choice (for demo purposes; transfers can happen in any Python medium):

```shell
ape console --network ethereum:mainnet:node
```

Then, load the account you want to send money from:

```shell
account = accounts.load("<my-account>")
```

Find the address you want to send money to and invoke the `.transfer()` method.
The first argument is the account you are sending money to.
The second argument is the amount you want to send.
Any additional kwargs are passed to the transaction, such as `gas`, `max_fee`, or `max_priority_fee`, etc:

```shell
other_account = "0xab5801a7d398351b8be11c439e05c5b3259aec9b"
tx = account.transfer(other_account, "1 ETH", gas=21000)
print(tx.confirmed)
```

Learn more about accounts (necessary for `.transfer()`) by following the [Accounts Guide](./accounts.html).

## Deployment

Deploying a smart contract is a unique type of transaction where we don't necessarily care about the receipt as much
as we care about the contract instance. That is why the return value from
[the deploy method](../methoddocs/api.html?highlight=accountapi#ape.api.accounts.AccountAPI.deploy) is a
[ContractInstance](../methoddocs/contracts.html?highlight=contractinstance#ape.contracts.base.ContractInstance).

The following example demonstrates a simple deployment script:

```python
from ape import accounts, project

def deploy():
    account = accounts.load("MyAccount")
    # Assume you have a contract named `MyContract` in your project's contracts folder.
    return account.deploy(project.MyContract)
```

### Deployment from Ape Console

Deploying from [ape console](./console.html) allows you to interact with a contract in real time. You can also use the `--network` flag to connect a live network.

```bash
ape console --network ethereum:sepolia:alchemy
```

This will launch an IPython shell:

```python
In [1]: dev = accounts.load("dev")
In [2]: token = dev.deploy(project.Token)
In [3]: token.contract_method_defined_in_contract()
```

For an in depth tutorial on how to deploy, please visit [ApeAcademy](https://academy.apeworx.io/).

### Deployment Metadata

To get the receipt of a `deploy` transaction, use the [ContractInstance.creation_metadata](../methoddocs/contracts.html#ape.contracts.base.ContractInstance.creation_metadata) property:

```{note}
Use `ape-etherscan` or a node with Otterscan for increased support for these features.
```

```python
from ape import accounts, project

dev = accounts.load("dev")
contract = project.MyContract.deploy(sender=dev)

# The receipt is available on the contract instance and has the expected sender.
receipt = contract.creation_metadata.receipt
assert receipt.sender == dev
```

**NOTE**: The `creation_metadata` contains other information as well, such as `.factory` for factory-deployed contracts.

## Dynamic-Fee Transactions

Before [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559), all transactions used a `gas_price`.
After the London fork of Ethereum, the `gas_price` got broken up into two values, `max_fee` and `max_priority_fee`.
The `ape` framework supports both types of transactions. By default, transactions use the dynamic-fee model.
Making contract calls without specifying any additional `kwargs` will use a dynamic-fee transaction.

Calling certain methods on a deployed-contract is one way to transact.

```python
contract = deploy()  # Example from above, that returns a contract instance.
contract.fundMyContract(value="1 gwei", sender=sender)  # Assuming there is a method named 'fundMyContract' on MyContract.
```

In the example above, the call to `fundMyContract()` invokes a dynamic-fee transaction.
To have more control of the fee-values, you can specify the `max_fee`, the `max_priority_fee`, or both.

```python
contract.fundMyContract(value="1 gwei", max_priority_fee="50 gwei", max_fee="100 gwei", sender=sender)
```

The `max_priority_fee` cannot exceed the `max_fee`, as the `max_fee` includes both the base fee and the priority fee.
The `max_priority_fee`, when omitted, defaults to the return value from the
[ProviderAPI.priority_fee](../methoddocs/api.html?highlight=accountapi#ape.api.providers.ProviderAPI.priority_fee)
method property.
The `max_fee`, when omitted, defaults to the `priority_fee` (which gets its default applied beforehand) plus the latest
the value returned from the
[ProviderAPI.base_fee](../methoddocs/api.html?highlight=accountapi#ape.api.providers.ProviderAPI.base_fee) method
property.

## Static-Fee Transactions

Static-fee transactions are the transactions that Ethereum used before the London-fork
(before [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559)).
**However, some applications may still require using static-fee transactions.**

One way to use a static-fee transaction is by specifying the `gas_price` as a key-value argument:

```python
contract.startAuction(gas_price="100 gwei", sender=sender)
```

```{note}
Miners prioritize static-fee transactions based on the highest `gas_price`.
```

Another way to use a static-fee transaction (without having to provide `gas_price`) is to set the key-value
argument `type` equal to `0x00`.

```python
contract.startAuction(type="0x0", sender=sender)
```

When declaring `type="0x0"` and _not_ specifying a `gas_price`, the `gas_price` gets set using the provider's estimation.

## Access List Transactions

Utilizing [EIP-2930](https://eips.ethereum.org/EIPS/eip-2930), you can also make access-list transactions using Ape.
Access-list transactions are static-fee transactions except you can optionally specify an access list.
Access-lists make contract-interaction more predictable and optimized.
You can also use Access-lists in Dynamic-fee transactions.

To automatically use access-list (type 1) transactions in Ape, specify `type=1` in your call:

```python
contract.startAuction(type=1, sender=sender)
```

When specifying `type=1`, Ape uses `eth_createAccessList` RPC to attach an access list to the transaction automatically.

You can also specify the access-list directly:

```python
contract.fundMyContract(type=1, sender=sender, access_list=MY_ACCESS_LIST)
```

## Payable Transactions

To add value to a transaction, use the `value=` kwarg when transacting in Ape.

```python
contract.fundMyContract(value="1 ether", sender=sender)
```

The `value="1 ether"` part is sending 1 ETH to the contract.
You would do this if `fundMyContract` was a `"payable"` method, e.g. marked `@payable` in Vyper.

## Transaction Logs

In Ape, you can easily get all the events on a receipt.
Use the `.events` property to access the ([ContractLog](../methoddocs/types.html#ape.types.ContractLog)) objects.
Each object represents an event emitted from the call.

```python
receipt = contract.fundMyContract(value="1 gwei", type="0x0", sender=sender)
print(receipt.events)
```

To only get specific log types, use the `decode_logs()` method and pass the event ABIs as arguments:

```python
for log in receipt.decode_logs(contract.FooEvent.abi, contract.BarEvent.abi):
    print(log.amount)  # Assuming 'amount' is a property on the event.
```

You can also use the [ContractEvent.from_receipt(receipt)](../methoddocs/contracts.html?highlight=contractevent#ape.contracts.base.ContractEvent.from_receipt) method:

```python
receipt = contract.fooMethod(value="1 gwei", type="0x0", sender=sender)
for log in contract.FooEvent.from_receipt(receipt):
    print(log.amount)  # Assuming 'amount' is a property on the event.
```

```{note}
If you have more than one event with the same name in your contract type's ABI, you can access the events by using the [get_event_by_signature()](../methoddocs/contracts.html?highlight=contractinstance#ape.contracts.base.ContractInstance.get_event_by_signature) method:
```

```python
event_type = contract.get_event_by_signature("FooEvent(uint256 bar, uint256 baz)")
receipt.decode_logs(event_type.abi)
```

Otherwise, you will get an `AttributeError`.

## Transaction Acceptance Timeout

```{note}
For longer running scripts, you may need to increase the transaction acceptance timeout.
```

The default value is 2 minutes for live networks and 20 seconds for local networks.
In your `ape-config.yaml` file, add the following:

```yaml
ethereum:
  mainnet:
    transaction_acceptance_timeout: 600  # 5 minutes
```

## Traces

Transaction traces are the steps in the contract the transaction took.
Traces both power a myriad of features in Ape as well are themselves a tool for developers to use to debug transactions.
To learn more about traces, see the [traces userguide](./trace.html).

## Estimate Gas Cost

To estimate the gas cost on a transaction or call without sending it, use the `estimate_gas_cost()` method from the contract's transaction / call handler:
(Assume I have a contract instance named `contract_a` that has a method named `methodToCall`)

```python
txn_cost = contract_a.myMutableMethod.estimate_gas_cost(1, sender=accounts.load("me"))
print(txn_cost)

view_cost = contract_a.myViewMethod.estimate_gas_cost()
print(view_cost)
```
# Developing Bots

In this guide, we are going to show you more details on how to build an bot with Silverback.

## Prerequisites

You should have a python project with Silverback installed.
You can install Silverback via `pip install silverback`

## Project structure

There are 3 suggested ways to structure your project. In the root directory of your project:

1. Create a `bot.py` file. This is the simplest way to define your bot project.

2. Create a `bots/` folder. Then develop bots in this folder as separate scripts (Do not include a __init__.py file).

3. Create a `bot/` folder with a `__init__.py` file that will include the instantiation of your `SilverbackBot()` object.

The `silverback` cli automatically searches for python scripts to run as bots in specific locations relative to the root of your project.
It will also be able to detect the scripts inside your `bots/` directory and let you run those by name (in case you have multiple bots in your project).

If `silverback` finds a module named `bot` in the root directory of the project, then it will use that by default.

```{note}
It is suggested that you create the instance of your `SilverbackBot()` object by naming the variable `bot`, since `silverback` will autodetect that variable name when loading your script file.
```

Another way you can structure your bot is to create a `bot` folder and define a runner inside of that folder as `__init__.py`.

If you have a more complicated project that requires multiple bots, naming each bot their own individual name is okay to do, and we encourage you to locate them under the `bots/` folder relative to the root of your project.
This will work fairly seamlessly with the rest of the examples shown in this guide.

To run a bot, as long as your project directory follows the suggestions above by using a `bot` module, you can run it easily with:

```bash
silverback run --network your:network:of:choice
```

If your bot's module name is `example.py` (for example), you can run it like this:

```bash
silverback run example --network your:network:of:choice
```

If the variable that you call the `SilverbackBot()` object is something other than `bot`, you can specific that by adding `:{variable-name}`:

```bash
silverback run example:my_bot --network your:network:of:choice
```

We will automatically detect all scripts under the `bots/` folder automatically, but if your bot resides in a location other than `bots/` then you can use this to run it:

```bash
silverback run folder.example:bot --network your:network:of:choice
```

Note that with a `bot/__init__.py` setup, silverback will also autodetect it, and you can run it with:

```bash
silverback run --network your:network:of:choice
```

```{note}
It is suggested that you develop your bots as scripts to keep your deployments simple.
If you have a deep understanding of containerization, and have specific needs, you can set your bots up however you'd like, and then create your own container definitions for deployments to publish to your reqistry of choice.
For the most streamlined experience, develop your bots as scripts, and avoid relying on local packages
(e.g. do not include an `__init__.py` file inside your `bots/` directory, and do not use local modules inside `bots/` for reusable code).
If you follow these suggestions, your Silverback deployments will be easy to use and require almost no thought.
```

## Creating a Bot

Creating a Silverback Bot is easy, to do so initialize the `silverback.SilverbackBot` class:

```py
from silverback import SilverbackBot

bot = SilverbackBot()
```

The `SilverbackBot` class handles state and configuration.
Through this class, we can hook up event handlers to be executed each time we encounter a new block or each time a specific event is emitted.
Initializing the bot creates a network connection using the Ape configuration of your local project, making it easy to add a Silverback bot to your project in order to perform automation of necessary on-chain interactions required.

However, by default an bot has no configured event handlers, so it won't be very useful.
This is where adding event handlers is useful via the `bot.on_` method.
This method lets us specify which event will trigger the execution of our handler as well as which handler to execute.

## New Block Events

To add a block handler, you will do the following:

```py
from ape import chain

@bot.on_(chain.blocks)
def handle_new_block(block):
    ...
```

Inside of `handle_new_block` you can define any logic that you want to handle each new `block` detected by the silverback client.
You can return any serializable data structure from this function and that will be stored in the results database as a trackable metric for the execution of this handler.
Any errors you raise during this function will get captured by the client, and recorded as a failure to handle this `block`.

## New Event Logs

Similarly to blocks, you can handle events emitted by a contract by adding an event handler:

```
from ape import Contract

TOKEN = Contract(<your token address here>)

@bot.on_(TOKEN.Transfer)
def handle_token_transfer_events(transfer):
    ...
```

Inside of `handle_token_transfer_events` you can define any logic that you want to handle each new `transfer` event that gets emitted by `TOKEN.Transfer` detected by the silverback client.
Again, you can return any serializable data structure from this function and that will be stored in the results database as a trackable metric for the execution of this handler.
Any errors you raise during this function will get captured by the client, and recorded as a failure to handle this `transfer` event log.

## Startup and Shutdown

### Worker Events

If you have heavier resources you want to load during startup, or want to initialize things like database connections, you can add a worker startup function like so:

```py
@bot.on_worker_startup()
def handle_on_worker_startup(state):
    # Connect to DB, set initial state, etc
    ...

@bot.on_worker_shutdown()
def handle_on_worker_shutdown(state):
    # cleanup resources, close connections cleanly, etc
    ...
```

This function comes a parameter `state` that you can use for storing the results of your startup computation or resources that you have provisioned.

It's import to note that this is useful for ensuring that your workers (of which there can be multiple) have the resources necessary to properly handle any updates you want to make in your handler functions, such as connecting to the Telegram API, an SQL or NoSQL database connection, or something else.  **This function will run on every worker process**.

*New in 0.2.0*: These events moved from `on_startup()` and `on_shutdown()` for clarity.

#### Worker State

The `state` variable is also useful as this can be made available to each handler method so other stateful quantities can be maintained for other uses.  Each distributed worker has its own instance of state.

To access the state from a handler, you must annotate `context` as a dependency like so:

```py
from typing import Annotated
from taskiq import Context, TaskiqDepends

@bot.on_(chain.blocks)
def block_handler(block, context: Annotated[Context, TaskiqDepends()]):
    # Access state via context.state
    ...
```

### Bot Events

You can also add an bot startup and shutdown handler that will be **executed once upon every bot startup**.  This may be useful for things like processing historical events since the bot was shutdown or other one-time actions to perform at startup.

```py
@bot.on_startup()
def handle_on_startup(startup_state):
    # Process missed events, etc
    # process_history(start_block=startup_state.last_block_seen)
    # ...or startup_state.last_block_processed
    ...


@bot.on_shutdown()
def handle_on_shutdown():
    # Record final state, etc
    ...
```

*Changed in 0.2.0*: The behavior of the `@bot.on_startup()` decorator and handler signature have changed.  It is now executed only once upon bot startup and worker events have moved on `@bot.on_worker_startup()`.

## Bot State

Sometimes it is very useful to have access to values in a shared state across your workers.
For example you might have a value or complex reference type that you wish to update during one of your tasks, and read during another.
Silverback provides `bot.state` to help with these use cases.

For example, you might want to pre-populate a large dataframe into state on startup, keeping that dataframe in sync with the chain through event logs,
and then use that data to determine a signal under which you want trigger transactions to commit back to the chain.
Such an bot might look like this:

```py
@bot.on_startup()
def create_table(startup_state):
    df = contract.MyEvent.query(..., start_block=startup_state.last_block_processed)
    ...  # Do some further processing on df
    bot.state.table = df


@bot.on_(contract.MyEvent)
def update_table(log):
    bot.state.table = ...  # Update using stuff from `log`


@bot.on_(chain.blocks)
def use_table(blk):
    if bot.state.table[...].mean() > bot.state.table[...].sum():
        # Trigger your bot to send a transaction from `bot.signer`
        contract.myMethod(..., sender=bot.signer)
    ...
```

```{warning}
You can use `bot.state` to store any python variable type, however note that the item is not networked nor threadsafe so it is not recommended to have multiple tasks write to the same value in state at the same time.
```

```{note}
Bot startup and bot runtime event triggers (e.g. block or event container) are handled distinctly and can be trusted not to execute at the same time.
```

### Signing Transactions

If configured, your bot with have `bot.signer` which is an Ape account that can sign arbitrary transactions you ask it to.
To learn more about signing transactions with Ape, see the [documentation](https://docs.apeworx.io/ape/stable/userguides/transactions.html).

```{warning}
While not recommended, you can use keyfile accounts for automated signing.
See [this guide](https://docs.apeworx.io/ape/stable/userguides/accounts.html#automation) to learn more about how to do that.
```

## Running your Bot

Once you have programmed your bot, it's really useful to be able to run it locally and validate that it does what you expect it to do.
To run your bot locally, we have included a really useful cli command [`run`](../commands/run) that takes care of connecting to the proper network, configuring signers (using your local Ape accounts), and starting up the bot client and in-memory task queue workers.

```sh
# Run your bot on the Ethereum Sepolia testnet, with your own signer:
$ silverback run my_bot --network :sepolia --account acct-name
```

```{note}
`my_bot:bot` is not required for silverback run if you follow the suggested folder structure at the start of this page, you can just call it via `my_bot`.
```

It's important to note that signers are optional, if not configured in the bot then `bot.signer` will be `None`.
You can use this in your bot to enable a "test execution" mode, something like this:

```py
# Compute some metric that might lead to creating a transaction
if bot.signer:
    # Execute a transaction via `sender=bot.signer`
else:
    # Log what the transaction *would* have done, had a signer been enabled
```

```{warning}
If you configure your bot to use a signer, and that signer signs anything given to it, remember that you can lose substational amounts of funds if you deploy this to a production network.
Always test your bots throughly before deploying, and always use a dedicated key for production signing with your bot in a remote setting.
```

```{note}
It is highly suggested to use a dedicated cloud signer plugin, such as [`ape-aws`](https://github.com/ApeWorX/ape-aws) for signing transactions in a cloud environment.
Use segregated keys and limit your risk by controlling the amount of funds that key has access to at any given time.
```

### Distributed Execution

Using only the `silverback run ...` command in a default configuration executes everything in one process and the job queue is completely in-memory with a shared state.
In some high volume environments, you may want to deploy your Silverback bot in a distributed configuration using multiple processes to handle the messages at a higher rate.

The primary components are the client and workers.  The client handles Silverback events (blocks and contract event logs) and creates jobs for the workers to process in an asynchronous manner.

For this to work, you must configure a [TaskIQ broker](https://taskiq-python.github.io/guide/architecture-overview.html#broker) capable of distributed processing.
Additonally, it is highly suggested you should also configure a [TaskIQ result backend](https://taskiq-python.github.io/guide/architecture-overview.html#result-backend) in order to process and store the results of executing tasks.

```{note}
Without configuring a result backend, Silverback may not work as expected since your tasks will now suddenly return `None` instead of the actual result.
```

For instance, with [`taskiq_redis`](https://github.com/taskiq-python/taskiq-redis) you could do something like this for the client:

```bash
export SILVERBACK_BROKER_CLASS="taskiq_redis:ListQueueBroker"
export SILVERBACK_BROKER_KWARGS='{"queue_name": "taskiq", "url": "redis://127.0.0.1:6379"}'
export SILVERBACK_RESULT_BACKEND_CLASS="taskiq_redis:RedisAsyncResultBackend"
export SILVERBACK_RESULT_BACKEND_URI="redis://127.0.0.1:6379"

silverback run --network :mainnet:alchemy
```

And then the worker process with 2 worker subprocesses:

```bash
export SILVERBACK_BROKER_CLASS="taskiq_redis:ListQueueBroker"
export SILVERBACK_BROKER_KWARGS='{"url": "redis://127.0.0.1:6379"}'
export SILVERBACK_RESULT_BACKEND_CLASS="taskiq_redis:RedisAsyncResultBackend"
export SILVERBACK_RESULT_BACKEND_URI="redis://127.0.0.1:6379"

silverback worker -w 2
```

The client will send tasks to the 2 worker subprocesses, and all task queue and results data will be go through Redis.

## Testing your Bot

TODO: Add backtesting mode w/ `silverback test`

## Deploying your Bot

Check out the [Platform Deployment Userguide](./platform.html) for more information on how to deploy your bot to the [Silverback Platform](https://silverback.apeworx.io).
# Deploying Bots

In this guide, we are going to show you more details on how to deploy your application to the [Silverback Platform](https://silverback.apeworx.io).

## Creating a Cluster

The Silverback Platform runs your Bots on dedicated managed application Clusters.
These Clusters will take care to orchestrate infrastructure, monitor, run your triggers, and collect metrics for your applications.
Each Cluster is bespoke for an individual or organization, and isolates your applications from others on different infrastructure.

Before we deploy our Bot, we have to create a Cluster.
If you haven't yet, please sign up for Silverback at [https://silverback.apeworx.io](https://silverback.apeworx.io).

Once you have signed up, you can actually create (and pay for) your Clusters from the Silverback CLI utility by first
logging in to the Platform using [`silverback login`][silverback-login],
and then using [`silverback cluster new`][silverback-cluster-new] to follow the steps necessary to deploy it.

```{note}
The Platform UI will let you create and manage Clusters using a graphical experience, which may be preferred.
The CLI experience is for those working locally who don't want to visit the website, or are locally developing their applications.
```

Once you have created your Cluster, you have to fund it so it is made available for your use.
To do that, use the [`silverback cluster pay create`][silverback-cluster-pay-create] command to fund your newly created cluster.
Please note that provisioning your cluster will take time, and it may take up to an hour for it to be ready.
Check back after 10-15 minutes using the [`silverback cluster info`][silverback-cluster-info] command to see when it's ready.

At any point after the Cluster is funded, you can fund it with more funds via [`silverback cluster pay add-time`][silverback-cluster-pay-add-time]
command to extend the timeline that the Cluster is kept around for.
Note that it is possible for anyone to add more time to the Cluster, at any time and for any amount.

If that timeline expires, the Platform will automatically de-provision your infrastructure, and it is not possible to reverse this!
The Platform may send you notifications when your Stream is close to expiring, but it is up to you to remember to fill it so it doesn't.
Note that your data collection will stay available for up to 30 days allowing you the ability to download any data you need.

Lastly, if you ever feel like you no longer need your Cluster, you can cancel the funding for it and get a refund of the remaining funds.
If you are the owner of the Stream, you can do this via the [`silverback cluster pay cancel`][silverback-cluster-pay-cancel] command.
Only the owner may do this, so if you are not the owner you should contact them to have them do that action for you.

## Connecting to your Cluster

To connect to a cluster, you can use commands from the [`silverback cluster`][silverback-cluster] subcommand group.
For instance, to list all your available bots on your cluster, use [`silverback cluster bots list`][silverback-cluster-bots-list].
To obtain general information about your cluster, just use [`silverback cluster info`][silverback-cluster-info],
or [`silverback cluster health`][silverback-cluster-health] to see the current status of your Cluster.

If you have no bots, we will first have to containerize our Bots and upload them to a container registry that our Cluster is configured to access.

```{note}
Building a container for your application can be an advanced topic, we have included the `silverback build` subcommand to help assist in generating Dockerfiles.
```

## Building your Bot

To build your container definition(s) for your bot(s), you can use the `silverback build` command. This command searches your `bots` directory for python modules, then auto-generates Dockerfiles.

For example, if your directory is structured as suggested in [development](./development), and your `bots/` directory looks like this:

```
bots/
├── botA.py
├── botB.py
├── botC.py
```

Then you can use `silverback build --generate` to generate 3 separate Dockerfiles for those bots, and start trying to build them.

Those Dockerfiles will appear under `.silverback-images/` as follows:

```bash
silverback build --generate
```

This method will generate 3 Dockerfiles:

```
.silverback-images/
├── Dockerfile.botA
├── Dockerfile.botB
├── Dockerfile.botC
```

You can retry you builds using the following (assuming you don't modify the structure of your project):

```bash
silverback build
```

You can then push your image to your registry using:

```bash
docker push your-registry-url/project/botA:latest
```

TODO: The ApeWorX team has github actions definitions for building, pushing and deploying.

If you are unfamiliar with docker and container registries, you can use the \[\[github-action\]\].

You do not need to build using this command if you use the github action, but it is there to help you if you are having problems figuring out how to build and run your bot images on the cluster successfully.

TODO: Add how to debug containers using `silverback run` w/ `taskiq-redis` broker

## Adding Environment Variables

Once you have created your bot application container image, you might know of some environment variables the image requires to run properly.
Thanks to it's flexible plugin system, ape plugins may also require specific environment variables to load as well.
Silverback Clusters include an environment variable management system for exactly this purpose,
which you can manage using [`silverback cluster vars`][silverback-cluster-vars] subcommand.

The environment variable management system makes use of a concept called "Variable Groups" which are distinct collections of environment variables meant to be used together.
These variable groups will help in managing the runtime environment of your Bots by allowing you to segregate different variables depending on each bot's needs.

To create an environment group, use the [`silverback cluster vars new`][silverback-cluster-vars-new] command and give it a name and a set of related variables.
For instance, it may make sense to make a group of variables for your favorite Ape plugins or services, such as RPC Providers, Blockchain Data Indexers, Etherscan, etc.
You might have a database connection that you want all your bots to access.

```{warning}
All environment variables in Silverback Clusters are private, meaning they cannot be viewed after they are uploaded.
However, your Bots will have full access to their values from within their runtime environment, so be careful that you fully understand what you are sharing with your bots.

Also, understand your build dependencies within your container and make sure you are not using any vulnerable or malicious packages.

**NEVER** upload your private key in a plaintext format!

Use _Ape Account Plugins_ such as [`ape-aws`](https://github.com/ApeWorX/ape-aws) to safely manage access to your hosted keys.
```

```{note}
The Etherscan plugin _will not function_ without an API key in the cloud environment.
This will likely create errors running your applications if you use Ape's `Contract` class.
```

To list your Variable Groups, use [`silverback cluster vars list`][silverback-cluster-vars-list].
To see information about a specific Variable Group, including the Environment Variables it includes, use [`silverback cluster vars info`][silverback-cluster-vars-info]
To remove a variable group, use [`silverback cluster vars remove`][silverback-cluster-vars-remove],

```{note}
You can only remove a Variable Group if it is not referenced by any existing Bot.
```

Once you have created all the Variable Group(s) that you need to operate your Bot, you can reference these groups by name when adding your Bot to the cluster.

## Private Container Registries

If you are using a private container registry to store your images, you will need to provide your bot with the necessary credentials to access it.
First you will need to add your credentials to the cluster with the [`silverback cluster registry auth new`][silverback-cluster-registry-auth-new] command.

Then you can provide the name of these credentials when creating your bot with the [`silverback cluster bots new`][silverback-cluster-bots-new] or [`silverback cluster bots update`][silverback-cluster-bots-update] commands.

## Deploying your Bot

You are finally ready to deploy your bot on the Cluster and get it running!

To deploy your Bot, use the [`silverback cluster bots new`][silverback-cluster-bots-new] command and give your bot a name,
container image, network to run on, an account alias (if you want to sign transactions w/ `bot.signer`),
and any environment Variable Group(s) the bot needs.
If everything validates successfully, the Cluster will begin orchestrating your deployment for you.

You should monitor the deployment and startup of your bot to make sure it enters the RUNNING state successfully.
You can do this using the [`silverback cluster bots health`][silverback-cluster-bots-health] command.

```{note}
It usually takes a minute or so for your bot to transition from PROVISIONING to STARTUP to the RUNNING state.
If there are any difficulties in downloading your container image, provisioning your desired infrastructure, or if your application encounters an error during the STARTUP phase,
the Bot will not enter into the RUNNING state and will be shut down gracefully into the STOPPED state.

Once in the STOPPED state, you can make any adjustments to the environment Variable Group(s) or other runtime parameters in the Bot config;
or, you can make code changes and deploy a new image for the Bot to use.
Once ready, you can use the `silverback cluster bots start` command to re-start your Bot.
```

If at any time you want to view the configuration of your bot, you can do so using the [`silverback cluster bots info`][silverback-cluster-bots-info] command.
You can also update metadata or configuration of your bot using the [`silverback cluster bots update`][silverback-cluster-bots-update] command.
Lastly, if you want to shutdown and delete your bot, you can do so using the [`silverback cluster bots remove`][silverback-cluster-bots-remove] command.

```{note}
Configuration updates do not redeploy your Bots automatically, you must manually stop and restart your bots for changes to take effect.
```

```{warning}
Removing a Bot will immediately trigger a SHUTDOWN if the Bot is not already STOPPED.
```

## Monitoring your Bot

Once your bot is successfully running in the RUNNING state, you can monitor your bot with a series of commands
under the [`silverback cluster bots`][silverback-cluster-bots] subcommand group.
We already saw how you can use the [`silverback cluster bots list`][silverback-cluster-bots-list] command to see all bots managed by your Cluster (running or not).

To see runtime health information about a specific bot, again use the [`silverback cluster bots health`][silverback-cluster-bots-health] command.
You can view the logs that a specific bot is generating using the [`silverback cluster bots logs`][silverback-cluster-bots-logs] command.
Lastly, you can view unacknowledged errors that your bot has experienced while in the RUNNING state
using the [`silverback cluster bots errors`][silverback-cluster-bots-errors] command.

```{warning}
Once in the RUNNING state, your Bot will not stop running unless it experiences a certain amount of errors in quick succession.
Any task execution that experiences an error will abort execution (and therefore not produce any metrics) but the Bot **will not** shutdown.

All errors encountered during task exeuction are reported to the Cluster for later review by any users with appriopiate access.
Tasks do not retry (by default), but updates to `bot.state` are maintained up until the point an error occurs.

It is important to keep track of these errors and ensure that none of them are in fact critical to the operation of your Bot,
and to take corrective or preventative action if it is determined that it should be treated as a more critical failure condition.
```

```{note}
Your Bots can also be monitored from the Platform UI at [https://silverback.apeworx.io](https://silverback.apeworx.io).
```

## Controlling your Bot

As we already saw, once a Bot is configured in a Cluster, we can control it using commands from the [`silverback cluster bots`][silverback-cluster-bots] subcommand group.
For example, we can attempt to start a Bot that is not currently running (after making configuration or code changes)
using the [`silverback cluster bots start`][silverback-cluster-bots-start] command.
We can also stop a bot using [`silverback cluster bots stop`][silverback-cluster-bots-stop] that is currently in the RUNNING state if we desire.

```{note}
Controlling your bots can be done from the Platform UI at [https://silverback.apeworx.io](https://silverback.apeworx.io), if you have the right permissions to do so.
```
===============
SAMPLE CODE FOR BOTS BUILT WITH SILVERBACK AND ApeWorX

```
import os

from ape import Contract, chain
from silverback import SilverbackBot


bot = SilverbackBot()

vault = Contract(os.environ["ERC4626_VAULT_ADDRESS"])

one_share = 10 ** vault.decimals()


@bot.on_(chain.blocks)
def update_shareprice(_):
    """
    Conver share to set price unit.
    """
    price = vault.convertToAssets(one_share) / one_share
    # Total number of shares in the vault divide by 
    # the current unit price of a share  = gwei 
    print(f"Price Event: {price}")
```

```
from math import log10, floor

from ape import project
from silverback import SilverbackApp
from ape_farcaster import Warpcast
import time

import os
import tempfile
import requests

from wonderwords import RandomWord

STABILITY_KEY = os.environ.get("STABILITY_KEY")
PINATA_API_KEY = os.environ.get("PINATA_API_KEY")
PINATA_SECRET_API_KEY = os.environ.get("PINATA_SECRET_API_KEY")

app = SilverbackApp()

attempts = 0
while attempts < 11:
    try:
        client = Warpcast(app.signer)
        break
    except Exception as e:
        print(e)        
        attempts+=1
        time.sleep(1)
        
my_contract = project.Echo.at(os.environ.get("ECHO_CONTRACT"))

def create_prompt(number_adj: int) -> str:
    w = RandomWord()
    adjectives = w.random_words(number_adj, include_categories=["adjective"])
    adjectives_string = ", ".join(adjectives)
    prompt = f"An {adjectives_string} ape that is screaming AHHHHH."
    return prompt


@app.on_(my_contract.Received)
def payment_received(log):
    print(log)
    prompt = create_prompt(max(floor(log10(log.amount)) - 12, 1))
    for _ in range(10):
        print(f"\n{prompt}\n")
        # create image from AI using scream
        try:
            fileName = createImage(prompt)
            break
        except Exception as e:
            print(e)
            prompt = create_prompt(max(floor(log10(log.amount)) - 12, 1))

    # open the created image
    print(fileName + " has beeen created")
    image = open(fileName, 'rb')
    # upload image to Pinata
    ipfsHash = uploadToPinata(image)
    # cast the message with the scream and ipfs link
    ipfsLink = "https://jade-slow-pigeon-687.mypinata.cloud/ipfs/" + ipfsHash
    warpcast_text = f"A picture of {log.sender}:\n"
    client.post_cast(text=warpcast_text, embeds=[ipfsLink])


def createImage(prompt):
    response = requests.post(
        "https://api.stability.ai/v2beta/stable-image/generate/ultra",
        headers={
            "authorization": STABILITY_KEY,
            "accept": "image/*"
        },
        files={"none": ''},
        data={
            "prompt": prompt,
            "output_format": "jpeg",
        },
    )
    if response.status_code == 200:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".jpeg") as fp:
            fp.write(response.content)
    else:
        raise Exception(str(response.json()))
    return fp.name


def uploadToPinata(image):
    url = "https://api.pinata.cloud/pinning/pinFileToIPFS"
    headers = {
        'pinata_api_key': PINATA_API_KEY,
        'pinata_secret_api_key': PINATA_SECRET_API_KEY,
    }

    files = {'file': ("ApeScream", image)}
    response = requests.request("POST", url, files=files, headers=headers)
    response.raise_for_status()
    return response.json()["IpfsHash"]

```.. index:: function, built-in;

.. _built_in_functions:

Built-in Functions
##################

Vyper provides a collection of built-in functions available in the global namespace of all contracts.

Bitwise Operations
==================

.. py:function:: bitwise_and(x: uint256, y: uint256) -> uint256

    Perform a "bitwise and" operation. Each bit of the output is 1 if the corresponding bit of ``x`` AND of ``y`` is 1, otherwise it is 0.

    .. code-block:: python

        @external
        @view
        def foo(x: uint256, y: uint256) -> uint256:
            return bitwise_and(x, y)

    .. code-block:: python

        >>> ExampleContract.foo(31337, 8008135)
        12353

.. note::

  This function has been deprecated from version 0.3.4 onwards. Please use the ``&`` operator instead.

.. py:function:: bitwise_not(x: uint256) -> uint256

    Return the bitwise complement of ``x`` - the number you get by switching each 1 for a 0 and each 0 for a 1.

    .. code-block:: python

        @external
        @view
        def foo(x: uint256) -> uint256:
            return bitwise_not(x)

    .. code-block:: python

        >>> ExampleContract.foo(0)
        115792089237316195423570985008687907853269984665640564039457584007913129639935

.. note::

  This function has been deprecated from version 0.3.4 onwards. Please use the ``~`` operator instead.

.. py:function:: bitwise_or(x: uint256, y: uint256) -> uint256

    Perform a "bitwise or" operation. Each bit of the output is 0 if the corresponding bit of ``x`` AND of ``y`` is 0, otherwise it is 1.

    .. code-block:: python

        @external
        @view
        def foo(x: uint256, y: uint256) -> uint256:
            return bitwise_or(x, y)

    .. code-block:: python

        >>> ExampleContract.foo(31337, 8008135)
        8027119

.. note::

  This function has been deprecated from version 0.3.4 onwards. Please use the ``|`` operator instead.

.. py:function:: bitwise_xor(x: uint256, y: uint256) -> uint256

    Perform a "bitwise exclusive or" operation. Each bit of the output is the same as the corresponding bit in ``x`` if that bit in ``y`` is 0, and it is the complement of the bit in ``x`` if that bit in ``y`` is 1.

    .. code-block:: python

        @external
        @view
        def foo(x: uint256, y: uint256) -> uint256:
            return bitwise_xor(x, y)

    .. code-block:: python

        >>> ExampleContract.foo(31337, 8008135)
        8014766

.. note::

  This function has been deprecated from version 0.3.4 onwards. Please use the ``^`` operator instead.

.. py:function:: shift(x: int256 | uint256, _shift: integer) -> uint256

    Return ``x`` with the bits shifted ``_shift`` places. A positive ``_shift`` value equals a left shift, a negative value is a right shift.

    .. code-block:: python

        @external
        @view
        def foo(x: uint256, y: int128) -> uint256:
            return shift(x, y)

    .. code-block:: python

        >>> ExampleContract.foo(2, 8)
        512

.. note::

  This function has been deprecated from version 0.3.8 onwards. Please use the ``<<`` and ``>>`` operators instead.


Chain Interaction
=================


Vyper has three built-ins for contract creation; all three contract creation built-ins rely on the code to deploy already being stored on-chain, but differ in call vs deploy overhead, and whether or not they invoke the constructor of the contract to be deployed. The following list provides a short summary of the differences between them.

* ``create_minimal_proxy_to(target: address, ...)``
    * Creates an immutable proxy to ``target``
    * Expensive to call (incurs a single ``DELEGATECALL`` overhead on every invocation), cheap to create (since it only deploys ``EIP-1167`` forwarder bytecode)
    * Does not have the ability to call a constructor
    * Does **not** check that there is code at ``target`` (allows one to deploy proxies counterfactually)
* ``create_copy_of(target: address, ...)``
    * Creates a byte-for-byte copy of runtime code stored at ``target``
    * Cheap to call (no ``DELEGATECALL`` overhead), expensive to create (200 gas per deployed byte)
    * Does not have the ability to call a constructor
    * Performs an ``EXTCODESIZE`` check to check there is code at ``target``
* ``create_from_blueprint(target: address, ...)``
    * Deploys a contract using the initcode stored at ``target``
    * Cheap to call (no ``DELEGATECALL`` overhead), expensive to create (200 gas per deployed byte)
    * Invokes constructor, requires a special "blueprint" contract to be deployed
    * Performs an ``EXTCODESIZE`` check to check there is code at ``target``

.. py:function:: create_minimal_proxy_to(target: address, value: uint256 = 0[, salt: bytes32]) -> address

    Deploys a small, EIP1167-compliant "minimal proxy contract" that duplicates the logic of the contract at ``target``, but has its own state since every call to ``target`` is made using ``DELEGATECALL`` to ``target``. To the end user, this should be indistinguishable from an independently deployed contract with the same code as ``target``.


    * ``target``: Address of the contract to proxy to
    * ``value``: The wei value to send to the new contract address (Optional, default 0)
    * ``salt``: A ``bytes32`` value utilized by the deterministic ``CREATE2`` opcode (Optional, if not supplied, ``CREATE`` is used)

    Returns the address of the newly created proxy contract. If the create operation fails (for instance, in the case of a ``CREATE2`` collision), execution will revert.

    .. code-block:: python

        @external
        def foo(target: address) -> address:
            return create_minimal_proxy_to(target)

.. note::

  It is very important that the deployed contract at ``target`` is code you know and trust, and does not implement the ``selfdestruct`` opcode or have upgradeable code as this will affect the operation of the proxy contract.

.. note::

  There is no runtime check that there is code already deployed at ``target`` (since a proxy may be deployed counterfactually). Most applications may want to insert this check.

.. note::

  Before version 0.3.4, this function was named ``create_forwarder_to``.


.. py:function:: create_copy_of(target: address, value: uint256 = 0[, salt: bytes32]) -> address

    Create a physical copy of the runtime code at ``target``. The code at ``target`` is byte-for-byte copied into a newly deployed contract.

    * ``target``: Address of the contract to copy
    * ``value``: The wei value to send to the new contract address (Optional, default 0)
    * ``salt``: A ``bytes32`` value utilized by the deterministic ``CREATE2`` opcode (Optional, if not supplied, ``CREATE`` is used)

    Returns the address of the created contract. If the create operation fails (for instance, in the case of a ``CREATE2`` collision), execution will revert. If there is no code at ``target``, execution will revert.

    .. code-block:: python

        @external
        def foo(target: address) -> address:
            return create_copy_of(target)

.. note::

    The implementation of ``create_copy_of`` assumes that the code at ``target`` is smaller than 16MB. While this is much larger than the EIP-170 constraint of 24KB, it is a conservative size limit intended to future-proof deployer contracts in case the EIP-170 constraint is lifted. If the code at ``target`` is larger than 16MB, the behavior of ``create_copy_of`` is undefined.


.. py:function:: create_from_blueprint(target: address, *args, value: uint256 = 0, raw_args: bool = False, code_offset: int = 0, [, salt: bytes32]) -> address

    Copy the code of ``target`` into memory and execute it as initcode. In other words, this operation interprets the code at ``target`` not as regular runtime code, but directly as initcode. The ``*args`` are interpreted as constructor arguments, and are ABI-encoded and included when executing the initcode.

    * ``target``: Address of the blueprint to invoke
    * ``*args``: Constructor arguments to forward to the initcode.
    * ``value``: The wei value to send to the new contract address (Optional, default 0)
    * ``raw_args``: If ``True``, ``*args`` must be a single ``Bytes[...]`` argument, which will be interpreted as a raw bytes buffer to forward to the create operation (which is useful for instance, if pre- ABI-encoded data is passed in from elsewhere). (Optional, default ``False``)
    * ``code_offset``: The offset to start the ``EXTCODECOPY`` from (Optional, default 0)
    * ``salt``: A ``bytes32`` value utilized by the deterministic ``CREATE2`` opcode (Optional, if not supplied, ``CREATE`` is used)

    Returns the address of the created contract. If the create operation fails (for instance, in the case of a ``CREATE2`` collision), execution will revert. If ``code_offset >= target.codesize`` (ex. if there is no code at ``target``), execution will revert.

    .. code-block:: python

        @external
        def foo(blueprint: address) -> address:
            arg1: uint256 = 18
            arg2: String[32] = "some string"
            return create_from_blueprint(blueprint, arg1, arg2, code_offset=1)

.. note::

    To properly deploy a blueprint contract, special deploy bytecode must be used. The output of ``vyper -f blueprint_bytecode`` will produce bytecode which deploys an ERC-5202 compatible blueprint.

.. warning::

    It is recommended to deploy blueprints with the ERC-5202 preamble ``0xFE7100`` to guard them from being called as regular contracts. This is particularly important for factories where the constructor has side effects (including ``SELFDESTRUCT``!), as those could get executed by *anybody* calling the blueprint contract directly. The ``code_offset=`` kwarg is provided to enable this pattern:

    .. code-block:: python

        @external
        def foo(blueprint: address) -> address:
            # `blueprint` is a blueprint contract with some known preamble b"abcd..."
            return create_from_blueprint(blueprint, code_offset=<preamble length>)

.. py:function:: raw_call(to: address, data: Bytes, max_outsize: uint256 = 0, gas: uint256 = gasLeft, value: uint256 = 0, is_delegate_call: bool = False, is_static_call: bool = False, revert_on_failure: bool = True) -> Bytes[max_outsize]

    Call to the specified Ethereum address.

    * ``to``: Destination address to call to
    * ``data``: Data to send to the destination address
    * ``max_outsize``: Maximum length of the bytes array returned from the call. If the returned call data exceeds this length, only this number of bytes is returned. (Optional, default ``0``)
    * ``gas``: The amount of gas to attach to the call. (Optional, defaults to ``msg.gas``).
    * ``value``: The wei value to send to the address (Optional, default ``0``)
    * ``is_delegate_call``: If ``True``, the call will be sent as ``DELEGATECALL`` (Optional, default ``False``)
    * ``is_static_call``: If ``True``, the call will be sent as ``STATICCALL`` (Optional, default ``False``)
    * ``revert_on_failure``: If ``True``, the call will revert on a failure, otherwise ``success`` will be returned (Optional, default ``True``)

    .. note::

        Returns the data returned by the call as a ``Bytes`` list, with ``max_outsize`` as the max length. The actual size of the returned data may be less than ``max_outsize``. You can use ``len`` to obtain the actual size.

        Returns nothing if ``max_outsize`` is omitted or set to ``0``.

        Returns ``success`` in a tuple with return value if ``revert_on_failure`` is set to ``False``.

    .. code-block:: python

        @external
        @payable
        def foo(_target: address) -> Bytes[32]:
            response: Bytes[32] = raw_call(_target, method_id("someMethodName()"), max_outsize=32, value=msg.value)
            return response

        @external
        @payable
        def bar(_target: address) -> Bytes[32]:
            success: bool = False
            response: Bytes[32] = b""
            x: uint256 = 123
            success, response = raw_call(
                _target,
                _abi_encode(x, method_id=method_id("someMethodName(uint256)")),
                max_outsize=32,
                value=msg.value,
                revert_on_failure=False
                )
            assert success
            return response

    .. note::

        Regarding "forwarding all gas", note that, while Vyper will provide ``msg.gas`` to the call, in practice, there are some subtleties around forwarding all remaining gas on the EVM which are out of scope of this documentation and could be subject to change. For instance, see the language in EIP-150 around "all but one 64th".

.. py:function:: raw_log(topics: bytes32[4], data: Union[Bytes, bytes32]) -> None

    Provides low level access to the ``LOG`` opcodes, emitting a log without having to specify an ABI type.

    * ``topics``: List of ``bytes32`` log topics. The length of this array determines which opcode is used.
    * ``data``: Unindexed event data to include in the log. May be given as ``Bytes`` or ``bytes32``.

    .. code-block:: python

        @external
        def foo(_topic: bytes32, _data: Bytes[100]):
            raw_log([_topic], _data)

.. py:function:: raw_revert(data: Bytes) -> None

    Provides low level access to the ``REVERT`` opcode, reverting execution with the specified data returned.

    * ``data``: Data representing the error message causing the revert.

    .. code-block:: python

        @external
        def foo(_data: Bytes[100]):
            raw_revert(_data)

.. py:function:: selfdestruct(to: address) -> None

    Trigger the ``SELFDESTRUCT`` opcode (``0xFF``), causing the contract to be destroyed.

    * ``to``: Address to forward the contract's ether balance to

    .. warning::

        This method deletes the contract from the blockchain. All non-ether assets associated with this contract are "burned" and the contract is no longer accessible.

    .. note::

        This function has been deprecated from version 0.3.8 onwards. The underlying opcode will eventually undergo breaking changes, and its use is not recommended.

    .. code-block:: python

        @external
        def do_the_needful():
            selfdestruct(msg.sender)

.. py:function:: send(to: address, value: uint256, gas: uint256 = 0) -> None

    Send ether from the contract to the specified Ethereum address.

    * ``to``: The destination address to send ether to
    * ``value``: The wei value to send to the address
    * ``gas``: The amount of gas (the "stipend") to attach to the call. If not set, the stipend defaults to 0.

    .. note::

        The amount to send is always specified in ``wei``.

    .. code-block:: python

        @external
        def foo(_receiver: address, _amount: uint256, gas: uint256):
            send(_receiver, _amount, gas=gas)

Cryptography
============

.. py:function:: ecadd(a: uint256[2], b: uint256[2]) -> uint256[2]

    Take two points on the Alt-BN128 curve and add them together.

    .. code-block:: python

        @external
        @view
        def foo(x: uint256[2], y: uint256[2]) -> uint256[2]:
            return ecadd(x, y)

    .. code-block:: python

        >>> ExampleContract.foo([1, 2], [1, 2])
        [
            1368015179489954701390400359078579693043519447331113978918064868415326638035,
            9918110051302171585080402603319702774565515993150576347155970296011118125764,
        ]

.. py:function:: ecmul(point: uint256[2], scalar: uint256) -> uint256[2]

    Take a point on the Alt-BN128 curve (``p``) and a scalar value (``s``), and return the result of adding the point to itself ``s`` times, i.e. ``p * s``.

    * ``point``: Point to be multiplied
    * ``scalar``: Scalar value

    .. code-block:: python

        @external
        @view
        def foo(point: uint256[2], scalar: uint256) -> uint256[2]:
            return ecmul(point, scalar)

    .. code-block:: python

        >>> ExampleContract.foo([1, 2], 3)
        [
            3353031288059533942658390886683067124040920775575537747144343083137631628272,
            19321533766552368860946552437480515441416830039777911637913418824951667761761,
        ]

.. py:function:: ecrecover(hash: bytes32, v: uint256 | uint8, r: uint256 | bytes32, s: uint256 | bytes32) -> address

    Recover the address associated with the public key from the given elliptic curve signature.

    * ``r``: first 32 bytes of signature
    * ``s``: second 32 bytes of signature
    * ``v``: final 1 byte of signature

    Returns the associated address, or ``empty(address)`` on error.

    .. note::

         Prior to Vyper ``0.3.10``, the ``ecrecover`` function could return an undefined (possibly nonzero) value for invalid inputs to ``ecrecover``. For more information, please see `GHSA-f5x6-7qgp-jhf3 <https://github.com/vyperlang/vyper/security/advisories/GHSA-f5x6-7qgp-jhf3>`_.

    .. code-block:: python

        @external
        @view
        def foo(hash: bytes32, v: uint8, r:bytes32, s:bytes32) -> address:
            return ecrecover(hash, v, r, s)


        @external
        @view
        def foo(hash: bytes32, v: uint256, r:uint256, s:uint256) -> address:
            return ecrecover(hash, v, r, s)
    .. code-block:: python

        >>> ExampleContract.foo('0x6c9c5e133b8aafb2ea74f524a5263495e7ae5701c7248805f7b511d973dc7055',
             28,
             78616903610408968922803823221221116251138855211764625814919875002740131251724,
             37668412420813231458864536126575229553064045345107737433087067088194345044408
            )
        '0x9eE53ad38Bb67d745223a4257D7d48cE973FeB7A'

.. py:function:: keccak256(_value) -> bytes32

    Return a ``keccak256`` hash of the given value.

    * ``_value``: Value to hash. Can be a ``String``, ``Bytes``, or ``bytes32``.

    .. code-block:: python

        @external
        @view
        def foo(_value: Bytes[100]) -> bytes32
            return keccak256(_value)

    .. code-block:: python

        >>> ExampleContract.foo(b"potato")
        0x9e159dfcfe557cc1ca6c716e87af98fdcb94cd8c832386d0429b2b7bec02754f

.. py:function:: sha256(_value) -> bytes32

    Return a ``sha256`` (SHA2 256-bit output) hash of the given value.

    * ``_value``: Value to hash. Can be a ``String``, ``Bytes``, or ``bytes32``.

    .. code-block:: python

        @external
        @view
        def foo(_value: Bytes[100]) -> bytes32
            return sha256(_value)

    .. code-block:: python

        >>> ExampleContract.foo(b"potato")
        0xe91c254ad58860a02c788dfb5c1a65d6a8846ab1dc649631c7db16fef4af2dec

Data Manipulation
=================

.. py:function:: concat(a, b, *args) -> Union[Bytes, String]

    Take 2 or more bytes arrays of type ``bytesM``, ``Bytes`` or ``String`` and combine them into a single value.

    If the input arguments are ``String`` the return type is ``String``.  Otherwise the return type is ``Bytes``.

    .. code-block:: python

        @external
        @view
        def foo(a: String[5], b: String[5], c: String[5]) -> String[100]:
            return concat(a, " ", b, " ", c, "!")

    .. code-block:: python

        >>> ExampleContract.foo("why","hello","there")
        "why hello there!"

.. py:function:: convert(value, type_) -> Any

    Converts a variable or literal from one type to another.

    * ``value``: Value to convert
    * ``type_``: The destination type to convert to (e.g., ``bool``, ``decimal``, ``int128``, ``uint256`` or ``bytes32``)

    Returns a value of the type specified by ``type_``.

    For more details on available type conversions, see :ref:`type_conversions`.

.. py:function:: uint2str(value: unsigned integer) -> String

    Returns an unsigned integer's string representation.

    * ``value``: Unsigned integer to convert.

    Returns the string representation of ``value``.

    .. code-block:: python

        @external
        @view
        def foo(b: uint256) -> String[78]:
            return uint2str(b)

    .. code-block:: python

        >>> ExampleContract.foo(420)
        "420"

.. py:function:: extract32(b: Bytes, start: uint256, output_type=bytes32) -> Any

    Extract a value from a ``Bytes`` list.

    * ``b``: ``Bytes`` list to extract from
    * ``start``: Start point to extract from
    * ``output_type``: Type of output (``bytesM``, ``integer``, or ``address``). Defaults to ``bytes32``.

    Returns a value of the type specified by ``output_type``.

    .. code-block:: python

        @external
        @view
        def foo(b: Bytes[32]) -> address:
            return extract32(b, 0, output_type=address)

    .. code-block:: python

        >>> ExampleContract.foo("0x0000000000000000000000009f8F72aA9304c8B593d555F12eF6589cC3A579A2")
        "0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2"

.. py:function:: slice(b: Union[Bytes, bytes32, String], start: uint256, length: uint256) -> Union[Bytes, String]

    Copy a list of bytes and return a specified slice.

    * ``b``: value being sliced
    * ``start``: start position of the slice
    * ``length``: length of the slice

    If the value being sliced is a ``Bytes`` or ``bytes32``, the return type is ``Bytes``.  If it is a ``String``, the return type is ``String``.

    .. code-block:: python

        @external
        @view
        def foo(s: String[32]) -> String[5]:
            return slice(s, 4, 5)

    .. code-block:: python

        >>> ExampleContract.foo("why hello! how are you?")
        "hello"

Math
====

.. py:function:: abs(value: int256) -> int256

    Return the absolute value of a signed integer.

    * ``value``: Integer to return the absolute value of

    .. code-block:: python

        @external
        @view
        def foo(value: int256) -> int256:
            return abs(value)

    .. code-block:: python

        >>> ExampleContract.foo(-31337)
        31337

.. py:function:: ceil(value: decimal) -> int256

    Round a decimal up to the nearest integer.

    * ``value``: Decimal value to round up

    .. code-block:: python

        @external
        @view
        def foo(x: decimal) -> int256:
            return ceil(x)

    .. code-block:: python

        >>> ExampleContract.foo(3.1337)
        4

.. py:function:: epsilon(typename) -> Any

    Returns the smallest non-zero value for a decimal type.

    * ``typename``: Name of the decimal type (currently only ``decimal``)

    .. code-block:: python

        @external
        @view
        def foo() -> decimal:
            return epsilon(decimal)

    .. code-block:: python

        >>> ExampleContract.foo()
        Decimal('1E-10')

.. py:function:: floor(value: decimal) -> int256

    Round a decimal down to the nearest integer.

    * ``value``: Decimal value to round down

    .. code-block:: python

        @external
        @view
        def foo(x: decimal) -> int256:
            return floor(x)

    .. code-block:: python

        >>> ExampleContract.foo(3.1337)
        3

.. py:function:: max(a: numeric, b: numeric) -> numeric

    Return the greater value of ``a`` and ``b``. The input values may be any numeric type as long as they are both of the same type.  The output value is of the same type as the input values.

    .. code-block:: python

        @external
        @view
        def foo(a: uint256, b: uint256) -> uint256:
            return max(a, b)

    .. code-block:: python

        >>> ExampleContract.foo(23, 42)
        42

.. py:function:: max_value(type_) -> numeric

    Returns the maximum value of the numeric type specified by ``type_`` (e.g., ``int128``, ``uint256``, ``decimal``).

    .. code-block:: python

        @external
        @view
        def foo() -> int256:
            return max_value(int256)

    .. code-block:: python

        >>> ExampleContract.foo()
        57896044618658097711785492504343953926634992332820282019728792003956564819967

.. py:function:: min(a: numeric, b: numeric) -> numeric

    Returns the lesser value of ``a`` and ``b``. The input values may be any numeric type as long as they are both of the same type.  The output value is of the same type as the input values.

    .. code-block:: python

        @external
        @view
        def foo(a: uint256, b: uint256) -> uint256:
            return min(a, b)

    .. code-block:: python

        >>> ExampleContract.foo(23, 42)
        23

.. py:function:: min_value(type_) -> numeric

    Returns the minimum value of the numeric type specified by ``type_`` (e.g., ``int128``, ``uint256``, ``decimal``).

    .. code-block:: python

        @external
        @view
        def foo() -> int256:
            return min_value(int256)

    .. code-block:: python

        >>> ExampleContract.foo()
        -57896044618658097711785492504343953926634992332820282019728792003956564819968

.. py:function:: pow_mod256(a: uint256, b: uint256) -> uint256

    Return the result of ``a ** b % (2 ** 256)``.

    This method is used to perform exponentiation without overflow checks.

    .. code-block:: python

        @external
        @view
        def foo(a: uint256, b: uint256) -> uint256:
            return pow_mod256(a, b)

    .. code-block:: python

        >>> ExampleContract.foo(2, 3)
        8
        >>> ExampleContract.foo(100, 100)
        59041770658110225754900818312084884949620587934026984283048776718299468660736

.. py:function:: sqrt(d: decimal) -> decimal

    Return the square root of the provided decimal number, using the Babylonian square root algorithm.

    .. code-block:: python

        @external
        @view
        def foo(d: decimal) -> decimal:
            return sqrt(d)

    .. code-block:: python

        >>> ExampleContract.foo(9.0)
        3.0

.. py:function:: isqrt(x: uint256) -> uint256

    Return the (integer) square root of the provided integer number, using the Babylonian square root algorithm. The rounding mode is to round down to the nearest integer. For instance, ``isqrt(101) == 10``.

    .. code-block:: python

        @external
        @view
        def foo(x: uint256) -> uint256:
            return isqrt(x)

    .. code-block:: python

        >>> ExampleContract.foo(101)
        10

.. py:function:: uint256_addmod(a: uint256, b: uint256, c: uint256) -> uint256
    
    Return the modulo of ``(a + b) % c``. Reverts if ``c == 0``. As this built-in function is intended to provides access to the underlying ``ADDMOD`` opcode, all intermediate calculations of this operation are not subject to the ``2 ** 256`` modulo according to the EVM specifications.

    .. code-block:: python

        @external
        @view
        def foo(a: uint256, b: uint256, c: uint256) -> uint256:
            return uint256_addmod(a, b, c)

    .. code-block:: python

        >>> (6 + 13) % 8
        3
        >>> ExampleContract.foo(6, 13, 8)
        3

.. py:function:: uint256_mulmod(a: uint256, b: uint256, c: uint256) -> uint256

    Return the modulo from ``(a * b) % c``. Reverts if ``c == 0``. As this built-in function is intended to provides access to the underlying ``MULMOD`` opcode, all intermediate calculations of this operation are not subject to the ``2 ** 256`` modulo according to the EVM specifications.

    .. code-block:: python

        @external
        @view
        def foo(a: uint256, b: uint256, c: uint256) -> uint256:
            return uint256_mulmod(a, b, c)

    .. code-block:: python

        >>> (11 * 2) % 5
        2
        >>> ExampleContract.foo(11, 2, 5)
        2

.. py:function:: unsafe_add(x: integer, y: integer) -> integer

    Add ``x`` and ``y``, without checking for overflow. ``x`` and ``y`` must both be integers of the same type. If the result exceeds the bounds of the input type, it will be wrapped.

    .. code-block:: python

        @external
        @view
        def foo(x: uint8, y: uint8) -> uint8:
            return unsafe_add(x, y)

        @external
        @view
        def bar(x: int8, y: int8) -> int8:
            return unsafe_add(x, y)


    .. code-block:: python

        >>> ExampleContract.foo(1, 1)
        2

        >>> ExampleContract.foo(255, 255)
        254

        >>> ExampleContract.bar(127, 127)
        -2

.. note::
    Performance note: for the native word types of the EVM ``uint256`` and ``int256``, this will compile to a single ``ADD`` instruction, since the EVM natively wraps addition on 256-bit words.

.. py:function:: unsafe_sub(x: integer, y: integer) -> integer

    Subtract ``x`` and ``y``, without checking for overflow. ``x`` and ``y`` must both be integers of the same type. If the result underflows the bounds of the input type, it will be wrapped.

    .. code-block:: python

        @external
        @view
        def foo(x: uint8, y: uint8) -> uint8:
            return unsafe_sub(x, y)

        @external
        @view
        def bar(x: int8, y: int8) -> int8:
            return unsafe_sub(x, y)


    .. code-block:: python

        >>> ExampleContract.foo(4, 3)
        1

        >>> ExampleContract.foo(0, 1)
        255

        >>> ExampleContract.bar(-128, 1)
        127

.. note::
    Performance note: for the native word types of the EVM ``uint256`` and ``int256``, this will compile to a single ``SUB`` instruction, since the EVM natively wraps subtraction on 256-bit words.


.. py:function:: unsafe_mul(x: integer, y: integer) -> integer

    Multiply ``x`` and ``y``, without checking for overflow. ``x`` and ``y`` must both be integers of the same type. If the result exceeds the bounds of the input type, it will be wrapped.

    .. code-block:: python

        @external
        @view
        def foo(x: uint8, y: uint8) -> uint8:
            return unsafe_mul(x, y)

        @external
        @view
        def bar(x: int8, y: int8) -> int8:
            return unsafe_mul(x, y)


    .. code-block:: python

        >>> ExampleContract.foo(1, 1)
        1

        >>> ExampleContract.foo(255, 255)
        1

        >>> ExampleContract.bar(-128, -128)
        0

        >>> ExampleContract.bar(127, -128)
        -128

.. note::
    Performance note: for the native word types of the EVM ``uint256`` and ``int256``, this will compile to a single ``MUL`` instruction, since the EVM natively wraps multiplication on 256-bit words.


.. py:function:: unsafe_div(x: integer, y: integer) -> integer

    Divide ``x`` and ``y``, without checking for division-by-zero. ``x`` and ``y`` must both be integers of the same type. If the denominator is zero, the result will (following EVM semantics) be zero.

    .. code-block:: python

        @external
        @view
        def foo(x: uint8, y: uint8) -> uint8:
            return unsafe_div(x, y)

        @external
        @view
        def bar(x: int8, y: int8) -> int8:
            return unsafe_div(x, y)


    .. code-block:: python

        >>> ExampleContract.foo(1, 1)
        1

        >>> ExampleContract.foo(1, 0)
        0

        >>> ExampleContract.bar(-128, -1)
        -128

.. note::
    Performance note: this will compile to a single ``SDIV`` or ``DIV`` instruction, depending on if the inputs are signed or unsigned (respectively).


Utilities
=========

.. py:function:: as_wei_value(_value, unit: str) -> uint256

    Take an amount of ether currency specified by a number and a unit and return the integer quantity of wei equivalent to that amount.

    * ``_value``: Value for the ether unit. Any numeric type may be used, however the value cannot be negative.
    * ``unit``: Ether unit name (e.g. ``"wei"``, ``"ether"``, ``"gwei"``, etc.) indicating the denomination of ``_value``. Must be given as a literal string.

    .. code-block:: python

        @external
        @view
        def foo(s: String[32]) -> uint256:
            return as_wei_value(1.337, "ether")

    .. code-block:: python

        >>> ExampleContract.foo(1)
        1337000000000000000

.. py:function:: blockhash(block_num: uint256) -> bytes32

    Return the hash of the block at the specified height.

    .. note::

        The EVM only provides access to the most recent 256 blocks. This function reverts if the block number is greater than or equal to the current block number or more than 256 blocks behind the current block.

    .. code-block:: python

        @external
        @view
        def foo() -> bytes32:
            return blockhash(block.number - 16)

    .. code-block:: python

        >>> ExampleContract.foo()
        0xf3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855

.. py:function:: empty(typename) -> Any

    Return a value which is the default (zero-ed) value of its type. Useful for initializing new memory variables.

    * ``typename``: Name of the type, except ``HashMap[_KeyType, _ValueType]``

    .. code-block:: python

        @external
        @view
        def foo():
            x: uint256[2][5] = empty(uint256[2][5])

.. py:function:: len(b: Union[Bytes, String, DynArray[_Type, _Integer]]) -> uint256

    Return the length of a given ``Bytes``, ``String`` or ``DynArray[_Type, _Integer]``.

    .. code-block:: python

        @external
        @view
        def foo(s: String[32]) -> uint256:
            return len(s)

    .. code-block:: python

        >>> ExampleContract.foo("hello")
        5

.. py:function:: method_id(method, output_type: type = Bytes[4]) -> Union[Bytes[4], bytes4]

    Takes a function declaration and returns its method_id (used in data field to call it).

    * ``method``: Method declaration as given as a literal string
    * ``output_type``: The type of output (``Bytes[4]`` or ``bytes4``). Defaults to ``Bytes[4]``.

    Returns a value of the type specified by ``output_type``.

    .. code-block:: python

        @external
        @view
        def foo() -> Bytes[4]:
            return method_id('transfer(address,uint256)', output_type=Bytes[4])

    .. code-block:: python

        >>> ExampleContract.foo()
	0xa9059cbb

.. py:function:: _abi_encode(*args, ensure_tuple: bool = True) -> Bytes[<depends on input>]

    Takes a variable number of args as input, and returns the ABIv2-encoded bytestring. Used for packing arguments to raw_call, EIP712 and other cases where a consistent and efficient serialization method is needed.
    Once this function has seen more use we provisionally plan to put it into the ``ethereum.abi`` namespace.

    * ``*args``: Arbitrary arguments
    * ``ensure_tuple``: If set to True, ensures that even a single argument is encoded as a tuple. In other words, ``bytes`` gets encoded as ``(bytes,)``, and ``(bytes,)`` gets encoded as ``((bytes,),)`` This is the calling convention for Vyper and Solidity functions. Except for very specific use cases, this should be set to True. Must be a literal.
    * ``method_id``: A literal hex or Bytes[4] value to append to the beginning of the abi-encoded bytestring.

    Returns a bytestring whose max length is determined by the arguments. For example, encoding a ``Bytes[32]`` results in a ``Bytes[64]`` (first word is the length of the bytestring variable).

    .. code-block:: python

        @external
        @view
        def foo() -> Bytes[132]:
            x: uint256 = 1
            y: Bytes[32] = b"234"
            return _abi_encode(x, y, method_id=method_id("foo()"))

    .. code-block:: python

        >>> ExampleContract.foo().hex()
        "c2985578"
        "0000000000000000000000000000000000000000000000000000000000000001"
        "0000000000000000000000000000000000000000000000000000000000000040"
        "0000000000000000000000000000000000000000000000000000000000000003"
        "3233340000000000000000000000000000000000000000000000000000000000"


.. py:function:: _abi_decode(b: Bytes, output_type: type_, unwrap_tuple: bool = True) -> Any

    Takes a byte array as input, and returns the decoded values according to the specified output types. Used for unpacking ABIv2-encoded values.
    Once this function has seen more use we provisionally plan to put it into the ``ethereum.abi`` namespace.

    * ``b``: A byte array of a length that is between the minimum and maximum ABIv2 size bounds of the ``output type``.
    * ``output_type``: Name of the output type, or tuple of output types, to be decoded.
    * ``unwrap_tuple``: If set to True, the input is decoded as a tuple even if only one output type is specified. In other words, ``_abi_decode(b, Bytes[32])`` gets decoded as ``(Bytes[32],)``. This is the convention for ABIv2-encoded values generated by Vyper and Solidity functions. Except for very specific use cases, this should be set to True. Must be a literal.

    Returns the decoded value(s), with type as specified by `output_type`.

    .. code-block:: python

        @external
        @view
        def foo(someInput: Bytes[128]) -> (uint256, Bytes[32]):
            x: uint256 = empty(uint256)
            y: Bytes[32] = empty(Bytes[32])
            x, y =  _abi_decode(someInput, (uint256, Bytes[32]))
            return x, y


.. py:function:: print(*args, hardhat_compat=False) -> None

    "prints" the arguments by issuing a static call to the "console" address, ``0x000000000000000000636F6E736F6C652E6C6F67``. This is supported by some smart contract development frameworks.

    The default mode works natively with titanoboa. For hardhat-style frameworks, use ``hardhat_compat=True)``.

.. note::

    Issuing of the static call is *NOT* mode-dependent (that is, it is not removed from production code), although the compiler will issue a warning whenever ``print`` is used.
.. _compiler-exceptions:

Compiler Exceptions
###################

.. _exceptions-common:

Vyper raises one or more of the following exceptions when an issue is encountered while compiling a contract.

Whenever possible, exceptions include a source highlight displaying the location
of the error within the code:

.. code-block:: python

    vyper.exceptions.VariableDeclarationException: line 79:17 Persistent variable undeclared: highstBid
         78     # If bid is less than highest bid, bid fails
    ---> 79     if (value <= self.highstBid):
    -------------------------^
         80         return False

.. py:exception:: ArgumentException

    Raises when calling a function with invalid arguments, for example an incorrect number of positional arguments or an invalid keyword argument.

.. py:exception:: CallViolation

    Raises on an illegal function call, such as attempting to call between two external functions.

.. py:exception:: ArrayIndexException

    Raises when an array index is out of bounds.

.. py:exception:: EventDeclarationException

    Raises when an event declaration is invalid.

.. py:exception:: EvmVersionException

    Raises when a contract contains an action that cannot be performed with the active EVM ruleset.

.. py:exception:: FunctionDeclarationException

    Raises when a function declaration is invalid, for example because of incorrect or mismatched return values.

.. py:exception:: ImmutableViolation

    Raises when attempting to perform a change a variable, constant or definition that cannot be changed. For example, trying to update a constant, or trying to assign to a function definition.

.. py:exception:: InterfaceViolation

    Raises when an interface is not fully implemented.

.. py:exception:: InvalidAttribute

    Raises on a reference to an attribute that does not exist.

.. py:exception:: InvalidLiteral

    Raises when no valid type can be found for a literal value.

    .. code-block:: python

        @external
        def foo():
            bar: decimal = 3.123456789123456789

    This example raises ``InvalidLiteral`` because the given literal value has too many decimal places and so cannot be assigned any valid Vyper type.

.. py:exception:: InvalidOperation

    Raises when using an invalid operator for a given type.

    .. code-block:: python

        @external
        def foo():
            a: String[10] = "hello" * 2

    This example raises ``InvalidOperation`` because multiplication is not possible on string types.

.. py:exception:: InvalidReference

    Raises on an invalid reference to an existing definition.

    .. code-block:: python

        baz: int128

        @external
        def foo():
            bar: int128 = baz

    This example raises ``InvalidReference`` because ``baz`` is a storage variable. The reference to it should be written as ``self.baz``.

.. py:exception:: InvalidType

    Raises when using an invalid literal value for the given type.

    .. code-block:: python

        @external
        def foo():
            bar: int128 = 3.5

    This example raises ``InvalidType`` because ``3.5`` is a valid literal value, but cannot be cast as ``int128``.

.. py:exception:: IteratorException

   Raises when an iterator is constructed or used incorrectly.

.. py:exception:: JSONError

    Raises when the compiler JSON input is malformed.

.. py:exception:: NamespaceCollision

    Raises when attempting to assign a variable to a name that is already in use.

.. py:exception:: NatSpecSyntaxException

    Raises when a contract contains an invalid :ref:`NatSpec<natspec>` docstring.

    .. code-block:: python

        vyper.exceptions.SyntaxException: line 14:5 No description given for tag '@param'
             13     @dev the feet are sticky like rice
        ---> 14     @param
        -------------^
             15     @return always True

.. py:exception:: NonPayableViolation

    Raises when attempting to access ``msg.value`` from within a function that has not been marked as ``@payable``.

    .. code-block:: python

        @public
        def _foo():
            bar: uint256 = msg.value

.. py:exception:: OverflowException

    Raises when a numeric value is out of bounds for the given type.

.. py:exception:: StateAccessViolation

    Raises when attempting to perform a modifying action within view-only or stateless context. For example, writing to storage in a ``@view`` function, reading from storage in a ``@pure`` function.

.. py:exception:: StructureException

    Raises on syntax that is parsable, but invalid in some way.

    .. code-block:: python

        vyper.exceptions.StructureException: line 181:0 Invalid top-level statement
             180
        ---> 181 '''
        ---------^
             182

.. py:exception:: SyntaxException

    Raises on invalid syntax that cannot be parsed.

    .. code-block:: python

        vyper.exceptions.SyntaxException: line 4:20 invalid syntax
                3 struct Bid:
        ---> 4   blindedBid bytes32
        ---------------------------^
                5   deposit: uint256

.. py:exception:: TypeMismatch

    Raises when attempting to perform an action between two or more objects with known, dislike types.

    .. code-block:: python

        @external
        def foo(:
            bar: int128 = 3
            foo: decimal = 4.2

            if foo + bar > 4:
                pass

    ``foo`` has a type of ``int128`` and ``bar`` has a type of ``decimal``, so attempting to add them together  raises a ``TypeMismatch``.

.. py:exception:: UndeclaredDefinition

    Raises when attempting to access an object that has not been declared.

.. py:exception:: VariableDeclarationException

    Raises on an invalid variable declaration.

    .. code-block:: bash

        vyper.exceptions.VariableDeclarationException: line 79:17 Persistent variable undeclared: highstBid
             78     # If bid is less than highest bid, bid fails
        ---> 79     if (value <= self.highstBid):
        -------------------------^
             80         return False

.. py:exception:: VersionException

    Raises when a contract version string is malformed or incompatible with the current compiler version.

.. py:exception:: ZeroDivisionException

    Raises when a divide by zero or modulo zero situation arises.

CompilerPanic
=============

.. py:exception:: CompilerPanic

    ::

        $ vyper v.vy
        Error compiling: v.vy
        vyper.exceptions.CompilerPanic: Number of times repeated
        must be a constant nonzero positive integer: 0 Please create an issue.

    A compiler panic error indicates that there is a problem internally to the compiler and an issue should be reported right
    away on the Vyper Github page.  Open an issue if you are experiencing this error. Please `Open an Issue <https://github.com/vyperlang/vyper/issues>`_
Compiling a Contract
********************

Command-Line Compiler Tools
===========================

Vyper includes the following command-line scripts for compiling contracts:

* ``vyper``: Compiles vyper contract files into ``IR`` or bytecode
* ``vyper-json``: Provides a JSON interface to the compiler

.. note::

    The ``--help`` flag gives verbose explanations of how to use each of these scripts.

vyper
-----

``vyper`` provides command-line access to the compiler. It can generate various outputs including simple binaries, ASTs, interfaces and source mappings.

To compile a contract:

::

    $ vyper yourFileName.vy


Include the ``-f`` flag to specify which output formats to return. Use ``vyper --help`` for a full list of output options.

::

    $ vyper -f abi,bytecode,bytecode_runtime,ir,asm,source_map,method_identifiers yourFileName.vy

The ``-p`` flag allows you to set a root path that is used when searching for interface files to import.  If none is given, it will default to the current working directory. See :ref:`searching_for_imports` for more information.

::

    $ vyper -p yourProject yourProject/yourFileName.vy


.. _compiler-storage-layout:

Storage Layout
~~~~~~~~~~~~~~

To display the default storage layout for a contract:

::

    $ vyper -f layout yourFileName.vy

This outputs a JSON object detailing the locations for all state variables as determined by the compiler.

To override the default storage layout for a contract:

::

    $ vyper --storage-layout-file storageLayout.json yourFileName.vy

The input to the ``--storage-layout-file`` flag must match the format of the ``.storage_layout`` field from the ``vyper -f layout`` command.


.. _vyper-json:

vyper-json
----------

``vyper-json`` provides a JSON interface for the compiler. It expects a :ref:`JSON formatted input<vyper-json-input>` and returns the compilation result in a :ref:`JSON formatted output<vyper-json-output>`.

To compile from JSON supplied via ``stdin``:

::

    $ vyper-json

To compile from a JSON file:

::

    $ vyper-json yourProject.json

By default, the output is sent to ``stdout``. To redirect to a file, use the ``-o`` flag:

::

    $ vyper-json -o compiled.json

Importing Interfaces
~~~~~~~~~~~~~~~~~~~~

``vyper-json`` searches for imported interfaces in the following sequence:

1. Interfaces defined in the ``interfaces`` field of the input JSON.
2. Derived interfaces generated from contracts in the ``sources`` field of the input JSON.
3. (Optional) The local filesystem, if a root path was explicitly declared via the ``-p`` flag.

See :ref:`searching_for_imports` for more information on Vyper's import system.

Online Compilers
================

Try VyperLang!
-----------------

`Try VyperLang! <https://try.vyperlang.org>`_ is a JupterHub instance hosted by the Vyper team as a sandbox for developing and testing contracts in Vyper. It requires github for login, and supports deployment via the browser.

Remix IDE
---------

`Remix IDE <https://remix.ethereum.org>`_ is a compiler and JavaScript VM for developing and testing contracts in Vyper, as well as Solidity.

.. note::

   While the Vyper version of the Remix IDE compiler is updated on a regular basis, it might be a bit behind the latest version found in the master branch of the repository. Make sure the byte code matches the output from your local compiler.

.. _optimization-mode:

Compiler Optimization Modes
===========================

The vyper CLI tool accepts an optimization mode ``"none"``, ``"codesize"``, or ``"gas"`` (default). It can be set using the ``--optimize`` flag. For example, invoking ``vyper --optimize codesize MyContract.vy`` will compile the contract, optimizing for code size. As a rough summary of the differences between gas and codesize mode, in gas optimized mode, the compiler will try to generate bytecode which minimizes gas (up to a point), including:

* using a sparse selector table which optimizes for gas over codesize
* inlining some constants, and
* trying to unroll some loops, especially for data copies.

In codesize optimized mode, the compiler will try hard to minimize codesize by

* using a dense selector table
* out-lining code, and
* using more loops for data copies.


.. _evm-version:

Setting the Target EVM Version
==============================

When you compile your contract code, you can specify the target Ethereum Virtual Machine version to compile for, to access or avoid particular features. You can specify the version either with a source code pragma or as a compiler option. It is recommended to use the compiler option when you want flexibility (for instance, ease of deploying across different chains), and the source code pragma when you want bytecode reproducibility (for instance, when verifying code on a block explorer).

.. note::
   If the evm version specified by the compiler options conflicts with the source code pragma, an exception will be raised and compilation will not continue.

For instance, the adding the following pragma to a contract indicates that it should be compiled for the "shanghai" fork of the EVM.

.. code-block:: python

   #pragma evm-version shanghai

.. warning::

    Compiling for the wrong EVM version can result in wrong, strange, or failing behavior. Please ensure, especially if running a private chain, that you use matching EVM versions.

When compiling via the ``vyper`` CLI, you can specify the EVM version option using the ``--evm-version`` flag:

::

    $ vyper --evm-version [VERSION]

When using the JSON interface, you can include the ``"evmVersion"`` key within the ``"settings"`` field:

.. code-block:: javascript

    {
        "settings": {
            "evmVersion": "[VERSION]"
        }
    }

Target Options
--------------

The following is a list of supported EVM versions, and changes in the compiler introduced with each version. Backward compatibility is not guaranteed between each version.


.. py:attribute:: istanbul

   - The ``CHAINID`` opcode is accessible via ``chain.id``
   - The ``SELFBALANCE`` opcode is used for calls to ``self.balance``
   - Gas estimates changed for ``SLOAD`` and ``BALANCE``

.. py:attribute:: berlin

   - Gas estimates changed for ``EXTCODESIZE``, ``EXTCODECOPY``, ``EXTCODEHASH``, ``SLOAD``, ``SSTORE``, ``CALL``, ``CALLCODE``, ``DELEGATECALL`` and ``STATICCALL``
   - Functions marked with ``@nonreentrant`` are protected with different values (3 and 2) than contracts targeting pre-berlin.
   - ``BASEFEE`` is accessible via ``block.basefee``

.. py:attribute:: paris

   - ``block.difficulty`` is deprecated in favor of its new alias, ``block.prevrandao``.

.. py:attribute:: shanghai (default)

   - The ``PUSH0`` opcode is automatically generated by the compiler instead of ``PUSH1 0``

.. py:attribute:: cancun (experimental)

   - The ``transient`` keyword allows declaration of variables which live in transient storage
   - Functions marked with ``@nonreentrant`` are protected with TLOAD/TSTORE instead of SLOAD/SSTORE
   - The ``MCOPY`` opcode will be generated automatically by the compiler for most memory operations.




Compiler Input and Output JSON Description
==========================================

Especially when dealing with complex or automated setups, the recommended way to compile is to use :ref:`vyper-json` and the JSON-input-output interface.

Where possible, the Vyper JSON compiler formats follow those of `Solidity <https://solidity.readthedocs.io/en/latest/using-the-compiler.html#compiler-input-and-output-json-description>`_.

.. _vyper-json-input:

Input JSON Description
----------------------

The following example describes the expected input format of ``vyper-json``. Comments are of course not permitted and used here *only for explanatory purposes*.

.. code-block:: javascript

    {
        // Required: Source code language. Must be set to "Vyper".
        "language": "Vyper",
        // Required
        // Source codes given here will be compiled.
        "sources": {
            "contracts/foo.vy": {
                // Optional: keccak256 hash of the source file
                "keccak256": "0x234...",
                // Required: literal contents of the source file
                "content": "@external\ndef foo() -> bool:\n    return True"
            }
        },
        // Optional
        // Interfaces given here are made available for import by the sources
        // that are compiled. If the suffix is ".vy", the compiler will expect
        // a contract-as-interface using proper Vyper syntax. If the suffix is
        // "abi" the compiler will expect an ABI object.
        "interfaces": {
            "contracts/bar.vy": {
                "content": ""
            },
            "contracts/baz.json": {
                "abi": []
            }
        },
        // Optional
        "settings": {
            "evmVersion": "shanghai",  // EVM version to compile for. Can be istanbul, berlin, paris, shanghai (default) or cancun (experimental!).
            // optional, optimization mode
            // defaults to "gas". can be one of "gas", "codesize", "none",
            // false  and true (the last two are for backwards compatibility).
            "optimize": "gas",
            // optional, whether or not the bytecode should include Vyper's signature
            // defaults to true
            "bytecodeMetadata": true,
            // The following is used to select desired outputs based on file names.
            // File names are given as keys, a star as a file name matches all files.
            // Outputs can also follow the Solidity format where second level keys
            // denoting contract names - all 2nd level outputs are applied to the file.
            //
            // To select all possible compiler outputs: "outputSelection: { '*': ["*"] }"
            // Note that this might slow down the compilation process needlessly.
            //
            // The available output types are as follows:
            //
            //    abi - The contract ABI
            //    ast - Abstract syntax tree
            //    interface - Derived interface of the contract, in proper Vyper syntax
            //    ir - intermediate representation of the code
            //    userdoc - Natspec user documentation
            //    devdoc - Natspec developer documentation
            //    evm.bytecode.object - Bytecode object
            //    evm.bytecode.opcodes - Opcodes list
            //    evm.deployedBytecode.object - Deployed bytecode object
            //    evm.deployedBytecode.opcodes - Deployed opcodes list
            //    evm.deployedBytecode.sourceMap - Deployed source mapping (useful for debugging)
            //    evm.methodIdentifiers - The list of function hashes
            //
            // Using `evm`, `evm.bytecode`, etc. will select every target part of that output.
            // Additionally, `*` can be used as a wildcard to request everything.
            //
            "outputSelection": {
                "*": ["evm.bytecode", "abi"],  // Enable the abi and bytecode outputs for every single contract
                "contracts/foo.vy": ["ast"]  // Enable the ast output for contracts/foo.vy
            }
        }
    }

.. _vyper-json-output:

Output JSON Description
-----------------------

The following example describes the output format of ``vyper-json``. Comments are of course not permitted and used here *only for explanatory purposes*.

.. code-block:: javascript

    {
        // The compiler version used to generate the JSON
        "compiler": "vyper-0.1.0b12",
        // Optional: not present if no errors/warnings were encountered
        "errors": [
            {
            // Optional: Location within the source file.
            "sourceLocation": {
                "file": "source_file.vy",
                "lineno": 5,
                "col_offset": 11
            },
            // Mandatory: Exception type, such as "JSONError", "StructureException", etc.
            "type": "TypeMismatch",
            // Mandatory: Component where the error originated, such as "json", "compiler", "vyper", etc.
            "component": "compiler",
            // Mandatory ("error" or "warning")
            "severity": "error",
            // Mandatory
            "message": "Unsupported type conversion: int128 to bool"
            // Optional: the message formatted with source location
            "formattedMessage": "line 5:11 Unsupported type conversion: int128 to bool"
            }
        ],
        // This contains the file-level outputs. Can be limited/filtered by the outputSelection settings.
        "sources": {
            "source_file.vy": {
                // Identifier of the source (used in source maps)
                "id": 0,
                // The AST object
                "ast": {},
            }
        },
        // This contains the contract-level outputs. Can be limited/filtered by the outputSelection settings.
        "contracts": {
            "source_file.vy": {
                // The contract name will always be the file name without a suffix
                "source_file": {
                    // The Ethereum Contract ABI.
                    // See https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI
                    "abi": [],
                    // Natspec developer documentation
                    "devdoc": {},
                    // Intermediate representation (string)
                    "ir": "",
                    // Natspec developer documentation
                    "userdoc": {},
                    // EVM-related outputs
                    "evm": {
                        "bytecode": {
                            // The bytecode as a hex string.
                            "object": "00fe",
                            // Opcodes list (string)
                            "opcodes": ""
                        },
                        "deployedBytecode": {
                            // The deployed bytecode as a hex string.
                            "object": "00fe",
                            // Deployed opcodes list (string)
                            "opcodes": "",
                            // The deployed source mapping as a string.
                            "sourceMap": ""
                        },
                        // The list of function hashes
                        "methodIdentifiers": {
                            "delegate(address)": "5c19a95c"
                        }
                    }
                }
            }
        }
    }

Errors
~~~~~~

Each error includes a ``component`` field, indicating the stage at which it occurred:

* ``json``: Errors that occur while parsing the input JSON. Usually, a result of invalid JSON or a required value that is missing.
* ``parser``: Errors that occur while parsing the contracts. Usually, a result of invalid Vyper syntax.
* ``compiler``: Errors that occur while compiling the contracts.
* ``vyper``: Unexpected errors that occur within Vyper. If you receive an error of this type, please open an issue.

You can also use the ``--traceback`` flag to receive a standard Python traceback when an error is encountered.
Environment Variables and Constants
###################################

.. _types-env-vars:

Environment Variables
=====================

Environment variables always exist in the namespace and are primarily used to provide information about the blockchain or current transaction.

Block and Transaction Properties
--------------------------------

==================== ================ =========================================================
Name                 Type             Value
==================== ================ =========================================================
``block.coinbase``   ``address``      Current block miner's address
``block.difficulty`` ``uint256``      Current block difficulty
``block.prevrandao`` ``uint256``      Current randomness beacon provided by the beacon chain
``block.number``     ``uint256``      Current block number
``block.prevhash``   ``bytes32``      Equivalent to ``blockhash(block.number - 1)``
``block.timestamp``  ``uint256``      Current block epoch timestamp
``chain.id``         ``uint256``      Chain ID
``msg.data``         ``Bytes``        Message data
``msg.gas``          ``uint256``      Remaining gas
``msg.sender``       ``address``      Sender of the message (current call)
``msg.value``        ``uint256``      Number of wei sent with the message
``tx.origin``        ``address``      Sender of the transaction (full call chain)
``tx.gasprice``      ``uint256``      Gas price of current transaction in wei
==================== ================ =========================================================

.. note::

    ``block.prevrandao`` is an alias for ``block.difficulty``. Since ``block.difficulty`` is considered deprecated according to `EIP-4399 <https://eips.ethereum.org/EIPS/eip-4399>`_ after "The Merge" (Paris hard fork), we recommend using ``block.prevrandao``.

.. note::

    ``msg.data`` requires the usage of :func:`slice <slice>` to explicitly extract a section of calldata. If the extracted section exceeds the bounds of calldata, this will throw. You can check the size of ``msg.data`` using :func:`len <len>`.

.. _constants-self:

The self Variable
-----------------

``self`` is an environment variable used to reference a contract from within itself. Along with the normal :ref:`address<address>` members, ``self`` allows you to read and write to state variables and to call private functions within the contract.

==================== ================ ==========================
Name                 Type             Value
==================== ================ ==========================
``self``             ``address``      Current contract's address
``self.balance``     ``uint256``      Current contract's balance
==================== ================ ==========================

Accessing State Variables
~~~~~~~~~~~~~~~~~~~~~~~~~

``self`` is used to access a contract's :ref:`state variables<structure-state-variables>`, as shown in the following example:

.. code-block:: python

    state_var: uint256

    @external
    def set_var(value: uint256) -> bool:
        self.state_var = value
        return True

    @external
    @view
    def get_var() -> uint256:
        return self.state_var


Calling Internal Functions
~~~~~~~~~~~~~~~~~~~~~~~~~~

``self`` is also used to call :ref:`internal functions<structure-functions-internal>` within a contract:

.. code-block:: python

    @internal
    def _times_two(amount: uint256) -> uint256:
        return amount * 2

    @external
    def calculate(amount: uint256) -> uint256:
        return self._times_two(amount)

.. _types-constants:

Custom Constants
================

Custom constants can be defined at a global level in Vyper. To define a constant, make use of the ``constant`` keyword.

.. code-block:: python

    TOTAL_SUPPLY: constant(uint256) = 10000000
    total_supply: public(uint256)

    @external
    def __init__():
        self.total_supply = TOTAL_SUPPLY
.. _contributing:

Contributing
############

Help is always appreciated!

To get started, you can try `installing Vyper <https://vyper.readthedocs.io/en/latest/installing-vyper.html>`_ in order to familiarize
yourself with the components of Vyper and the build process. Also, it may be
useful to become well-versed at writing smart-contracts in Vyper.

Types of Contributions
======================

In particular, we need help in the following areas:

* Improving the documentation
* Responding to questions from other users on `StackExchange
  <https://ethereum.stackexchange.com>`_ and `Discussions <https://github.com/vyperlang/vyper/discussions>`_
* Add to the discussions on the `Vyper (Smart Contract Programming Language) Discord <https://discord.gg/6tw7PTM7C2>`_
* Suggesting Improvements
* Fixing and responding to `Vyper's GitHub issues <https://github.com/vyperlang/vyper/issues>`_

How to Suggest Improvements
===========================

To suggest an improvement, please create a Vyper Improvement Proposal (VIP for short)
using the `VIP Template <https://github.com/vyperlang/vyper/blob/master/.github/ISSUE_TEMPLATE/vip.md>`_.

How to Report Issues
====================

To report an issue, please use the
`GitHub issues tracker <https://github.com/vyperlang/vyper/issues>`_. When
reporting issues, please mention the following details:

* Which version of Vyper you are using
* What was the source code (if applicable)
* Which platform are you running on
* Your operating system name and version
* Detailed steps to reproduce the issue
* What was the result of the issue
* What the expected behaviour is

Reducing the source code that caused the issue to a bare minimum is always
very helpful and sometimes even clarifies a misunderstanding.

Fix Bugs
========

Find or report bugs at our `issues page <https://github.com/vyperlang/vyper/issues>`_. Anything tagged with "bug" is open to whoever wants to implement it.

Style Guide
===========

Our :ref:`style guide<style-guide>` outlines best practices for the Vyper repository. Please ask us on the `Vyper (Smart Contract Programming Language) Discord <https://discord.gg/6tw7PTM7C2>`_ ``#compiler-dev`` channel if you have questions about anything that is not outlined in the style guide.

Workflow for Pull Requests
==========================

In order to contribute, please fork off of the ``master`` branch and make your
changes there. Your commit messages should detail *why* you made your change
in addition to *what* you did (unless it is a tiny change).

If you need to pull in any changes from ``master`` after making your fork (for
example, to resolve potential merge conflicts), please avoid using ``git merge``
and instead, ``git rebase`` your branch.

Implementing New Features
-------------------------

If you are writing a new feature, please ensure you write appropriate Pytest test cases and place them under ``tests/``.

If you are making a larger change, please consult first with the `Vyper (Smart Contract Programming Language) Discord <https://discord.gg/6tw7PTM7C2>`_ ``#compiler-dev`` channel.

Although we do CI testing, please make sure that the tests pass for supported Python version and ensure that it builds locally before submitting a pull request.

Thank you for your help!
.. _control-structures:

Control Structures
##################

.. _control-structures-functions:

Functions
=========

Functions are executable units of code within a contract. Functions may only be declared within a contract's :ref:`module scope <scoping-module>`.

.. code-block:: python

    @external
    def bid():
        ...

Functions may be called internally or externally depending on their :ref:`visibility <function-visibility>`. Functions may accept input arguments and return variables in order to pass values between them.

.. _function-visibility:

Visibility
----------

All functions must include exactly one visibility decorator.

External Functions
******************

External functions (marked with the ``@external`` decorator) are a part of the contract interface and may only be called via transactions or from other contracts.

.. code-block:: python

    @external
    def add_seven(a: int128) -> int128:
        return a + 7

    @external
    def add_seven_with_overloading(a: uint256, b: uint256 = 3):
        return a + b

A Vyper contract cannot call directly between two external functions. If you must do this, you can use an :ref:`interface <interfaces>`.

.. note::
    For external functions with default arguments like ``def my_function(x: uint256, b: uint256 = 1)`` the Vyper compiler will generate ``N+1`` overloaded function selectors based on ``N`` default arguments.

.. _structure-functions-internal:

Internal Functions
******************

Internal functions (marked with the ``@internal`` decorator) are only accessible from other functions within the same contract. They are called via the :ref:`self<constants-self>` object:

.. code-block:: python

    @internal
    def _times_two(amount: uint256, two: uint256 = 2) -> uint256:
        return amount * two

    @external
    def calculate(amount: uint256) -> uint256:
        return self._times_two(amount)

.. note::
    Since calling an ``internal`` function is realized by jumping to its entry label, the internal function dispatcher ensures the correctness of the jumps. Please note that for ``internal`` functions which use more than one default parameter, Vyper versions ``>=0.3.8`` are strongly recommended due to the security advisory `GHSA-ph9x-4vc9-m39g <https://github.com/vyperlang/vyper/security/advisories/GHSA-ph9x-4vc9-m39g>`_.

Mutability
----------

.. _function-mutability:

You can optionally declare a function's mutability by using a :ref:`decorator <function-decorators>`. There are four mutability levels:

    * **Pure**: does not read from the contract state or any environment variables.
    * **View**: may read from the contract state, but does not alter it.
    * **Nonpayable**: may read from and write to the contract state, but cannot receive Ether.
    * **Payable**: may read from and write to the contract state, and can receive Ether.

.. code-block:: python

    @view
    @external
    def readonly():
        # this function cannot write to state
        ...

    @payable
    @external
    def send_me_money():
        # this function can receive ether
        ...

Functions default to ``nonpayable`` when no mutability decorator is used.

Functions marked with ``@view`` cannot call mutable (``payable`` or ``nonpayable``) functions. Any external calls are made using the special ``STATICCALL`` opcode, which prevents state changes at the EVM level.

Functions marked with ``@pure`` cannot call non-``pure`` functions.

Re-entrancy Locks
-----------------

The ``@nonreentrant(<key>)`` decorator places a lock on a function, and all functions with the same ``<key>`` value. An attempt by an external contract to call back into any of these functions causes the transaction to revert.

.. code-block:: python

    @external
    @nonreentrant("lock")
    def make_a_call(_addr: address):
        # this function is protected from re-entrancy
        ...

You can put the ``@nonreentrant(<key>)`` decorator on a ``__default__`` function but we recommend against it because in most circumstances it will not work in a meaningful way.

Nonreentrancy locks work by setting a specially allocated storage slot to a ``<locked>`` value on function entrance, and setting it to an ``<unlocked>`` value on function exit. On function entrance, if the storage slot is detected to be the ``<locked>`` value, execution reverts.

You cannot put the ``@nonreentrant`` decorator on a ``pure`` function. You can put it on a ``view`` function, but it only checks that the function is not in a callback (the storage slot is not in the ``<locked>`` state), as ``view`` functions can only read the state, not change it.

.. note::
    A mutable function can protect a ``view`` function from being called back into (which is useful for instance, if a ``view`` function would return inconsistent state during a mutable function), but a ``view`` function cannot protect itself from being called back into. Note that mutable functions can never be called from a ``view`` function because all external calls out from a ``view`` function are protected by the use of the ``STATICCALL`` opcode.

.. note::

    A nonreentrant lock has an ``<unlocked>`` value of 3, and a ``<locked>`` value of 2. Nonzero values are used to take advantage of net gas metering - as of the Berlin hard fork, the net cost for utilizing a nonreentrant lock is 2300 gas. Prior to v0.3.4, the ``<unlocked>`` and ``<locked>`` values were 0 and 1, respectively.


The ``__default__`` Function
--------------------------

A contract can also have a default function, which is executed on a call to the contract if no other functions match the given function identifier (or if none was supplied at all, such as through someone sending it Eth). It is the same construct as fallback functions `in Solidity <https://solidity.readthedocs.io/en/latest/contracts.html?highlight=fallback#fallback-function>`_.

This function is always named ``__default__``. It must be annotated with ``@external``. It cannot expect any input arguments.

If the function is annotated as ``@payable``, this function is executed whenever the contract is sent Ether (without data). This is why the default function cannot accept arguments - it is a design decision of Ethereum to make no differentiation between sending ether to a contract or a user address.

.. code-block:: python

    event Payment:
        amount: uint256
        sender: indexed(address)

    @external
    @payable
    def __default__():
        log Payment(msg.value, msg.sender)

Considerations
**************

Just as in Solidity, Vyper generates a default function if one isn't found, in the form of a ``REVERT`` call. Note that this still `generates an exception <https://github.com/ethereum/wiki/wiki/Subtleties>`_ and thus will not succeed in receiving funds.

Ethereum specifies that the operations will be rolled back if the contract runs out of gas in execution. ``send`` calls to the contract come with a free stipend of 2300 gas, which does not leave much room to perform other operations except basic logging. **However**, if the sender includes a higher gas amount through a ``call`` instead of ``send``, then more complex functionality can be run.

It is considered a best practice to ensure your payable default function is compatible with this stipend. The following operations will consume more than 2300 gas:

    * Writing to storage
    * Creating a contract
    * Calling an external function which consumes a large amount of gas
    * Sending Ether

Lastly, although the default function receives no arguments, it can still access the ``msg`` object, including:

    * the address of who is interacting with the contract (``msg.sender``)
    * the amount of ETH sent (``msg.value``)
    * the gas provided (``msg.gas``).

The ``__init__`` Function
-----------------------

``__init__`` is a special initialization function that may only be called at the time of deploying a contract. It can be used to set initial values for storage variables. A common use case is to set an ``owner`` variable with the creator the contract:

.. code-block:: python

    owner: address

    @external
    def __init__():
        self.owner = msg.sender

You cannot call to other contract functions from the initialization function.

.. _function-decorators:

Decorators Reference
--------------------

All functions must include one :ref:`visibility <function-visibility>` decorator (``@external`` or ``@internal``). The remaining decorators are optional.

=============================== ===========================================================
Decorator                       Description
=============================== ===========================================================
``@external``                   Function can only be called externally
``@internal``                   Function can only be called within current contract
``@pure``                       Function does not read contract state or environment variables
``@view``                       Function does not alter contract state
``@payable``                    Function is able to receive Ether
``@nonreentrant(<unique_key>)`` Function cannot be called back into during an external call
=============================== ===========================================================

``if`` statements
=================

The ``if`` statement is a control flow construct used for conditional execution:

.. code-block:: python

    if CONDITION:
        ...

``CONDITION`` is a boolean or boolean operation. The boolean is evaluated left-to-right, one expression at a time, until the condition is found to be true or false.  If true, the logic in the body of the ``if`` statement is executed.

Note that unlike Python, Vyper does not allow implicit conversion from non-boolean types within the condition of an ``if`` statement. ``if 1: pass`` will fail to compile with a type mismatch.

You can also include ``elif`` and ``else`` statements, to add more conditional statements and a body that executes when the conditionals are false:

.. code-block:: python

    if CONDITION:
        ...
    elif OTHER_CONDITION:
        ...
    else:
        ...

``for`` loops
=============

The ``for`` statement is a control flow construct used to iterate over a value:

.. code-block:: python

    for i in <ITERABLE>:
        ...

The iterated value can be a static array, a dynamic array, or generated from the built-in ``range`` function.

Array Iteration
---------------

You can use ``for`` to iterate through the values of any array variable:

.. code-block:: python

    foo: int128[3] = [4, 23, 42]
    for i in foo:
        ...

In the above, example, the loop executes three times with ``i`` assigned the values of ``4``, ``23``, and then ``42``.

You can also iterate over a literal array, as long as a common type can be determined for each item in the array:

.. code-block:: python

    for i in [4, 23, 42]:
        ...

Some restrictions:

* You cannot iterate over a multi-dimensional array.  ``i`` must always be a base type.
* You cannot modify a value in an array while it is being iterated, or call to a function that might modify the array being iterated.

Range Iteration
---------------

Ranges are created using the ``range`` function. The following examples are valid uses of ``range``:

.. code-block:: python

    for i in range(STOP):
        ...

``STOP`` is a literal integer greater than zero. ``i`` begins as zero and increments by one until it is equal to ``STOP``.

.. code-block:: python

    for i in range(stop, bound=N):
        ...

Here, ``stop`` can be a variable with integer type, greater than zero. ``N`` must be a compile-time constant. ``i`` begins as zero and increments by one until it is equal to ``stop``. If ``stop`` is larger than ``N``, execution will revert at runtime. In certain cases, you may not have a guarantee that ``stop`` is less than ``N``, but still want to avoid the possibility of runtime reversion. To accomplish this, use the ``bound=`` keyword in combination with ``min(stop, N)`` as the argument to ``range``, like ``range(min(stop, N), bound=N)``. This is helpful for use cases like chunking up operations on larger arrays across multiple transactions.

Another use of range can be with ``START`` and ``STOP`` bounds.

.. code-block:: python

    for i in range(START, STOP):
        ...

Here, ``START`` and ``STOP`` are literal integers, with ``STOP`` being a greater value than ``START``. ``i`` begins as ``START`` and increments by one until it is equal to ``STOP``.

.. code-block:: python

    for i in range(a, a + N):
        ...

``a`` is a variable with an integer type and ``N`` is a literal integer greater than zero.  ``i`` begins as ``a`` and increments by one until it is equal to ``a + N``. If ``a + N`` would overflow, execution will revert.
.. index:: deploying;deploying;

.. _deploying:

Deploying a Contract
********************

Once you are ready to deploy your contract to a public test net or the main net, you have several options:

* Take the bytecode generated by the vyper compiler and manually deploy it through mist or geth:

.. code-block:: bash

  vyper yourFileName.vy
  # returns bytecode

* Take the byte code and ABI and deploy it with your current browser on `myetherwallet's <https://www.myetherwallet.com/>`_ contract menu:

.. code-block:: bash

  vyper -f abi yourFileName.vy
  # returns ABI

* Use the remote compiler provided by the `Remix IDE <https://remix.ethereum.org>`_ to compile and deploy your contract on your net of choice. Remix also provides a JavaScript VM to test deploy your contract.

.. note::
   While the vyper version of the Remix IDE compiler is updated on a regular basis it might be a bit behind the latest version found in the master branch of the repository. Make sure the byte code matches the output from your local compiler.
.. _event-logging:

Event Logging
#############

Vyper can log events to be caught and displayed by user interfaces.

Example of Logging
==================

This example is taken from the `sample ERC20 contract <https://github.com/vyperlang/vyper/blob/master/examples/tokens/ERC20.vy>`_ and shows the basic flow of event logging:

.. code-block:: python

    # Events of the token.
    event Transfer:
        sender: indexed(address)
        receiver: indexed(address)
        value: uint256

    event Approval:
        owner: indexed(address)
        spender: indexed(address)
        value: uint256

    # Transfer some tokens from message sender to another address
    def transfer(_to : address, _value : uint256) -> bool:

       ... Logic here to do the real work ...

       # All done, log the event for listeners
       log Transfer(msg.sender, _to, _value)

Let's look at what this is doing.

    1. We declare two event types to log. The two events are similar in that they contain two indexed address fields. Indexed fields do not make up part of the event data itself, but can be searched by clients that want to catch the event. Also, each event contains one single data field, in each case called ``value``. Events can contain several arguments with any names desired.
    2. In the ``transfer`` function, after we do whatever work is necessary, we log the event. We pass three arguments, corresponding with the three arguments of the Transfer event declaration.

Clients listening to the events will declare and handle the events they are interested in using a `library such as web3.js <https://solidity.readthedocs.io/en/latest/contracts.html#events>`_:

.. code-block:: javascript

    var abi = /* abi as generated by the compiler */;
    var MyToken = web3.eth.contract(abi);
    var myToken = MyToken.at("0x1234...ab67" /* address */);

    // watch for changes in the callback
    var event = myToken.Transfer(function(error, result) {
        if (!error) {
            var args = result.returnValues;
            console.log('value transferred = ', args._amount);
        }
    });

In this example, the listening client declares the event to listen for. Any time the contract sends this log event, the callback will be invoked.

Declaring Events
================

Let's look at an event declaration in more detail.

.. code-block:: python

    event Transfer:
        sender: indexed(address)
        receiver: indexed(address)
        value: uint256

Event declarations look similar to struct declarations, containing one or more arguments that are passed to the event. Typical events will contain two kinds of arguments:

    * **Indexed** arguments, which can be searched for by listeners. Each indexed argument is identified by the ``indexed`` keyword.  Here, each indexed argument is an address. You can have any number of indexed arguments, but indexed arguments are not passed directly to listeners, although some of this information (such as the sender) may be available in the listener's `results` object.
    * **Value** arguments, which are passed through to listeners. You can have any number of value arguments and they can have arbitrary names, but each is limited by the EVM to be no more than 32 bytes.

It is also possible to create an event with no arguments. In this case, use the ``pass`` statement:

.. code-block:: python

    event Foo: pass

Logging Events
==============

Once an event is declared, you can log (send) events. You can send events as many times as you want to. Please note that events sent do not take state storage and thus do not cost gas: this makes events a good way to save some information. However, the drawback is that events are not available to contracts, only to clients.

Logging events is done using the ``log`` statement:

.. code-block:: python

   log Transfer(msg.sender, _to, _amount)

The order and types of arguments given must match the order of arguments used when declaring the event.

Listening for Events
====================

In the example listener above, the ``result`` arg actually passes a `large amount of information <https://web3js.readthedocs.io/en/v1.2.6/web3-eth-contract.html#contract-events-return>`_. Here we're most interested in ``result.returnValues``. This is an object with properties that match the properties declared in the event. Note that this object does not contain the indexed properties, which can only be searched in the original ``myToken.Transfer`` that created the callback.
.. image:: vyper-logo-transparent.svg
    :width: 140px
    :alt: Vyper logo
    :align: center

Vyper
#####

Vyper is a contract-oriented, pythonic programming language that targets the `Ethereum Virtual Machine (EVM) <https://ethereum.org/learn/#ethereum-basics>`_.

Principles and Goals
====================

* **Security**: It should be possible and natural to build secure smart-contracts in Vyper.
* **Language and compiler simplicity**: The language and the compiler implementation should strive to be simple.
* **Auditability**: Vyper code should be maximally human-readable. Furthermore, it should be maximally difficult to write misleading code. Simplicity for the reader is more important than simplicity for the writer, and simplicity for readers with low prior experience with Vyper (and low prior experience with programming in general) is particularly important.

Because of this Vyper provides the following features:

* **Bounds and overflow checking**: On array accesses and arithmetic.
* **Support for signed integers and decimal fixed point numbers**
* **Decidability**: It is possible to compute a precise upper bound for the gas consumption of any Vyper function call.
* **Strong typing**
* **Small and understandable compiler code**
* **Limited support for pure functions**: Anything marked constant is not allowed to change the state.

Following the principles and goals, Vyper **does not** provide the following features:

* **Modifiers**: For example in Solidity you can define a ``function foo() mod1 { ... }``, where ``mod1`` can be defined elsewhere in the code to include a check that is done before execution, a check that is done after execution, some state changes, or possibly other things. Vyper does not have this, because it makes it too easy to write misleading code. ``mod1`` just looks too innocuous for something that could add arbitrary pre-conditions, post-conditions or state changes. Also, it encourages people to write code where the execution jumps around the file, harming auditability. The usual use case for a modifier is something that performs a single check before execution of a program; our recommendation is to simply inline these checks as asserts.
* **Class inheritance**: Class inheritance requires people to jump between multiple files to understand what a program is doing, and requires people to understand the rules of precedence in case of conflicts ("Which class's function ``X`` is the one that's actually used?"). Hence, it makes code too complicated to understand which negatively impacts auditability.
* **Inline assembly**: Adding inline assembly would make it no longer possible to search for a variable name in order to find all instances where that variable is read or modified.
* **Function overloading**: This can cause lots of confusion on which function is called at any given time. Thus it's easier to write missleading code (``foo("hello")`` logs "hello" but ``foo("hello", "world")`` steals your funds). Another problem with function overloading is that it makes the code much harder to search through as you have to keep track on which call refers to which function.
* **Operator overloading**: Operator overloading makes writing misleading code possible. For example ``+`` could be overloaded so that it executes commands that are not visible at a first glance, such as sending funds the user did not want to send.
* **Recursive calling**: Recursive calling makes it impossible to set an upper bound on gas limits, opening the door for gas limit attacks.
* **Infinite-length loops**: Similar to recursive calling, infinite-length loops make it impossible to set an upper bound on gas limits, opening the door for gas limit attacks.
* **Binary fixed point**: Decimal fixed point is better, because any decimal fixed point value written as a literal in code has an exact representation, whereas with binary fixed point approximations are often required (e.g. (0.2)\ :sub:`10` = (0.001100110011...)\ :sub:`2`, which needs to be truncated), leading to unintuitive results, e.g. in Python 0.3 + 0.3 + 0.3 + 0.1 != 1.

Vyper **does not** strive to be a 100% replacement for everything that can be done in Solidity; it will deliberately forbid things or make things harder if it deems fit to do so for the goal of increasing security.
Installing Vyper
################

Take a deep breath, follow the instructions, and please
`create an issue <https://github.com/vyperlang/vyper/issues>`_ if you encounter
any errors.

.. note::

    The easiest way to experiment with the language is to use the `Remix online compiler <https://remix.ethereum.org>`_.
    (Activate the vyper-remix plugin in the Plugin manager.)

Docker
******

Vyper can be downloaded as docker image from `dockerhub <https://hub.docker.com/r/vyperlang/vyper/tags?page=1&ordering=last_updated>`_:
::

    docker pull vyperlang/vyper

To run the compiler use the ``docker run`` command:
::

    docker run -v $(pwd):/code vyperlang/vyper /code/<contract_file.vy>

Alternatively you can log into the docker image and execute vyper on the prompt.
::

    docker run -v $(pwd):/code/ -it --entrypoint /bin/bash vyperlang/vyper
    root@d35252d1fb1b:/code# vyper <contract_file.vy>

The normal parameters are also supported, for example:
::

    docker run -v $(pwd):/code vyperlang/vyper -f abi /code/<contract_file.vy>
    [{'name': 'test1', 'outputs': [], 'inputs': [{'type': 'uint256', 'name': 'a'}, {'type': 'bytes', 'name': 'b'}], 'constant': False, 'payable': False, 'type': 'function', 'gas': 441}, {'name': 'test2', 'outputs': [], 'inputs': [{'type': 'uint256', 'name': 'a'}], 'constant': False, 'payable': False, 'type': 'function', 'gas': 316}]

.. note::

    If you would like to know how to install Docker, please follow their `documentation <https://docs.docker.com/get-docker/>`_.

PIP
***

Installing Python
=================

Vyper can only be built using Python 3.6 and higher. If you need to know how to install the correct version of python,
follow the instructions from the official `Python website <https://wiki.python.org/moin/BeginnersGuide/Download>`_.

Creating a virtual environment
==============================

It is **strongly recommended** to install Vyper in **a virtual Python
environment**, so that new packages installed and dependencies built are
strictly contained in your Vyper project and will not alter or affect your
other development environment set-up.
For easy virtualenv management, we recommend either `pyenv <https://github.com/pyenv/pyenv>`_
or `Poetry <https://github.com/python-poetry/poetry>`_.


.. note::

    To find out more about virtual environments, check out:
    `virtualenv guide <https://docs.python.org/3/library/venv.html>`_.


Installing Vyper
================

Each tagged version of vyper is uploaded to `pypi <https://pypi.org/project/vyper/>`_, and can be installed using ``pip``:
::

    pip install vyper

To install a specific version use:
::

    pip install vyper==0.3.7

You can check if Vyper is installed completely or not by typing the following in your terminal/cmd:

::

    vyper --version
nix
***

View the versions supported through nix at `nix package search <https://search.nixos.org/packages?channel=21.05&show=vyper&from=0&size=50&sort=relevance&query=vyper>`_ 

.. note::

    The derivation for Vyper is located at  `nixpkgs <https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/compilers/vyper/default.nix>`_


Installing Vyper
============================

::

    nix-env -iA nixpkgs.vyper


.. _interfaces:

Interfaces
##########

An interface is a set of function definitions used to enable communication between smart contracts. A contract interface defines all of that contract's externally available functions. By importing the interface, your contract now knows how to call these functions in other contracts.

Declaring and using Interfaces
==============================

Interfaces can be added to contracts either through inline definition, or by importing them from a separate file.

The ``interface`` keyword is used to define an inline external interface:

.. code-block:: python

    interface FooBar:
        def calculate() -> uint256: view
        def test1(): nonpayable

The defined interface can then be used to make external calls, given a contract address:

.. code-block:: python

    @external
    def test(foobar: FooBar):
        foobar.calculate()

The interface name can also be used as a type annotation for storage variables. You then assign an address value to the variable to access that interface. Note that casting an address to an interface is possible, e.g. ``FooBar(<address_var>)``:

.. code-block:: python

    foobar_contract: FooBar

    @external
    def __init__(foobar_address: address):
        self.foobar_contract = FooBar(foobar_address)

    @external
    def test():
        self.foobar_contract.calculate()

Specifying ``payable`` or ``nonpayable`` annotation indicates that the call made to the external contract will be able to alter storage, whereas the ``view`` ``pure`` call will use a ``STATICCALL`` ensuring no storage can be altered during execution. Additionally, ``payable`` allows non-zero value to be sent along with the call.

.. code-block:: python

    interface FooBar:
        def calculate() -> uint256: pure
        def query() -> uint256: view
        def update(): nonpayable
        def pay(): payable

    @external
    def test(foobar: FooBar):
        foobar.calculate()  # cannot change storage
        foobar.query()  # cannot change storage, but reads itself
        foobar.update()  # storage can be altered
        foobar.pay(value=1)  # storage can be altered, and value can be sent

Vyper offers the option to set the following additional keyword arguments when making external calls:

=============================== ===========================================================
Keyword                         Description
=============================== ===========================================================
``gas``                         Specify gas value for the call
``value``                       Specify amount of ether sent with the call
``skip_contract_check``         Drop ``EXTCODESIZE`` and ``RETURNDATASIZE`` checks
``default_return_value``        Specify a default return value if no value is returned
=============================== ===========================================================

The ``default_return_value`` parameter can be used to handle ERC20 tokens affected by the missing return value bug in a way similar to OpenZeppelin's ``safeTransfer`` for Solidity:

.. code-block:: python

    ERC20(USDT).transfer(msg.sender, 1, default_return_value=True) # returns True
    ERC20(USDT).transfer(msg.sender, 1) # reverts because nothing returned

.. warning::

   When ``skip_contract_check=True`` is used and the called function returns data (ex.: ``x: uint256 = SomeContract.foo(skip_contract_check=True)``, no guarantees are provided by the compiler as to the validity of the returned value. In other words, it is undefined behavior what happens if the called contract did not exist. In particular, the returned value might point to garbage memory. It is therefore recommended to only use ``skip_contract_check=True`` to call contracts which have been manually ensured to exist at the time of the call.

Importing Interfaces
====================

Interfaces are imported with ``import`` or ``from ... import`` statements.

Imported interfaces are written using standard Vyper syntax. The body of each function is ignored when the interface is imported. If you are defining a standalone interface, it is normally specified by using a ``pass`` statement:

.. code-block:: python

    @external
    def test1():
        pass

    @external
    def calculate() -> uint256:
        pass

You can also import a fully implemented contract and Vyper will automatically convert it to an interface. It is even possible for a contract to import itself to gain access to its own interface.

.. code-block:: python

    import greeter as Greeter

    name: public(String[10])

    @external
    def __init__(_name: String[10]):
        self.name = _name

    @view
    @external
    def greet() -> String[16]:
        return concat("Hello ", Greeter(msg.sender).name())

Imports via ``import``
----------------------

With absolute ``import`` statements, you **must** include an alias as a name for the imported package. In the following example, failing to include ``as Foo`` will raise a compile error:

.. code-block:: python

    import contract.foo as Foo

Imports via ``from ... import``
-------------------------------

Using ``from`` you can perform both absolute and relative imports. You may optionally include an alias - if you do not, the name of the interface will be the same as the file.

.. code-block:: python

    # without an alias
    from contract import foo

    # with an alias
    from contract import foo as Foo

Relative imports are possible by prepending dots to the contract name. A single leading dot indicates a relative import starting with the current package. Two leading dots indicate a relative import from the parent of the current package:

.. code-block:: python

    from . import foo
    from ..interfaces import baz

.. _searching_for_imports:

Searching For Interface Files
-----------------------------

When looking for a file to import, Vyper will first search relative to the same folder as the contract being compiled. For absolute imports, it also searches relative to the root path for the project. Vyper checks for the file name with a ``.vy`` suffix first, then ``.json``.

When using the command line compiler, the root path defaults to the current working directory. You can change it with the ``-p`` flag:

::

    $ vyper my_project/contracts/my_contract.vy -p my_project

In the above example, the ``my_project`` folder is set as the root path. A contract cannot perform a relative import that goes beyond the top-level folder.

Built-in Interfaces
===================

Vyper includes common built-in interfaces such as `ERC20 <https://eips.ethereum.org/EIPS/eip-20>`_ and `ERC721 <https://eips.ethereum.org/EIPS/eip-721>`_. These are imported from ``vyper.interfaces``:

.. code-block:: python

    from vyper.interfaces import ERC20

    implements: ERC20

You can see all the available built-in interfaces in the `Vyper GitHub <https://github.com/vyperlang/vyper/tree/master/vyper/builtins/interfaces>`_ repo.

Implementing an Interface
=========================

You can define an interface for your contract with the ``implements`` statement:

.. code-block:: python

    import an_interface as FooBarInterface

    implements: FooBarInterface


This imports the defined interface from the vyper file at ``an_interface.vy`` (or ``an_interface.json`` if using ABI json interface type) and ensures your current contract implements all the necessary external functions. If any interface functions are not included in the contract, it will fail to compile. This is especially useful when developing contracts around well-defined standards such as ERC20.

.. note::

  Interfaces that implement functions with return values that require an upper bound (e.g. ``Bytes``, ``DynArray``, or ``String``), the upper bound defined in the interface represents the lower bound of the implementation. Assuming a function ``my_func`` returns a value ``String[1]`` in the interface, this would mean for the implementation function of ``my_func`` that the return value must have **at least** length 1. This behavior might change in the future.

Extracting Interfaces
=====================

Vyper has a built-in format option to allow you to make your own Vyper interfaces easily.

::

    $ vyper -f interface examples/voting/ballot.vy

    # Functions

    @view
    @external
    def delegated(addr: address) -> bool:
        pass

    # ...

If you want to do an external call to another contract, Vyper provides an external interface extract utility as well.

::

    $ vyper -f external_interface examples/voting/ballot.vy

    # External Contracts
    interface Ballot:
        def delegated(addr: address) -> bool: view
        def directlyVoted(addr: address) -> bool: view
        def giveRightToVote(voter: address): nonpayable
        def forwardWeight(delegate_with_weight_to_forward: address): nonpayable
        # ...

The output can then easily be copy-pasted to be consumed.
.. _natspec:

NatSpec Metadata
################

Vyper contracts can use a special form of docstring to provide rich documentation for functions, return variables and more. This special form is named the Ethereum Natural Language Specification Format (NatSpec).

This documentation is segmented into developer-focused messages and end-user-facing messages. These messages may be shown to the end user (the human) at the time that they will interact with the contract (i.e. sign a transaction).

Example
=======

Vyper supports structured documentation for contracts and external functions using the doxygen notation format.

.. note::

    The compiler does not parse docstrings of internal functions. You are welcome to NatSpec in comments for internal functions, however they are not processed or included in the compiler output.


.. code-block:: python

    """
    @title A simulator for Bug Bunny, the most famous Rabbit
    @license MIT
    @author Warned Bros
    @notice You can use this contract for only the most basic simulation
    @dev
        Simply chewing a carrot does not count, carrots must pass
        the throat to be considered eaten
    """

    @external
    @payable
    def doesEat(food: string[30], qty: uint256) -> bool:
        """
        @notice Determine if Bugs will accept `qty` of `food` to eat
        @dev Compares the entire string and does not rely on a hash
        @param food The name of a food to evaluate (in English)
        @param qty The number of food items to evaluate
        @return True if Bugs will eat it, False otherwise
        """

Tags
====

All tags are optional. The following table explains the purpose of each NatSpec tag and where it may be used:

=============== ============================================ ==================
Tag             Description                                  Context
=============== ============================================ ==================
``@title``      Title that describes the contract            contract
``@license``    License of the contract                      contract
``@author``     Name of the author                           contract, function
``@notice``     Explain to an end user what this does        contract, function
``@dev``        Explain to a developer any extra details     contract, function
``@param``      Documents a single parameter                 function
``@return``     Documents one or all return variable(s)      function
``@custom:...`` Custom tag, semantics is application-defined contract, function
=============== ============================================ ==================

Some rules / restrictions:

1. A single tag description may span multiple lines. All whitespace between lines is interpreted as a single space.
2. If a docstring is included with no NatSpec tags, it is interpreted as a ``@notice``.
3. Each use of ``@param`` must be followed by the name of an input argument. Including invalid or duplicate argument names raises a :func:`NatSpecSyntaxException<NatSpecSyntaxException>`.
4. The preferred use of ``@return`` is one entry for each output value, however you may also use it once for all outputs. Including more ``@return`` values than output values raises a :func:`NatSpecSyntaxException<NatSpecSyntaxException>`.

Documentation Output
====================

When parsed by the compiler, documentation such as the one from the above example will produce two different JSON outputs. One is meant to be consumed by the end user as a notice when a function is executed and the other to be used by the developer.

If the above contract is saved as ``carrots.vy`` then you can generate the documentation using:

.. code::

   vyper -f userdoc,devdoc carrots.vy

User Documentation
------------------

The above documentation will produce the following user documentation JSON as output:

.. code-block:: javascript

    {
      "methods": {
        "doesEat(string,uint256)": {
          "notice": "Determine if Bugs will accept `qty` of `food` to eat"
        }
      },
      "notice": "You can use this contract for only the most basic simulation"
    }

Note that the key by which to find the methods is the function's
canonical signature as defined in the contract ABI, not simply the function's
name.

Developer Documentation
-----------------------

Apart from the user documentation file, a developer documentation JSON
file should also be produced and should look like this:

.. code-block:: javascript

    {
      "author": "Warned Bros",
      "license": "MIT",
      "details": "Simply chewing a carrot does not count, carrots must pass the throat to be considered eaten",
      "methods": {
        "doesEat(string,uint256)": {
          "details" : "Compares the entire string and does not rely on a hash",
          "params": {
            "food": "The name of a food to evaluate (in English)",
            "qty": "The number of food items to evaluate"
          },
          "returns": {
            "_0": "True if Bugs will eat it, False otherwise"
          }
        }
      },
      "title" : "A simulator for Bug Bunny, the most famous Rabbit"
    }
.. _release-notes:

Release Notes
#############

..
    vim regexes:
    first convert all single backticks to double backticks:
    :'<,'>s/`/``/g
    to convert links to nice rst links:
    :'<,'>s/\v(https:\/\/github.com\/vyperlang\/vyper\/pull\/)(\d+)/(`#\2 <\1\2>`_)/g
    ex. in: https://github.com/vyperlang/vyper/pull/3373
    ex. out: (`#3373 <https://github.com/vyperlang/vyper/pull/3373>`_)
    for advisory links:
    :'<,'>s/\v(https:\/\/github.com\/vyperlang\/vyper\/security\/advisories\/)([-A-Za-z0-9]+)/(`\2 <\1\2>`_)/g

v0.3.10 ("Black Adder")
***********************

Date released: 2023-10-04
=========================

v0.3.10 is a performance focused release that additionally ships numerous bugfixes. It adds a ``codesize`` optimization mode (`#3493 <https://github.com/vyperlang/vyper/pull/3493>`_), adds new vyper-specific ``#pragma`` directives  (`#3493 <https://github.com/vyperlang/vyper/pull/3493>`_), uses Cancun's ``MCOPY`` opcode for some compiler generated code (`#3483 <https://github.com/vyperlang/vyper/pull/3483>`_), and generates selector tables which now feature O(1) performance (`#3496 <https://github.com/vyperlang/vyper/pull/3496>`_).

Breaking changes:
-----------------

- add runtime code layout to initcode (`#3584 <https://github.com/vyperlang/vyper/pull/3584>`_)
- drop evm versions through istanbul (`#3470 <https://github.com/vyperlang/vyper/pull/3470>`_)
- remove vyper signature from runtime (`#3471 <https://github.com/vyperlang/vyper/pull/3471>`_)
- only allow valid identifiers to be nonreentrant keys (`#3605 <https://github.com/vyperlang/vyper/pull/3605>`_)

Non-breaking changes and improvements:
--------------------------------------

- O(1) selector tables (`#3496 <https://github.com/vyperlang/vyper/pull/3496>`_)
- implement bound= in ranges (`#3537 <https://github.com/vyperlang/vyper/pull/3537>`_, `#3551 <https://github.com/vyperlang/vyper/pull/3551>`_)
- add optimization mode to vyper compiler (`#3493 <https://github.com/vyperlang/vyper/pull/3493>`_)
- improve batch copy performance (`#3483 <https://github.com/vyperlang/vyper/pull/3483>`_, `#3499 <https://github.com/vyperlang/vyper/pull/3499>`_, `#3525 <https://github.com/vyperlang/vyper/pull/3525>`_)

Notable fixes:
--------------

- fix ``ecrecover()`` behavior when signature is invalid (`GHSA-f5x6-7qgp-jhf3 <https://github.com/vyperlang/vyper/security/advisories/GHSA-f5x6-7qgp-jhf3>`_, `#3586 <https://github.com/vyperlang/vyper/pull/3586>`_)
- fix: order of evaluation for some builtins (`#3583 <https://github.com/vyperlang/vyper/pull/3583>`_, `#3587 <https://github.com/vyperlang/vyper/pull/3587>`_)
- fix: memory allocation in certain builtins using ``msize`` (`#3610 <https://github.com/vyperlang/vyper/pull/3610>`_)
- fix: ``_abi_decode()`` input validation in certain complex expressions (`#3626 <https://github.com/vyperlang/vyper/pull/3626>`_)
- fix: pycryptodome for arm builds (`#3485 <https://github.com/vyperlang/vyper/pull/3485>`_)
- let params of internal functions be mutable (`#3473 <https://github.com/vyperlang/vyper/pull/3473>`_)
- typechecking of folded builtins in (`#3490 <https://github.com/vyperlang/vyper/pull/3490>`_)
- update tload/tstore opcodes per latest 1153 EIP spec (`#3484 <https://github.com/vyperlang/vyper/pull/3484>`_)
- fix: raw_call type when max_outsize=0 is set (`#3572 <https://github.com/vyperlang/vyper/pull/3572>`_)
- fix: implements check for indexed event arguments (`#3570 <https://github.com/vyperlang/vyper/pull/3570>`_)
- fix: type-checking for ``_abi_decode()`` arguments (`#3626 <https://github.com/vyperlang/vyper/pull/3623>`_)

Other docs updates, chores and fixes:
-------------------------------------

- relax restrictions on internal function signatures (`#3573 <https://github.com/vyperlang/vyper/pull/3573>`_)
- note on security advisory in release notes for versions ``0.2.15``, ``0.2.16``, and ``0.3.0`` (`#3553 <https://github.com/vyperlang/vyper/pull/3553>`_)
- fix: yanked version in release notes (`#3545 <https://github.com/vyperlang/vyper/pull/3545>`_)
- update release notes on yanked versions (`#3547 <https://github.com/vyperlang/vyper/pull/3547>`_)
- improve error message for conflicting methods IDs (`#3491 <https://github.com/vyperlang/vyper/pull/3491>`_)
- document epsilon builtin (`#3552 <https://github.com/vyperlang/vyper/pull/3552>`_)
- relax version pragma parsing (`#3511 <https://github.com/vyperlang/vyper/pull/3511>`_)
- fix: issue with finding installed packages in editable mode (`#3510 <https://github.com/vyperlang/vyper/pull/3510>`_)
- add note on security advisory for ``ecrecover`` in docs (`#3539 <https://github.com/vyperlang/vyper/pull/3539>`_)
- add ``asm`` option to cli help (`#3585 <https://github.com/vyperlang/vyper/pull/3585>`_)
- add message to error map for repeat range check (`#3542 <https://github.com/vyperlang/vyper/pull/3542>`_)
- fix: public constant arrays (`#3536 <https://github.com/vyperlang/vyper/pull/3536>`_)


v0.3.9 ("Common Adder")
***********************

Date released: 2023-05-29

This is a patch release fix for v0.3.8. @bout3fiddy discovered a codesize regression for blueprint contracts in v0.3.8 which is fixed in this release. @bout3fiddy also discovered a runtime performance (gas) regression for default functions in v0.3.8 which is fixed in this release.

Fixes:

- initcode codesize blowup (`#3450 <https://github.com/vyperlang/vyper/pull/3450>`_)
- add back global calldatasize check for contracts with default fn (`#3463 <https://github.com/vyperlang/vyper/pull/3463>`_)


v0.3.8
******

Date released: 2023-05-23

Non-breaking changes and improvements:

- ``transient`` storage keyword (`#3373 <https://github.com/vyperlang/vyper/pull/3373>`_)
- ternary operators (`#3398 <https://github.com/vyperlang/vyper/pull/3398>`_)
- ``raw_revert()`` builtin (`#3136 <https://github.com/vyperlang/vyper/pull/3136>`_)
- shift operators (`#3019 <https://github.com/vyperlang/vyper/pull/3019>`_)
- make ``send()`` gas stipend configurable (`#3158 <https://github.com/vyperlang/vyper/pull/3158>`_)
- use new ``push0`` opcode (`#3361 <https://github.com/vyperlang/vyper/pull/3361>`_)
- python 3.11 support (`#3129 <https://github.com/vyperlang/vyper/pull/3129>`_)
- drop support for python 3.8 and 3.9 (`#3325 <https://github.com/vyperlang/vyper/pull/3325>`_)
- build for ``aarch64`` (`#2687 <https://github.com/vyperlang/vyper/pull/2687>`_)

Note that with the addition of ``push0`` opcode, ``shanghai`` is now the default compilation target for vyper. When deploying to a chain which does not support ``shanghai``, it is recommended to set ``--evm-version`` to ``paris``, otherwise it could result in hard-to-debug errors.

Major refactoring PRs:

- refactor front-end type system (`#2974 <https://github.com/vyperlang/vyper/pull/2974>`_)
- merge front-end and codegen type systems (`#3182 <https://github.com/vyperlang/vyper/pull/3182>`_)
- simplify ``GlobalContext`` (`#3209 <https://github.com/vyperlang/vyper/pull/3209>`_)
- remove ``FunctionSignature`` (`#3390 <https://github.com/vyperlang/vyper/pull/3390>`_)

Notable fixes:

- assignment when rhs is complex type and references lhs (`#3410 <https://github.com/vyperlang/vyper/pull/3410>`_)
- uninitialized immutable values (`#3409 <https://github.com/vyperlang/vyper/pull/3409>`_)
- success value when mixing ``max_outsize=0`` and ``revert_on_failure=False`` (`GHSA-w9g2-3w7p-72g9 <https://github.com/vyperlang/vyper/security/advisories/GHSA-w9g2-3w7p-72g9>`_)
- block certain kinds of storage allocator overflows (`GHSA-mgv8-gggw-mrg6 <https://github.com/vyperlang/vyper/security/advisories/GHSA-mgv8-gggw-mrg6>`_) 
- store-before-load when a dynarray appears on both sides of an assignment (`GHSA-3p37-3636-q8wv <https://github.com/vyperlang/vyper/security/advisories/GHSA-3p37-3636-q8wv>`_)
- bounds check for loops of the form ``for i in range(x, x+N)`` (`GHSA-6r8q-pfpv-7cgj <https://github.com/vyperlang/vyper/security/advisories/GHSA-6r8q-pfpv-7cgj>`_)
- alignment of call-site posargs and kwargs for internal functions (`GHSA-ph9x-4vc9-m39g <https://github.com/vyperlang/vyper/security/advisories/GHSA-ph9x-4vc9-m39g>`_)
- batch nonpayable check for default functions calldatasize < 4 (`#3104 <https://github.com/vyperlang/vyper/pull/3104>`_, `#3408 <https://github.com/vyperlang/vyper/pull/3408>`_, cf. `GHSA-vxmm-cwh2-q762 <https://github.com/vyperlang/vyper/security/advisories/GHSA-vxmm-cwh2-q762>`_)

Other docs updates, chores and fixes:

- call graph stability (`#3370 <https://github.com/vyperlang/vyper/pull/3370>`_)
- fix ``vyper-serve`` output (`#3338 <https://github.com/vyperlang/vyper/pull/3338>`_)
- add ``custom:`` natspec tags (`#3403 <https://github.com/vyperlang/vyper/pull/3403>`_)
- add missing pc maps to ``vyper_json`` output (`#3333 <https://github.com/vyperlang/vyper/pull/3333>`_)
- fix constructor context for internal functions (`#3388 <https://github.com/vyperlang/vyper/pull/3388>`_)
- add deprecation warning for ``selfdestruct`` usage (`#3372 <https://github.com/vyperlang/vyper/pull/3372>`_)
- add bytecode metadata option to vyper-json (`#3117 <https://github.com/vyperlang/vyper/pull/3117>`_)
- fix compiler panic when a ``break`` is outside of a loop (`#3177 <https://github.com/vyperlang/vyper/pull/3177>`_)
- fix complex arguments to builtin functions (`#3167 <https://github.com/vyperlang/vyper/pull/3167>`_)
- add support for all types in ABI imports (`#3154 <https://github.com/vyperlang/vyper/pull/3154>`_)
- disable uadd operator (`#3174 <https://github.com/vyperlang/vyper/pull/3174>`_)
- block bitwise ops on decimals (`#3219 <https://github.com/vyperlang/vyper/pull/3219>`_)
- raise ``UNREACHABLE`` (`#3194 <https://github.com/vyperlang/vyper/pull/3194>`_)
- allow enum as mapping key (`#3256 <https://github.com/vyperlang/vyper/pull/3256>`_)
- block boolean ``not`` operator on numeric types (`#3231 <https://github.com/vyperlang/vyper/pull/3231>`_)
- enforce that loop's iterators are valid names (`#3242 <https://github.com/vyperlang/vyper/pull/3242>`_)
- fix typechecker hotspot (`#3318 <https://github.com/vyperlang/vyper/pull/3318>`_)
- rewrite typechecker journal to handle nested commits (`#3375 <https://github.com/vyperlang/vyper/pull/3375>`_)
- fix missing pc map for empty functions (`#3202 <https://github.com/vyperlang/vyper/pull/3202>`_)
- guard against iterating over empty list in for loop (`#3197 <https://github.com/vyperlang/vyper/pull/3197>`_)
- skip enum members during constant folding (`#3235 <https://github.com/vyperlang/vyper/pull/3235>`_)
- bitwise ``not`` constant folding (`#3222 <https://github.com/vyperlang/vyper/pull/3222>`_)
- allow accessing members of constant address (`#3261 <https://github.com/vyperlang/vyper/pull/3261>`_)
- guard against decorators in interface (`#3266 <https://github.com/vyperlang/vyper/pull/3266>`_)
- fix bounds for decimals in some builtins (`#3283 <https://github.com/vyperlang/vyper/pull/3283>`_)
- length of literal empty bytestrings (`#3276 <https://github.com/vyperlang/vyper/pull/3276>`_)
- block ``empty()`` for HashMaps (`#3303 <https://github.com/vyperlang/vyper/pull/3303>`_)
- fix type inference for empty lists (`#3377 <https://github.com/vyperlang/vyper/pull/3377>`_)
- disallow logging from ``pure``, ``view`` functions (`#3424 <https://github.com/vyperlang/vyper/pull/3424>`_)
- improve optimizer rules for comparison operators (`#3412 <https://github.com/vyperlang/vyper/pull/3412>`_)
- deploy to ghcr on push (`#3435 <https://github.com/vyperlang/vyper/pull/3435>`_)
- add note on return value bounds in interfaces (`#3205 <https://github.com/vyperlang/vyper/pull/3205>`_)
- index ``id`` param in ``URI`` event of ``ERC1155ownable`` (`#3203 <https://github.com/vyperlang/vyper/pull/3203>`_)
- add missing ``asset`` function to ``ERC4626`` built-in interface (`#3295 <https://github.com/vyperlang/vyper/pull/3295>`_)
- clarify ``skip_contract_check=True`` can result in undefined behavior (`#3386 <https://github.com/vyperlang/vyper/pull/3386>`_)
- add ``custom`` NatSpec tag to docs (`#3404 <https://github.com/vyperlang/vyper/pull/3404>`_)
- fix ``uint256_addmod`` doc (`#3300 <https://github.com/vyperlang/vyper/pull/3300>`_)
- document optional kwargs for external calls (`#3122 <https://github.com/vyperlang/vyper/pull/3122>`_)
- remove ``slice()`` length documentation caveats (`#3152 <https://github.com/vyperlang/vyper/pull/3152>`_)
- fix docs of ``blockhash`` to reflect revert behaviour (`#3168 <https://github.com/vyperlang/vyper/pull/3168>`_)
- improvements to compiler error messages (`#3121 <https://github.com/vyperlang/vyper/pull/3121>`_, `#3134 <https://github.com/vyperlang/vyper/pull/3134>`_, `#3312 <https://github.com/vyperlang/vyper/pull/3312>`_, `#3304 <https://github.com/vyperlang/vyper/pull/3304>`_, `#3240 <https://github.com/vyperlang/vyper/pull/3240>`_, `#3264 <https://github.com/vyperlang/vyper/pull/3264>`_, `#3343 <https://github.com/vyperlang/vyper/pull/3343>`_, `#3307 <https://github.com/vyperlang/vyper/pull/3307>`_, `#3313 <https://github.com/vyperlang/vyper/pull/3313>`_ and `#3215 <https://github.com/vyperlang/vyper/pull/3215>`_)

These are really just the highlights, as many other bugfixes, docs updates and refactoring (over 150 pull requests!) made it into this release! For the full list, please see the `changelog <https://github.com/vyperlang/vyper/compare/v0.3.7...v0.3.8>`_. Special thanks to contributions from @tserg, @trocher, @z80dev, @emc415 and @benber86 in this release!

New Contributors:

- @omahs made their first contribution in (`#3128 <https://github.com/vyperlang/vyper/pull/3128>`_)
- @ObiajuluM made their first contribution in (`#3124 <https://github.com/vyperlang/vyper/pull/3124>`_)
- @trocher made their first contribution in (`#3134 <https://github.com/vyperlang/vyper/pull/3134>`_)
- @ozmium22 made their first contribution in (`#3149 <https://github.com/vyperlang/vyper/pull/3149>`_)
- @ToonVanHove made their first contribution in (`#3168 <https://github.com/vyperlang/vyper/pull/3168>`_)
- @emc415 made their first contribution in (`#3158 <https://github.com/vyperlang/vyper/pull/3158>`_)
- @lgtm-com made their first contribution in (`#3147 <https://github.com/vyperlang/vyper/pull/3147>`_)
- @tdurieux made their first contribution in (`#3224 <https://github.com/vyperlang/vyper/pull/3224>`_)
- @victor-ego made their first contribution in (`#3263 <https://github.com/vyperlang/vyper/pull/3263>`_)
- @miohtama made their first contribution in (`#3257 <https://github.com/vyperlang/vyper/pull/3257>`_)
- @kelvinfan001 made their first contribution in (`#2687 <https://github.com/vyperlang/vyper/pull/2687>`_)


v0.3.7
******

Date released: 2022-09-26

Breaking changes:

- chore: drop python 3.7 support (`#3071 <https://github.com/vyperlang/vyper/pull/3071>`_)
- fix: relax check for statically sized calldata (`#3090 <https://github.com/vyperlang/vyper/pull/3090>`_)

Non-breaking changes and improvements:

- fix: assert description in ``Crowdfund.finalize()`` (`#3058 <https://github.com/vyperlang/vyper/pull/3058>`_)
- fix: change mutability of example ERC721 interface (`#3076 <https://github.com/vyperlang/vyper/pull/3076>`_)
- chore: improve error message for non-checksummed address literal (`#3065 <https://github.com/vyperlang/vyper/pull/3065>`_)
- feat: ``isqrt()`` builtin (`#3074 <https://github.com/vyperlang/vyper/pull/3074>`_) (`#3069 <https://github.com/vyperlang/vyper/pull/3069>`_)
- feat: add ``block.prevrandao`` as alias for ``block.difficulty`` (`#3085 <https://github.com/vyperlang/vyper/pull/3085>`_)
- feat: ``epsilon()`` builtin (`#3057 <https://github.com/vyperlang/vyper/pull/3057>`_)
- feat: extend ecrecover signature to accept additional parameter types (`#3084 <https://github.com/vyperlang/vyper/pull/3084>`_)
- feat: allow constant and immutable variables to be declared public (`#3024 <https://github.com/vyperlang/vyper/pull/3024>`_)
- feat: optionally disable metadata in bytecode (`#3107 <https://github.com/vyperlang/vyper/pull/3107>`_)
    
Bugfixes:

- fix: empty nested dynamic arrays (`#3061 <https://github.com/vyperlang/vyper/pull/3061>`_)
- fix: foldable builtin default args in imports (`#3079 <https://github.com/vyperlang/vyper/pull/3079>`_) (`#3077 <https://github.com/vyperlang/vyper/pull/3077>`_)

Additional changes and improvements:

- doc: update broken links in SECURITY.md (`#3095 <https://github.com/vyperlang/vyper/pull/3095>`_)
- chore: update discord link in docs (`#3031 <https://github.com/vyperlang/vyper/pull/3031>`_)
- fix: broken links in various READMEs (`#3072 <https://github.com/vyperlang/vyper/pull/3072>`_)
- chore: fix compile warnings in examples (`#3033 <https://github.com/vyperlang/vyper/pull/3033>`_)
- feat: append lineno to the filename in error messages (`#3092 <https://github.com/vyperlang/vyper/pull/3092>`_)
- chore: migrate lark grammar (`#3082 <https://github.com/vyperlang/vyper/pull/3082>`_)
- chore: loosen and upgrade semantic version (`#3106 <https://github.com/vyperlang/vyper/pull/3106>`_)

New Contributors

- @emilianobonassi made their first contribution in `#3107 <https://github.com/vyperlang/vyper/pull/3107>`_
- @unparalleled-js made their first contribution in `#3106 <https://github.com/vyperlang/vyper/pull/3106>`_
- @pcaversaccio made their first contribution in `#3085 <https://github.com/vyperlang/vyper/pull/3085>`_
- @nfwsncked made their first contribution in `#3058 <https://github.com/vyperlang/vyper/pull/3058>`_
- @z80 made their first contribution in `#3057 <https://github.com/vyperlang/vyper/pull/3057>`_
- @Benny made their first contribution in `#3024 <https://github.com/vyperlang/vyper/pull/3024>`_
- @cairo made their first contribution in `#3072 <https://github.com/vyperlang/vyper/pull/3072>`_
- @fiddy made their first contribution in `#3069 <https://github.com/vyperlang/vyper/pull/3069>`_

Special thanks to returning contributors @tserg, @pandadefi, and @delaaxe.

v0.3.6
******

Date released: 2022-08-07

Bugfixes:

* Fix ``in`` expressions when list members are variables (`#3035 <https://github.com/vyperlang/vyper/pull/3035>`_)


v0.3.5
******
**THIS RELEASE HAS BEEN PULLED**

Date released: 2022-08-05

Non-breaking changes and improvements:

* Add blueprint deployer output format (`#3001 <https://github.com/vyperlang/vyper/pull/3001>`_)
* Allow arbitrary data to be passed to ``create_from_blueprint`` (`#2996 <https://github.com/vyperlang/vyper/pull/2996>`_)
* Add CBOR length to bytecode for decoders (`#3010 <https://github.com/vyperlang/vyper/pull/3010>`_)
* Fix compiler panic when accessing enum storage vars via ``self`` (`#2998 <https://github.com/vyperlang/vyper/pull/2998>`_)
* Fix: allow ``empty()`` in constant definitions and in default argument position (`#3008 <https://github.com/vyperlang/vyper/pull/3008>`_)
* Fix: disallow ``self`` address in pure functions (`#3027 <https://github.com/vyperlang/vyper/pull/3027>`_)

v0.3.4
******

Date released: 2022-07-27

Non-breaking changes and improvements:

* Add enum types (`#2874 <https://github.com/vyperlang/vyper/pull/2874>`_, `#2915 <https://github.com/vyperlang/vyper/pull/2915>`_, `#2925 <https://github.com/vyperlang/vyper/pull/2925>`_, `#2977 <https://github.com/vyperlang/vyper/pull/2977>`_)
* Add ``_abi_decode`` builtin (`#2882 <https://github.com/vyperlang/vyper/pull/2882>`_)
* Add ``create_from_blueprint`` and ``create_copy_of`` builtins (`#2895 <https://github.com/vyperlang/vyper/pull/2895>`_)
* Add ``default_return_value`` kwarg for calls (`#2839 <https://github.com/vyperlang/vyper/pull/2839>`_)
* Add ``min_value`` and ``max_value`` builtins for numeric types (`#2935 <https://github.com/vyperlang/vyper/pull/2935>`_)
* Add ``uint2str`` builtin (`#2879 <https://github.com/vyperlang/vyper/pull/2879>`_)
* Add vyper signature to bytecode (`#2860 <https://github.com/vyperlang/vyper/pull/2860>`_)


Other fixes and improvements:

* Call internal functions from constructor (`#2496 <https://github.com/vyperlang/vyper/pull/2496>`_)
* Arithmetic for new int types (`#2843 <https://github.com/vyperlang/vyper/pull/2843>`_)
* Allow ``msg.data`` in ``raw_call`` without ``slice`` (`#2902 <https://github.com/vyperlang/vyper/pull/2902>`_)
* Per-method calldatasize checks (`#2911 <https://github.com/vyperlang/vyper/pull/2911>`_)
* Type inference and annotation of arguments for builtin functions (`#2817 <https://github.com/vyperlang/vyper/pull/2817>`_)
* Allow varargs for ``print`` (`#2833 <https://github.com/vyperlang/vyper/pull/2833>`_)
* Add ``error_map`` output format for tooling consumption (`#2939 <https://github.com/vyperlang/vyper/pull/2939>`_)
* Multiple evaluation of contract address in call (`GHSA-4v9q-cgpw-cf38 <https://github.com/vyperlang/vyper/security/advisories/GHSA-4v9q-cgpw-cf38>`_)
* Improve ast output (`#2824 <https://github.com/vyperlang/vyper/pull/2824>`_)
* Allow ``@nonreentrant`` on view functions (`#2921 <https://github.com/vyperlang/vyper/pull/2921>`_)
* Add ``shift()`` support for signed integers (`#2964 <https://github.com/vyperlang/vyper/pull/2964>`_)
* Enable dynarrays of strings (`#2922 <https://github.com/vyperlang/vyper/pull/2922>`_)
* Fix off-by-one bounds check in certain safepow cases (`#2983 <https://github.com/vyperlang/vyper/pull/2983>`_)
* Optimizer improvements (`#2647 <https://github.com/vyperlang/vyper/pull/2647>`_, `#2868 <https://github.com/vyperlang/vyper/pull/2868>`_, `#2914 <https://github.com/vyperlang/vyper/pull/2914>`_, `#2843 <https://github.com/vyperlang/vyper/pull/2843>`_, `#2944 <https://github.com/vyperlang/vyper/pull/2944>`_)
* Reverse order in which exceptions are reported (`#2838 <https://github.com/vyperlang/vyper/pull/2838>`_)
* Fix compile-time blowup for large contracts (`#2981 <https://github.com/vyperlang/vyper/pull/2981>`_)
* Rename ``vyper-ir`` binary to ``fang`` (`#2936 <https://github.com/vyperlang/vyper/pull/2936>`_)


Many other small bugfixes, optimizations and refactoring also made it into this release! Special thanks to @tserg and @pandadefi for contributing several important bugfixes, refactoring and features to this release!


v0.3.3
******

Date released: 2022-04-22

This is a bugfix release. It patches an off-by-one error in the storage allocation mechanism for dynamic arrays reported by @haltman-at in `#2820 <https://github.com/vyperlang/vyper/issues/2820>`_

Other fixes and improvements:

* Add a ``print`` built-in which allows printing debugging messages in hardhat. (`#2818 <https://github.com/vyperlang/vyper/pull/2818>`_)
* Fix various error messages (`#2798 <https://github.com/vyperlang/vyper/pull/2798>`_, `#2805 <https://github.com/vyperlang/vyper/pull/2805>`_)


v0.3.2
******

Date released: 2022-04-17

Breaking changes:

* Increase the bounds of the ``decimal`` type (`#2730 <https://github.com/vyperlang/vyper/pull/2730>`_)
* Generalize and simplify the semantics of the ``convert`` builtin (`#2694 <https://github.com/vyperlang/vyper/pull/2694>`_)
* Restrict hex and bytes literals (`#2736 <https://github.com/vyperlang/vyper/pull/2736>`_, `#2872 <https://github.com/vyperlang/vyper/pull/2782>`_)

Non-breaking changes and improvements:

* Implement dynamic arrays (`#2556 <https://github.com/vyperlang/vyper/pull/2556>`_, `#2606 <https://github.com/vyperlang/vyper/pull/2606>`_, `#2615 <https://github.com/vyperlang/vyper/pull/2615>`_)
* Support all ABIv2 integer and bytes types (`#2705 <https://github.com/vyperlang/vyper/pull/2705>`_)
* Add storage layout override mechanism (`#2593 <https://github.com/vyperlang/vyper/pull/2593>`_)
* Support ``<address>.code`` attribute (`#2583 <https://github.com/vyperlang/vyper/pull/2583>`_)
* Add ``tx.gasprice`` builtin (`#2624 <https://github.com/vyperlang/vyper/pull/2624>`_)
* Allow structs as constant variables (`#2617 <https://github.com/vyperlang/vyper/pull/2617>`_)
* Implement ``skip_contract_check`` kwarg (`#2551 <https://github.com/vyperlang/vyper/pull/2551>`_)
* Support EIP-2678 ethPM manifest files (`#2628 <https://github.com/vyperlang/vyper/pull/2628>`_)
* Add ``metadata`` output format (`#2597 <https://github.com/vyperlang/vyper/pull/2597>`_)
* Allow ``msg.*`` variables in internal functions (`#2632 <https://github.com/vyperlang/vyper/pull/2632>`_)
* Add ``unsafe_`` arithmetic builtins (`#2629 <https://github.com/vyperlang/vyper/pull/2629>`_)
* Add subroutines to Vyper IR (`#2598 <https://github.com/vyperlang/vyper/pull/2598>`_)
* Add ``select`` opcode to Vyper IR (`#2690 <https://github.com/vyperlang/vyper/pull/2690>`_)
* Allow lists of any type as loop variables (`#2616 <https://github.com/vyperlang/vyper/pull/2616>`_)
* Improve suggestions in error messages (`#2806 <https://github.com/vyperlang/vyper/pull/2806>`_)

Notable Fixes:

* Clamping of returndata from external calls in complex expressions (`GHSA-4mrx-6fxm-8jpg <https://github.com/vyperlang/vyper/security/advisories/GHSA-4mrx-6fxm-8jpg>`_, `GHSA-j2x6-9323-fp7h <https://github.com/vyperlang/vyper/security/advisories/GHSA-j2x6-9323-fp7h>`_)
* Bytestring equality for (N<=32) (`GHSA-7vrm-3jc8-5wwm <https://github.com/vyperlang/vyper/security/advisories/GHSA-7vrm-3jc8-5wwm>`_)
* Typechecking of constant variables (`#2580 <https://github.com/vyperlang/vyper/pull/2580>`_, `#2603 <https://github.com/vyperlang/vyper/pull/2603>`_)
* Referencing immutables in constructor (`#2627 <https://github.com/vyperlang/vyper/pull/2627>`_)
* Arrays of interfaces in for loops (`#2699 <https://github.com/vyperlang/vyper/pull/2699>`_)

Lots of optimizations, refactoring and other fixes made it into this release! For the full list, please see the `changelog <https://github.com/vyperlang/vyper/compare/v0.3.1...v0.3.2>`_.

Special thanks to @tserg for typechecker fixes and significant testing of new features! Additional contributors to this release include @abdullathedruid, @hi-ogawa, @skellet0r, @fubuloubu, @onlymaresia, @SwapOperator, @hitsuzen-eth, @Sud0u53r, @davidhq.


v0.3.1
*******

Date released: 2021-12-01

Breaking changes:

* Disallow changes to decimal precision when used as a library (`#2479 <https://github.com/vyperlang/vyper/pull/2479>`_)

Non-breaking changes and improvements:

* Add immutable variables (`#2466 <https://github.com/vyperlang/vyper/pull/2466>`_)
* Add uint8 type (`#2477 <https://github.com/vyperlang/vyper/pull/2477>`_)
* Add gaslimit and basefee env variables (`#2495 <https://github.com/vyperlang/vyper/pull/2495>`_)
* Enable checkable raw_call (`#2482 <https://github.com/vyperlang/vyper/pull/2482>`_)
* Propagate revert data when external call fails (`#2531 <https://github.com/vyperlang/vyper/pull/2531>`_)
* Improve LLL annotations (`#2486 <https://github.com/vyperlang/vyper/pull/2486>`_)
* Optimize short-circuiting boolean operations (`#2467 <https://github.com/vyperlang/vyper/pull/2467>`_, `#2493 <https://github.com/vyperlang/vyper/pull/2493>`_)
* Optimize identity precompile usage (`#2488 <https://github.com/vyperlang/vyper/pull/2488>`_)
* Remove loaded limits for int128 and address (`#2506 <https://github.com/vyperlang/vyper/pull/2506>`_)
* Add machine readable ir_json format (`#2510 <https://github.com/vyperlang/vyper/pull/2510>`_)
* Optimize raw_call for the common case when the input is in memory (`#2481 <https://github.com/vyperlang/vyper/pull/2481>`_)
* Remove experimental OVM transpiler (`#2532 <https://github.com/vyperlang/vyper/pull/2532>`_)
* Add CLI flag to disable optimizer (`#2522 <https://github.com/vyperlang/vyper/pull/2522>`_)
* Add docs for LLL syntax and semantics (`#2494 <https://github.com/vyperlang/vyper/pull/2494>`_)

Fixes:

* Allow non-constant revert reason strings (`#2509 <https://github.com/vyperlang/vyper/pull/2509>`_)
* Allow slices of complex expressions (`#2500 <https://github.com/vyperlang/vyper/pull/2500>`_)
* Remove seq_unchecked from LLL codegen (`#2485 <https://github.com/vyperlang/vyper/pull/2485>`_)
* Fix external calls with default parameters (`#2526 <https://github.com/vyperlang/vyper/pull/2526>`_)
* Enable lists of structs as function arguments (`#2515 <https://github.com/vyperlang/vyper/pull/2515>`_)
* Fix .balance on constant addresses (`#2533 <https://github.com/vyperlang/vyper/pull/2533>`_)
* Allow variable indexing into constant/literal arrays (`#2534 <https://github.com/vyperlang/vyper/pull/2534>`_)
* Fix allocation of unused storage slots (`#2439 <https://github.com/vyperlang/vyper/pull/2439>`_, `#2514 <https://github.com/vyperlang/vyper/pull/2514>`_)

Special thanks to @skellet0r for some major features in this release!

v0.3.0
*******
⚠️ A critical security vulnerability has been discovered in this version and we strongly recommend using version `0.3.1 <https://github.com/vyperlang/vyper/releases/tag/v0.3.1>`_ or higher. For more information, please see the Security Advisory `GHSA-5824-cm3x-3c38 <https://github.com/vyperlang/vyper/security/advisories/GHSA-5824-cm3x-3c38>`_.

Date released: 2021-10-04

Breaking changes:

* Change ABI encoding of single-struct return values to be compatible with Solidity (`#2457 <https://github.com/vyperlang/vyper/pull/2457>`_)
* Drop Python 3.6 support (`#2462 <https://github.com/vyperlang/vyper/pull/2462>`_)

Non-breaking changes and improvements:

* Rewrite internal calling convention (`#2447 <https://github.com/vyperlang/vyper/pull/2447>`_)
* Allow any ABI-encodable type as function arguments and return types (`#2154 <https://github.com/vyperlang/vyper/issues/2154>`_, `#2190 <https://github.com/vyperlang/vyper/issues/2190>`_)
* Add support for deterministic deployment of minimal proxies using CREATE2 (`#2460 <https://github.com/vyperlang/vyper/pull/2460>`_)
* Optimize code for certain copies (`#2468 <https://github.com/vyperlang/vyper/pull/2468>`_)
* Add -o CLI flag to redirect output to a file (`#2452 <https://github.com/vyperlang/vyper/pull/2452>`_)
* Other docs updates (`#2450 <https://github.com/vyperlang/vyper/pull/2450>`_)

Fixes:

* _abi_encode builtin evaluates arguments multiple times (`#2459 <https://github.com/vyperlang/vyper/issues/2459>`_)
* ABI length is too short for nested tuples (`#2458 <https://github.com/vyperlang/vyper/issues/2458>`_)
* Returndata is not clamped for certain numeric types (`#2454 <https://github.com/vyperlang/vyper/issues/2454>`_)
* __default__ functions do not respect nonreentrancy keys (`#2455 <https://github.com/vyperlang/vyper/issues/2455>`_)
* Clamps for bytestrings in initcode are broken (`#2456 <https://github.com/vyperlang/vyper/issues/2456>`_)
* Missing clamps for decimal args in external functions (`GHSA-c7pr-343r-5c46 <https://github.com/vyperlang/vyper/security/advisories/GHSA-c7pr-343r-5c46>`_)
* Memory corruption when returning a literal struct with a private function call inside of it (`GHSA-xv8x-pr4h-73jv <https://github.com/vyperlang/vyper/security/advisories/GHSA-xv8x-pr4h-73jv>`_)

Special thanks to contributions from @skellet0r and @benjyz for this release!


v0.2.16
*******
⚠️ A critical security vulnerability has been discovered in this version and we strongly recommend using version `0.3.1 <https://github.com/vyperlang/vyper/releases/tag/v0.3.1>`_ or higher. For more information, please see the Security Advisory `GHSA-5824-cm3x-3c38 <https://github.com/vyperlang/vyper/security/advisories/GHSA-5824-cm3x-3c38>`_.

Date released: 2021-08-27

Non-breaking changes and improvements:

* Expose _abi_encode as a user-facing builtin (`#2401 <https://github.com/vyperlang/vyper/pull/2401>`_)
* Export the storage layout as a compiler output option (`#2433 <https://github.com/vyperlang/vyper/pull/2433>`_)
* Add experimental OVM backend (`#2416 <https://github.com/vyperlang/vyper/pull/2416>`_)
* Allow any ABI-encodable type as event arguments (`#2403 <https://github.com/vyperlang/vyper/pull/2403>`_)
* Optimize int128 clamping (`#2411 <https://github.com/vyperlang/vyper/pull/2411>`_)
* Other docs updates (`#2405 <https://github.com/vyperlang/vyper/pull/2405>`_, `#2422 <https://github.com/vyperlang/vyper/pull/2422>`_, `#2425 <https://github.com/vyperlang/vyper/pull/2425>`_)

Fixes:

* Disallow nonreentrant decorator on constructors (`#2426 <https://github.com/vyperlang/vyper/pull/2426>`_)
* Fix bounds checks when handling msg.data (`#2419 <https://github.com/vyperlang/vyper/pull/2419>`_)
* Allow interfaces in lists, structs and maps (`#2397 <https://github.com/vyperlang/vyper/pull/2397>`_)
* Fix trailing newline parse bug (`#2412 <https://github.com/vyperlang/vyper/pull/2412>`_)

Special thanks to contributions from @skellet0r, @sambacha and @milancermak for this release!


v0.2.15
*******
⚠️ A critical security vulnerability has been discovered in this version and we strongly recommend using version `0.3.1 <https://github.com/vyperlang/vyper/releases/tag/v0.3.1>`_ or higher. For more information, please see the Security Advisory `GHSA-5824-cm3x-3c38 <https://github.com/vyperlang/vyper/security/advisories/GHSA-5824-cm3x-3c38>`_.

Date released: 23-07-2021

Non-breaking changes and improvements
- Optimization when returning nested tuples (`#2392 <https://github.com/vyperlang/vyper/pull/2392>`_)

Fixes:
- Annotated kwargs for builtins (`#2389 <https://github.com/vyperlang/vyper/pull/2389>`_)
- Storage slot allocation bug (`#2391 <https://github.com/vyperlang/vyper/pull/2391>`_)

v0.2.14
*******
**THIS RELEASE HAS BEEN PULLED**

Date released: 20-07-2021

Non-breaking changes and improvements:
- Reduce bytecode by sharing code for clamps (`#2387 <https://github.com/vyperlang/vyper/pull/2387>`_)

Fixes:
- Storage corruption from re-entrancy locks (`#2379 <https://github.com/vyperlang/vyper/pull/2379>`_)

v0.2.13
*******
**THIS RELEASE HAS BEEN PULLED**

Date released: 06-07-2021

Non-breaking changes and improvements:

- Add the ``abs`` builtin function (`#2356 <https://github.com/vyperlang/vyper/pull/2356>`_)
- Streamline the location of arrays within storage (`#2361 <https://github.com/vyperlang/vyper/pull/2361>`_)

v0.2.12
*******

Date released: 16-04-2021

This release fixes a memory corruption bug (`#2345 <https://github.com/vyperlang/vyper/pull/2345>`_) that was introduced in the v0.2.x series
and was not fixed in `VVE-2020-0004 <https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf>`_. Read about it further in
`VVE-2021-0001 <https://github.com/vyperlang/vyper/security/advisories/GHSA-22wc-c9wj-6q2v>`_.

Non-breaking changes and improvements:

- Optimize ``calldataload`` (`#2352 <https://github.com/vyperlang/vyper/pull/2352>`_)
- Add the ``int256`` signed integer type (`#2351 <https://github.com/vyperlang/vyper/pull/2351>`_)
- EIP2929 opcode repricing and Berlin support (`#2350 <https://github.com/vyperlang/vyper/pull/2350>`_)
- Add ``msg.data`` environment variable #2343 (`#2343 <https://github.com/vyperlang/vyper/pull/2343>`_)
- Full support for Python 3.9 (`#2233 <https://github.com/vyperlang/vyper/pull/2233>`_)

v0.2.11
*******

Date released: 27-02-2021

This is a quick patch release to fix a memory corruption bug that was introduced in v0.2.9 (`#2321 <https://github.com/vyperlang/vyper/pull/2321>`_) with excessive memory deallocation when releasing internal variables

v0.2.10
*******
**THIS RELEASE HAS BEEN PULLED**

Date released: 17-02-2021

This is a quick patch release to fix incorrect generated ABIs that was introduced in v0.2.9 (`#2311 <https://github.com/vyperlang/vyper/pull/2311>`_) where storage variable getters were incorrectly marked as ``nonpayable`` instead of ``view``

v0.2.9
******
**THIS RELEASE HAS BEEN PULLED**

Date released: 16-02-2021

Non-breaking changes and improvements:
- Add license to wheel, Anaconda support (`#2265 <https://github.com/vyperlang/vyper/pull/2265>`_)
- Consider events during type-check with `implements:` (`#2283 <https://github.com/vyperlang/vyper/pull/2283>`_)
- Refactor ABI generation (`#2284 <https://github.com/vyperlang/vyper/pull/2284>`_)
- Remove redundant checks in parser/signatures (`#2288 <https://github.com/vyperlang/vyper/pull/2288>`_)
- Streamling ABI-encoding logic for tuple return types (`#2302 <https://github.com/vyperlang/vyper/pull/2302>`_)
- Optimize function ordering within bytecode (`#2303 <https://github.com/vyperlang/vyper/pull/2303>`_)
- Assembly-level optimizations (`#2304 <https://github.com/vyperlang/vyper/pull/2304>`_)
- Optimize nonpayable assertion (`#2307 <https://github.com/vyperlang/vyper/pull/2307>`_)
- Optimize re-entrancy locks (`#2308 <https://github.com/vyperlang/vyper/pull/2308>`_)

Fixes:
- Change forwarder proxy bytecode to ERC-1167 (`#2281 <https://github.com/vyperlang/vyper/pull/2281>`_)
- Reserved keywords check update (`#2286 <https://github.com/vyperlang/vyper/pull/2286>`_)
- Incorrect type-check error in literal lists (`#2309 <https://github.com/vyperlang/vyper/pull/2309>`_)

Tons of Refactoring work courtesy of (`@iamdefinitelyahuman <https://github.com/iamdefinitelyahuman>`_)!

v0.2.8
******

Date released: 04-12-2020

Non-breaking changes and improvements:

- AST updates to provide preliminary support for Python 3.9 (`#2225 <https://github.com/vyperlang/vyper/pull/2225>`_)
- Support for the ``not in`` comparator (`#2232 <https://github.com/vyperlang/vyper/pull/2232>`_)
- Lift restriction on calldata variables shadowing storage variables (`#2226 <https://github.com/vyperlang/vyper/pull/2226>`_)
- Optimize ``shift`` bytecode when 2nd arg is a literal (`#2201 <https://github.com/vyperlang/vyper/pull/2201>`_)
- Warn when EIP-170 size limit is exceeded (`#2208 <https://github.com/vyperlang/vyper/pull/2208>`_)

Fixes:

- Allow use of ``slice`` on a calldata ``bytes32`` (`#2227 <https://github.com/vyperlang/vyper/pull/2227>`_)
- Explicitly disallow iteration of a list of structs (`#2228 <https://github.com/vyperlang/vyper/pull/2228>`_)
- Improved validation of address checksums (`#2229 <https://github.com/vyperlang/vyper/pull/2229>`_)
- Bytes are always represented as hex within the AST (`#2231 <https://github.com/vyperlang/vyper/pull/2231>`_)
- Allow ``empty`` as an argument within a function call (`#2234 <https://github.com/vyperlang/vyper/pull/2234>`_)
- Allow ``empty`` static-sized array as an argument within a ``log`` statement (`#2235 <https://github.com/vyperlang/vyper/pull/2235>`_)
- Compile-time issue with ``Bytes`` variables as a key in a mapping (`#2239 <https://github.com/vyperlang/vyper/pull/2239>`_)

v0.2.7
******

Date released: 10-14-2020

This is a quick patch release to fix a runtime error introduced in ``v0.2.6`` (`#2188 <https://github.com/vyperlang/vyper/pull/2188>`_) that could allow for memory corruption under certain conditions.

Non-breaking changes and improvements:

- Optimizations around ``assert`` and ``raise`` (`#2198 <https://github.com/vyperlang/vyper/pull/2198>`_)
- Simplified internal handling of memory variables (`#2194 <https://github.com/vyperlang/vyper/pull/2194>`_)

Fixes:

- Ensure internal variables are always placed sequentially within memory (`#2196 <https://github.com/vyperlang/vyper/pull/2196>`_)
- Bugfixes around memory de-allocation (`#2197 <https://github.com/vyperlang/vyper/pull/2197>`_)

v0.2.6
******
**THIS RELEASE HAS BEEN PULLED**

Date released: 10-10-2020

Non-breaking changes and improvements:

- Release and reuse memory slots within the same function (`#2188 <https://github.com/vyperlang/vyper/pull/2188>`_)
- Allow implicit use of ``uint256`` as iterator type in range-based for loops (`#2180 <https://github.com/vyperlang/vyper/pull/2180>`_)
- Optimize clamping logic for ``int128`` (`#2179 <https://github.com/vyperlang/vyper/pull/2179>`_)
- Calculate array index offsets at compile time where possible (`#2187 <https://github.com/vyperlang/vyper/pull/2187>`_)
- Improved exception for invalid use of dynamically sized struct (`#2189 <https://github.com/vyperlang/vyper/pull/2189>`_)
- Improved exception for incorrect arg count in function call (`#2178 <https://github.com/vyperlang/vyper/pull/2178>`_)
- Improved exception for invalid subscript (`#2177 <https://github.com/vyperlang/vyper/pull/2177>`_)

Fixes:

- Memory corruption issue when performing function calls inside a tuple or another function call (`#2186 <https://github.com/vyperlang/vyper/pull/2186>`_)
- Incorrect function output when using multidimensional arrays (`#2184 <https://github.com/vyperlang/vyper/pull/2184>`_)
- Reduced ambiguity bewteen ``address`` and ``Bytes[20]`` (`#2191 <https://github.com/vyperlang/vyper/pull/2191>`_)

v0.2.5
******

Date released: 30-09-2020

Non-breaking changes and improvements:

- Improve exception on incorrect interface (`#2131 <https://github.com/vyperlang/vyper/pull/2131>`_)
- Standalone binary preparation (`#2134 <https://github.com/vyperlang/vyper/pull/2134>`_)
- Improve make freeze (`#2135 <https://github.com/vyperlang/vyper/pull/2135>`_)
- Remove Excessive Scoping Rules on Local Variables (`#2166 <https://github.com/vyperlang/vyper/pull/2166>`_)
- Optimize nonpayable check for contracts that do not accept ETH (`#2172 <https://github.com/vyperlang/vyper/pull/2172>`_)
- Optimize safemath on division-by-zero with a literal divisor (`#2173 <https://github.com/vyperlang/vyper/pull/2173>`_)
- Optimize multiple sequential memory-zeroings (`#2174 <https://github.com/vyperlang/vyper/pull/2174>`_)
- Optimize size-limit checks for address and bool types (`#2175 <https://github.com/vyperlang/vyper/pull/2175>`_)

Fixes:

- Constant folding on lhs of assignments (`#2137 <https://github.com/vyperlang/vyper/pull/2137>`_)
- ABI issue with bytes and string arrays inside tuples (`#2140 <https://github.com/vyperlang/vyper/pull/2140>`_)
- Returning struct from a external function gives error (`#2143 <https://github.com/vyperlang/vyper/pull/2143>`_)
- Error messages with struct display all members (`#2160 <https://github.com/vyperlang/vyper/pull/2160>`_)
- The returned struct value from the external call doesn't get stored properly (`#2164 <https://github.com/vyperlang/vyper/pull/2164>`_)
- Improved exception on invalid function-scoped assignment (`#2176 <https://github.com/vyperlang/vyper/pull/2176>`_)

v0.2.4
******

Date released: 03-08-2020

Non-breaking changes and improvements:

- Improve EOF Exceptions (`#2115 <https://github.com/vyperlang/vyper/pull/2115>`_)
- Improve exception messaging for type mismatches (`#2119 <https://github.com/vyperlang/vyper/pull/2119>`_)
- Ignore trailing newline tokens (`#2120 <https://github.com/vyperlang/vyper/pull/2120>`_)

Fixes:

- Fix ABI translations for structs that are returned from functions (`#2114 <https://github.com/vyperlang/vyper/pull/2114>`_)
- Raise when items that are not types are called (`#2118 <https://github.com/vyperlang/vyper/pull/2118>`_)
- Ensure hex and decimal AST nodes are serializable (`#2123 <https://github.com/vyperlang/vyper/pull/2123>`_)

v0.2.3
******

Date released: 16-07-2020

Non-breaking changes and improvements:

- Show contract names in raised exceptions (`#2103 <https://github.com/vyperlang/vyper/pull/2103>`_)
- Adjust function offsets to not include decorators (`#2102 <https://github.com/vyperlang/vyper/pull/2102>`_)
- Raise certain exception types immediately during module-scoped type checking (`#2101 <https://github.com/vyperlang/vyper/pull/2101>`_)

Fixes:

- Pop ``for`` loop values from stack prior to returning (`#2110 <https://github.com/vyperlang/vyper/pull/2110>`_)
- Type checking non-literal array index values (`#2108 <https://github.com/vyperlang/vyper/pull/2108>`_)
- Meaningful output during ``for`` loop type checking (`#2096 <https://github.com/vyperlang/vyper/pull/2096>`_)

v0.2.2
******

Date released: 04-07-2020

Fixes:

- Do not fold exponentiation to a negative power (`#2089 <https://github.com/vyperlang/vyper/pull/2089>`_)
- Add repr for mappings (`#2090 <https://github.com/vyperlang/vyper/pull/2090>`_)
- Literals are only validated once (`#2093 <https://github.com/vyperlang/vyper/pull/2093>`_)

v0.2.1
******

Date released: 03-07-2020

This is a major breaking release of the Vyper compiler and language. It is also the first release following our versioning scheme (`#1887 <https://github.com/vyperlang/vyper/issues/1887>`_).

Breaking changes:

- ``@public`` and ``@private`` function decorators have been renamed to ``@external`` and ``@internal`` (VIP `#2065 <https://github.com/vyperlang/vyper/issues/2065>`_)
- The ``@constant`` decorator has been renamed to ``@view`` (VIP `#2040 <https://github.com/vyperlang/vyper/issues/2040>`_)
- Type units have been removed (VIP `#1881 <https://github.com/vyperlang/vyper/issues/1881>`_)
- Event declaraion syntax now resembles that of struct declarations (VIP `#1864 <https://github.com/vyperlang/vyper/issues/1864>`_)
- ``log`` is now a statement (VIP `#1864 <https://github.com/vyperlang/vyper/issues/1864>`_)
- Mapping declaration syntax changed to ``HashMap[key_type, value_type]`` (VIP `#1969 <https://github.com/vyperlang/vyper/issues/1969>`_)
- Interfaces are now declared via the ``interface`` keyword instead of ``contract`` (VIP `#1825 <https://github.com/vyperlang/vyper/issues/1825>`_)
- ``bytes`` and ``string`` types are now written as ``Bytes`` and ``String`` (`#2080 <https://github.com/vyperlang/vyper/pull/2080>`_)
- ``bytes`` and ``string`` literals must now be bytes or regular strings, respectively. They are no longer interchangeable. (VIP `#1876 <https://github.com/vyperlang/vyper/issues/1876>`_)
- ``assert_modifiable`` has been removed, you can now directly perform assertions on calls (`#2050 <https://github.com/vyperlang/vyper/pull/2050>`_)
- ``value`` is no longer an allowable variable name in a function input (VIP `#1877 <https://github.com/vyperlang/vyper/issues/1877>`_)
- The ``slice`` builtin function expects ``uint256`` for the ``start`` and ``length`` args (VIP `#1986 <https://github.com/vyperlang/vyper/issues/1986>`_)
- ``len`` return type is now ``uint256`` (VIP `#1979 <https://github.com/vyperlang/vyper/issues/1979>`_)
- ``value`` and ``gas`` kwargs for external function calls must be given as ``uint256`` (VIP `#1878 <https://github.com/vyperlang/vyper/issues/1878>`_)
- The ``outsize`` kwarg in ``raw_call`` has been renamed to ``max_outsize`` (`#1977 <https://github.com/vyperlang/vyper/pull/1977>`_)
- The ``type`` kwarg in ``extract32`` has been renamed to ``output_type`` (`#2036 <https://github.com/vyperlang/vyper/pull/2036>`_)
- Public array getters now use ``uint256`` for their input argument(s) (VIP `#1983 <https://github.com/vyperlang/vyper/issues/1983>`_)
- Public struct getters now return all values of a struct (`#2064 <https://github.com/vyperlang/vyper/pull/2064>`_)
- ``RLPList`` has been removed (VIP `#1866 <https://github.com/vyperlang/vyper/issues/1866>`_)


The following non-breaking VIPs and features were implemented:

- Implement boolean condition short circuiting (VIP `#1817 <https://github.com/vyperlang/vyper/issues/1817>`_)
- Add the ``empty`` builtin function for zero-ing a value (`#1676 <https://github.com/vyperlang/vyper/pull/1676>`_)
- Refactor of the compiler process resulting in an almost 5x performance boost! (`#1962 <https://github.com/vyperlang/vyper/pull/1962>`_)
- Support ABI State Mutability Fields in Interface Definitions (VIP `#2042 <https://github.com/vyperlang/vyper/issues/2042>`_)
- Support ``@pure`` decorator (VIP `#2041 <https://github.com/vyperlang/vyper/issues/2041>`_)
- Overflow checks for exponentiation (`#2072 <https://github.com/vyperlang/vyper/pull/2072>`_)
- Validate return data length via ``RETURNDATASIZE`` (`#2076 <https://github.com/vyperlang/vyper/pull/2076>`_)
- Improved constant folding (`#1949 <https://github.com/vyperlang/vyper/pull/1949>`_)
- Allow raise without reason string (VIP `#1902 <https://github.com/vyperlang/vyper/issues/1902>`_)
- Make the type argument in ``method_id`` optional (VIP `#1980 <https://github.com/vyperlang/vyper/issues/1980>`_)
- Hash complex types when used as indexed values in an event (`#2060 <https://github.com/vyperlang/vyper/pull/2060>`_)
- Ease restrictions on calls to self (`#2059 <https://github.com/vyperlang/vyper/pull/2059>`_)
- Remove ordering restrictions in module-scope of contract (`#2057 <https://github.com/vyperlang/vyper/pull/2057>`_)
- ``raw_call`` can now be used to perform a ``STATICCALL`` (`#1973 <https://github.com/vyperlang/vyper/pull/1973>`_)
- Optimize precompiles to use ``STATICCALL`` (`#1930 <https://github.com/vyperlang/vyper/pull/1930>`_)

Some of the bug and stability fixes:

- Arg clamping issue when using multidimensional arrays (`#2071 <https://github.com/vyperlang/vyper/pull/2071>`_)
- Support calldata arrays with the ``in`` comparator (`#2070 <https://github.com/vyperlang/vyper/pull/2070>`_)
- Prevent modification of a storage array during iteration via ``for`` loop (`#2028 <https://github.com/vyperlang/vyper/pull/2028>`_)
- Fix memory length of revert string (`#1982 <https://github.com/vyperlang/vyper/pull/1982>`_)
- Memory offset issue when returning tuples from private functions (`#1968 <https://github.com/vyperlang/vyper/pull/1968>`_)
- Issue with arrays as default function arguments (`#2077 <https://github.com/vyperlang/vyper/pull/2077>`_)
- Private function calls no longer generate a call signature (`#2058 <https://github.com/vyperlang/vyper/pull/2058>`_)

Significant codebase refactor, thanks to (`@iamdefinitelyahuman <https://github.com/iamdefinitelyahuman>`_)!

**NOTE**: ``v0.2.0`` was not used due to a conflict in PyPI with a previous release. Both tags ``v0.2.0`` and ``v0.2.1`` are identical.

v0.1.0-beta.17
**************

Date released: 24-03-2020

The following VIPs and features were implemented for Beta 17:

- ``raw_call`` and ``slice`` argument updates (VIP `#1879 <https://github.com/vyperlang/vyper/issues/1879>`_)
- NatSpec support (`#1898 <https://github.com/vyperlang/vyper/pull/1898>`_)

Some of the bug and stability fixes:

- ABI interface fixes (`#1842 <https://github.com/vyperlang/vyper/pull/1842>`_)
- Modifications to how ABI data types are represented (`#1846 <https://github.com/vyperlang/vyper/pull/1846>`_)
- Generate method identifier for struct return type (`#1843 <https://github.com/vyperlang/vyper/pull/1843>`_)
- Return tuple with fixed array fails to compile (`#1838 <https://github.com/vyperlang/vyper/pull/1838>`_)
- Also lots of refactoring and doc updates!

This release will be the last to follow our current release process.
All future releases will be governed by the versioning scheme (`#1887 <https://github.com/vyperlang/vyper/issues/1887>`_).
The next release will be v0.2.0, and contain many breaking changes.


v0.1.0-beta.16
**************

Date released: 09-01-2020

Beta 16 was a quick patch release to fix one issue: (`#1829 <https://github.com/vyperlang/vyper/pull/1829>`_)

v0.1.0-beta.15
**************

Date released: 06-01-2020

**NOTE**: we changed our license to Apache 2.0 (`#1772 <https://github.com/vyperlang/vyper/pull/1772>`_)

The following VIPs were implemented for Beta 15:

- EVM Ruleset Switch (VIP `#1230 <https://github.com/vyperlang/vyper/issues/1230>`_)
- Add support for `EIP-1344 <https://eips.ethereum.org/EIPS/eip-1344>`_, Chain ID Opcode (VIP `#1652 <https://github.com/vyperlang/vyper/issues/1652>`_)
- Support for `EIP-1052 <https://eips.ethereum.org/EIPS/eip-1052>`_, ``EXTCODEHASH`` (VIP `#1765 <https://github.com/vyperlang/vyper/issues/1765>`_)

Some of the bug and stability fixes:

- Removed all traces of Javascript from the codebase (`#1770 <https://github.com/vyperlang/vyper/pull/1770>`_)
- Ensured sufficient gas stipend for precompiled calls (`#1771 <https://github.com/vyperlang/vyper/pull/1771>`_)
- Allow importing an interface that contains an ``implements`` statement (`#1774 <https://github.com/vyperlang/vyper/pull/1774>`_)
- Fixed how certain values compared when using ``min`` and ``max`` (`#1790 <https://github.com/vyperlang/vyper/pull/1790>`_)
- Removed unnecessary overflow checks on ``addmod`` and ``mulmod`` (`#1786 <https://github.com/vyperlang/vyper/pull/1786>`_)
- Check for state modification when using tuples (`#1785 <https://github.com/vyperlang/vyper/pull/1785>`_)
- Fix Windows path issue when importing interfaces (`#1781 <https://github.com/vyperlang/vyper/pull/1781>`_)
- Added Vyper grammar, currently used for fuzzing (`#1768 <https://github.com/vyperlang/vyper/pull/1768>`_)
- Modify modulus calculations for literals to be consistent with the EVM (`#1792 <https://github.com/vyperlang/vyper/pull/1792>`_)
- Explicitly disallow the use of exponentiation on decimal values (`#1792 <https://github.com/vyperlang/vyper/pull/1792>`_)
- Add compile-time checks for divide by zero and modulo by zero (`#1792 <https://github.com/vyperlang/vyper/pull/1792>`_)
- Fixed some issues with negating constants (`#1791 <https://github.com/vyperlang/vyper/pull/1791>`_)
- Allow relative imports beyond one parent level (`#1784 <https://github.com/vyperlang/vyper/pull/1784>`_)
- Implement SHL/SHR for bitshifting, using Constantinople rules (`#1796 <https://github.com/vyperlang/vyper/pull/1796>`_)
- ``vyper-json`` compatibility with ``solc`` settings (`#1795 <https://github.com/vyperlang/vyper/pull/1795>`_)
- Simplify the type check when returning lists (`#1797 <https://github.com/vyperlang/vyper/pull/1797>`_)
- Add branch coverage reporting (`#1743 <https://github.com/vyperlang/vyper/pull/1743>`_)
- Fix struct assignment order (`#1728 <https://github.com/vyperlang/vyper/pull/1728>`_)
- Added more words to reserved keyword list (`#1741 <https://github.com/vyperlang/vyper/pull/1741>`_)
- Allow scientific notation for literals (`#1721 <https://github.com/vyperlang/vyper/pull/1721>`_)
- Avoid overflow on sqrt of Decimal upper bound (`#1679 <https://github.com/vyperlang/vyper/pull/1679>`_)
- Refactor ABI encoder (`#1723 <https://github.com/vyperlang/vyper/pull/1723>`_)
- Changed opcode costs per `EIP-1884 <https://eips.ethereum.org/EIPS/eip-1884>`_ (`#1764 <https://github.com/vyperlang/vyper/pull/1764>`_)

Special thanks to (`@iamdefinitelyahuman <https://github.com/iamdefinitelyahuman>`_) for lots of updates this release!

v0.1.0-beta.14
**************

Date released: 13-11-2019

Some of the bug and stability fixes:

- Mucho Documentation and Example cleanup!
- Python 3.8 support (`#1678 <https://github.com/vyperlang/vyper/pull/1678>`_)
- Disallow scientific notation in literals, which previously parsed incorrectly (`#1681 <https://github.com/vyperlang/vyper/pull/1681>`_)
- Add implicit rewrite rule for ``bytes[32]`` -> ``bytes32`` (`#1718 <https://github.com/vyperlang/vyper/pull/1718>`_)
- Support ``bytes32`` in ``raw_log`` (`#1719 <https://github.com/vyperlang/vyper/pull/1719>`_)
- Fixed EOF parsing bug (`#1720 <https://github.com/vyperlang/vyper/pull/1720>`_)
- Cleaned up arithmetic expressions (`#1661 <https://github.com/vyperlang/vyper/pull/1661>`_)
- Fixed off-by-one in check for homogeneous list element types (`#1673 <https://github.com/vyperlang/vyper/pull/1673>`_)
- Fixed stack valency issues in if and for statements (`#1665 <https://github.com/vyperlang/vyper/pull/1665>`_)
- Prevent overflow when using ``sqrt`` on certain datatypes (`#1679 <https://github.com/vyperlang/vyper/pull/1679>`_)
- Prevent shadowing of internal variables (`#1601 <https://github.com/vyperlang/vyper/pull/1601>`_)
- Reject unary substraction on unsigned types  (`#1638 <https://github.com/vyperlang/vyper/pull/1638>`_)
- Disallow ``orelse`` syntax in ``for`` loops (`#1633 <https://github.com/vyperlang/vyper/pull/1633>`_)
- Increased clarity and efficiency of zero-padding (`#1605 <https://github.com/vyperlang/vyper/pull/1605>`_)

v0.1.0-beta.13
**************

Date released: 27-09-2019

The following VIPs were implemented for Beta 13:

- Add ``vyper-json`` compilation mode (VIP `#1520 <https://github.com/vyperlang/vyper/issues/1520>`_)
- Environment variables and constants can now be used as default parameters (VIP `#1525 <https://github.com/vyperlang/vyper/issues/1525>`_)
- Require uninitialized memory be set on creation (VIP `#1493 <https://github.com/vyperlang/vyper/issues/1493>`_)

Some of the bug and stability fixes:

- Type check for default params and arrays (`#1596 <https://github.com/vyperlang/vyper/pull/1596>`_)
- Fixed bug when using assertions inside for loops (`#1619 <https://github.com/vyperlang/vyper/pull/1619>`_)
- Fixed zero padding error for ABI encoder (`#1611 <https://github.com/vyperlang/vyper/pull/1611>`_)
- Check ``calldatasize`` before ``calldataload`` for function selector (`#1606 <https://github.com/vyperlang/vyper/pull/1606>`_)

v0.1.0-beta.12
**************

Date released: 27-08-2019

The following VIPs were implemented for Beta 12:

- Support for relative imports (VIP `#1367 <https://github.com/vyperlang/vyper/issues/1367>`_)
- Restricted use of environment variables in private functions (VIP `#1199 <https://github.com/vyperlang/vyper/issues/1199>`_)

Some of the bug and stability fixes:

- ``@nonreentrant``/``@constant`` logical inconsistency (`#1544 <https://github.com/vyperlang/vyper/issues/1544>`_)
- Struct passthrough issue (`#1551 <https://github.com/vyperlang/vyper/issues/1551>`_)
- Private underflow issue (`#1470 <https://github.com/vyperlang/vyper/pull/1470>`_)
- Constancy check issue (`#1480 <https://github.com/vyperlang/vyper/pull/1480>`_)
- Prevent use of conflicting method IDs (`#1530 <https://github.com/vyperlang/vyper/pull/1530>`_)
- Missing arg check for private functions (`#1579 <https://github.com/vyperlang/vyper/pull/1579>`_)
- Zero padding issue (`#1563 <https://github.com/vyperlang/vyper/issues/1563>`_)
- ``vyper.cli`` rearchitecture of scripts (`#1574 <https://github.com/vyperlang/vyper/issues/1574>`_)
- AST end offsets and Solidity-compatible compressed sourcemap (`#1580 <https://github.com/vyperlang/vyper/pull/1580>`_)

Special thanks to (`@iamdefinitelyahuman <https://github.com/iamdefinitelyahuman>`_) for lots of updates this release!

v0.1.0-beta.11
**************

Date released: 23-07-2019

Beta 11 brings some performance and stability fixes.

- Using calldata instead of memory parameters. (`#1499 <https://github.com/vyperlang/vyper/pull/1499>`_)
- Reducing of contract size, for large parameter functions. (`#1486 <https://github.com/vyperlang/vyper/pull/1486>`_)
- Improvements for Windows users (`#1486 <https://github.com/vyperlang/vyper/pull/1486>`_)  (`#1488 <https://github.com/vyperlang/vyper/pull/1488>`_)
- Array copy optimisation (`#1487 <https://github.com/vyperlang/vyper/pull/1487>`_)
- Fixing ``@nonreentrant`` decorator for return statements (`#1532 <https://github.com/vyperlang/vyper/pull/1532>`_)
- ``sha3`` builtin function removed  (`#1328 <https://github.com/vyperlang/vyper/issues/1328>`_)
- Disallow conflicting method IDs (`#1530 <https://github.com/vyperlang/vyper/pull/1530>`_)
- Additional ``convert()`` supported types (`#1524 <https://github.com/vyperlang/vyper/pull/1524>`_) (`#1500 <https://github.com/vyperlang/vyper/pull/1500>`_)
- Equality operator for strings and bytes (`#1507 <https://github.com/vyperlang/vyper/pull/1507>`_)
- Change in ``compile_codes`` interface function (`#1504 <https://github.com/vyperlang/vyper/pull/1504>`_)

Thanks to all the contributors!

v0.1.0-beta.10
**************

Date released: 24-05-2019

- Lots of linting and refactoring!
- Bugfix with regards to using arrays as parameters to private functions (`#1418 <https://github.com/vyperlang/vyper/issues/1418>`_). Please check your contracts, and upgrade to latest version, if you do use this.
- Slight shrinking in init produced bytecode. (`#1399 <https://github.com/vyperlang/vyper/issues/1399>`_)
- Additional constancy protection in the ``for .. range`` expression. (`#1397 <https://github.com/vyperlang/vyper/issues/1397>`_)
- Improved bug report (`#1394 <https://github.com/vyperlang/vyper/issues/1394>`_)
- Fix returning of External Contract from functions (`#1376 <https://github.com/vyperlang/vyper/issues/1376>`_)
- Interface unit fix (`#1303 <https://github.com/vyperlang/vyper/issues/1303>`_)
- Not Equal (!=) optimisation (`#1303 <https://github.com/vyperlang/vyper/issues/1303>`_) 1386
- New ``assert <condition>, UNREACHABLE`` statement. (`#711 <https://github.com/vyperlang/vyper/issues/711>`_)

Special thanks to (`Charles Cooper <https://github.com/charles-cooper>`_), for some excellent contributions this release.

v0.1.0-beta.9
*************

Date released: 12-03-2019

- Add support for list constants (`#1211 <https://github.com/vyperlang/vyper/issues/1211>`_)
- Add ``sha256`` function (`#1327 <https://github.com/vyperlang/vyper/issues/1327>`_)
- Renamed ``create_with_code_of`` to ``create_forwarder_to`` (`#1177 <https://github.com/vyperlang/vyper/issues/1177>`_)
- ``@nonreentrant`` Decorator  (`#1204 <https://github.com/vyperlang/vyper/issues/1204>`_)
- Add opcodes and opcodes_runtime flags to compiler (`#1255 <https://github.com/vyperlang/vyper/pull/1255>`_)
- Improved External contract call interfaces (`#885 <https://github.com/vyperlang/vyper/issues/885>`_)

Prior to v0.1.0-beta.9
**********************

Prior to this release, we managed our change log in a different fashion.
Here is the old changelog:

* **2019.04.05**: Add stricter checking of unbalanced return statements. (`#590 <https://github.com/vyperlang/vyper/issues/590>`_)
* **2019.03.04**: ``create_with_code_of`` has been renamed to ``create_forwarder_to``. (`#1177 <https://github.com/vyperlang/vyper/issues/1177>`_)
* **2019.02.14**: Assigning a persistent contract address can only be done using the ``bar_contact = ERC20(<address>)`` syntax.
* **2019.02.12**: ERC20 interface has to be imported using ``from vyper.interfaces import ERC20`` to use.
* **2019.01.30**: Byte array literals need to be annoted using ``b""``, strings are represented as `""`.
* **2018.12.12**: Disallow use of ``None``, disallow use of ``del``, implemented ``clear()`` built-in function.
* **2018.11.19**: Change mapping syntax to use ``map()``. (`VIP564 <https://github.com/vyperlang/vyper/issues/564>`_)
* **2018.10.02**: Change the convert style to use types instead of string. (`VIP1026 <https://github.com/vyperlang/vyper/issues/1026>`_)
* **2018.09.24**: Add support for custom constants.
* **2018.08.09**: Add support for default parameters.
* **2018.06.08**: Tagged first beta.
* **2018.05.23**: Changed ``wei_value`` to be ``uint256``.
* **2018.04.03**: Changed bytes declaration from ``bytes <= n`` to ``bytes[n]``.
* **2018.03.27**: Renaming ``signed256`` to ``int256``.
* **2018.03.22**: Add modifiable and static keywords for external contract calls.
* **2018.03.20**: Renaming ``__log__`` to ``event``.
* **2018.02.22**: Renaming num to int128, and num256 to uint256.
* **2018.02.13**: Ban functions with payable and constant decorators.
* **2018.02.12**: Division by num returns decimal type.
* **2018.02.09**: Standardize type conversions.
* **2018.02.01**: Functions cannot have the same name as globals.
* **2018.01.27**: Change getter from get_var to var.
* **2018.01.11**: Change version from 0.0.2 to 0.0.3
* **2018.01.04**: Types need to be specified on assignment (`VIP545 <https://github.com/vyperlang/vyper/issues/545>`_).
* **2017.01.02** Change ``as_wei_value`` to use quotes for units.
* **2017.12.25**: Change name from Viper to Vyper.
* **2017.12.22**: Add ``continue`` for loops
* **2017.11.29**: ``@internal`` renamed to ``@private``.
* **2017.11.15**: Functions require either ``@internal`` or ``@public`` decorators.
* **2017.07.25**: The ``def foo() -> num(const): ...`` syntax no longer works; you now need to do ``def foo() -> num: ...`` with a ``@constant`` decorator on the previous line.
* **2017.07.25**: Functions without a ``@payable`` decorator now fail when called with nonzero wei.
* **2017.07.25**: A function can only call functions that are declared above it (that is, A can call B only if B appears earlier in the code than A does). This was introduced
.. _resources:

Other resources and learning material
#####################################

Vyper has an active community. You can find third-party tutorials, examples, courses, and other learning material.

General
-------

- `Ape Academy – Learn how to build Vyper projects <https://academy.apeworx.io/>`_ by ApeWorX
- `More Vyper by Example <https://vyper-by-example.org/>`_ by Smart Contract Engineer
- `Vyper cheat Sheet <https://reference.auditless.com/cheatsheet>`_
- `Vyper Hub for development <https://github.com/zcor/vyper-dev>`_
- `Vyper greatest hits smart contract examples <https://github.com/pynchmeister/vyper-greatest-hits/tree/main/contracts>`_
- `A curated list of Vyper resources, libraries, tools, and more <https://github.com/stars/pcaversaccio/lists/vyper>`_

Frameworks and tooling
----------------------

- `Titanoboa – An experimental Vyper interpreter with pretty tracebacks, forking, debugging features and more <https://github.com/vyperlang/titanoboa/>`_
- `ApeWorX – The Ethereum development framework for Python Developers, Data Scientists, and Security Professionals <https://www.apeworx.io/>`_
- `VyperDeployer – A helper smart contract to compile and test Vyper contracts in Foundry <https://github.com/pcaversaccio/snekmate/blob/main/lib/utils/VyperDeployer.sol>`_
- `🐍 snekmate – Vyper smart contract building blocks <https://github.com/pcaversaccio/snekmate>`_
- `Serpentor – A set of smart contracts tools for governance <https://github.com/yearn/serpentor>`_
- `Smart contract development frameworks and tools for Vyper on Ethreum.org <https://ethereum.org/en/developers/docs/programming-languages/python/>`_

Security
--------

- `VyperPunk – learn to secure and hack Vyper smart contracts <https://github.com/SupremacyTeam/VyperPunk>`_
- `VyperExamples – Vyper vulnerability examples <https://www.vyperexamples.com/reentrancy>`_

Conference presentations
------------------------

- `Vyper Smart Contract Programming Language by Patrick Collins (2022, 30 mins) <https://www.youtube.com/watch?v=b-sOMNF9quo&t=1444s>`_
- `Python and DeFi by Curve Finance (2022, 15 mins) <https://www.youtube.com/watch?v=4HOU3z0LoDg>`_
- `My experience with Vyper over the years by Benjamin Scherrey (2022, 15 mins) <https://www.youtube.com/watch?v=_j7qF_GlyWE>`_
- `Short introduction to Vyper by Edison Que (3 mins) <https://www.youtube.com/watch?v=dXqln-keyHw&t=4s>`_

Unmaintained
------------

These resources have not been updated for a while, but may still offer interesting content.

- `Awesome Vyper curated resources <https://github.com/spadebuilders/awesome-vyper>`_
- `Brownie – Python framework for developing smart contracts (deprecated) <https://eth-brownie.readthedocs.io/en/stable/>`_
- `Foundry x Vyper – Foundry template to compile Vyper contracts <https://github.com/0xKitsune/Foundry-Vyper>`_
.. _scoping:

Scoping and Declarations
########################

Variable Declaration
====================

The first time a variable is referenced you must declare its :ref:`type <types>`:

.. code-block:: python

    data: int128

In the above example, we declare the variable ``data`` with a type of ``int128``.

Depending on the active scope, an initial value may or may not be assigned:

    * For storage variables (declared in the module scope), an initial value **cannot** be set
    * For memory variables (declared within a function), an initial value **must** be set
    * For calldata variables (function input arguments), a default value **may** be given

Declaring Public Variables
--------------------------

Storage variables can be marked as ``public`` during declaration:

.. code-block:: python

    data: public(int128)

The compiler automatically creates getter functions for all public storage variables. For the example above, the compiler will generate a function called ``data`` that does not take any arguments and returns an ``int128``, the value of the state variable data.

For public arrays, you can only retrieve a single element via the generated getter. This mechanism exists to avoid high gas costs when returning an entire array. The getter will accept an argument to specify which element to return, for example ``data(0)``.

Declaring Immutable Variables
-----------------------------

Variables can be marked as ``immutable`` during declaration:

.. code-block:: python

    DATA: immutable(uint256)

    @external
    def __init__(_data: uint256):
        DATA = _data

Variables declared as immutable are similar to constants, except they are assigned a value in the constructor of the contract. Immutable values must be assigned a value at construction and cannot be assigned a value after construction.

The contract creation code generated by the compiler will modify the contract’s runtime code before it is returned by appending all values assigned to immutables to the runtime code returned by the constructor. This is important if you are comparing the runtime code generated by the compiler with the one actually stored in the blockchain.

Tuple Assignment
----------------

You cannot directly declare tuple types. However, in certain cases you can use literal tuples during assignment. For example, when a function returns multiple values:

.. code-block:: python

    @internal
    def foo() -> (int128, int128):
        return 2, 3

    @external
    def bar():
        a: int128 = 0
        b: int128 = 0

        # the return value of `foo` is assigned using a tuple
        (a, b) = self.foo()

        # Can also skip the parenthesis
        a, b = self.foo()


Storage Layout
==============

Storage variables are located within a smart contract at specific storage slots. By default, the compiler allocates the first variable to be stored at ``slot 0``; subsequent variables are stored in order after that.

There are cases where it is necessary to override this pattern and to allocate storage variables in custom slots. This behaviour is often required for upgradeable contracts, to ensure that both contracts (the old contract, and the new contract) store the same variable within the same slot.

This can be performed when compiling  via ``vyper`` by including the ``--storage-layout-file`` flag.

For example, consider upgrading the following contract:

.. code-block:: python

    # old_contract.vy
    owner: public(address)
    balanceOf: public(HashMap[address, uint256])

.. code-block:: python

    # new_contract.vy
    owner: public(address)
    minter: public(address)
    balanceOf: public(HashMap[address, uint256])

This would cause an issue when upgrading, as the ``balanceOf`` mapping would be located at ``slot1`` in the old contract, and ``slot2`` in the new contract.

This issue can be avoided by allocating ``balanceOf`` to ``slot1`` using the storage layout overrides. The contract can be compiled with ``vyper new_contract.vy --storage-layout-file new_contract_storage.json`` where ``new_contract_storage.json`` contains the following:

.. code-block:: javascript

    {
        "owner": {"type": "address", "slot": 0},
        "minter": {"type": "address", "slot": 2},
        "balanceOf": {"type": "HashMap[address, uint256]", "slot": 1}
    }

For further information on generating the storage layout, see :ref:`Storage Layout <compiler-storage-layout>`.

Scoping Rules
=============

Vyper follows C99 scoping rules. Variables are visible from the point right after their declaration until the end of the smallest block that contains the declaration.

.. _scoping-module:

Module Scope
------------

Variables and other items declared outside of a code block (functions, constants, event and struct definitions, ...), are visible even before they were declared. This means you can use module-scoped items before they are declared.

An exception to this rule is that you can only call functions that have already been declared.

Accessing Module Scope from Functions
*************************************

Values that are declared in the module scope of a contract, such as storage variables and functions, are accessed via the ``self`` object:

.. code-block:: python

    a: int128

    @internal
    def foo() -> int128
        return 42

    @external
    def foo() -> int128:
        b: int128 = self.foo()
        return self.a  + b

Name Shadowing
**************

It is not permitted for a memory or calldata variable to shadow the name of an immutable or constant value. The following examples will not compile:

.. code-block:: python

    a: constant(bool) = True

    @external
    def foo() -> bool:
        # memory variable cannot have the same name as a constant or immutable variable
        a: bool = False
        return a
.. code-block:: python

    a: immutable(bool)

    @external
    def __init__():
        a = True
    @external
    def foo(a:bool) -> bool:
        # input argument cannot have the same name as a constant or immutable variable
        return a

Function Scope
--------------

Variables that are declared within a function, or given as function input arguments, are visible within the body of that function. For example, the following contract is valid because each declaration of ``a`` only exists within one function's body.

.. code-block:: python

    @external
    def foo(a: int128):
        pass

    @external
    def bar(a: uint256):
        pass

    @external
    def baz():
        a: bool = True

The following examples will not compile:

.. code-block:: python

    @external
    def foo(a: int128):
        # `a` has already been declared as an input argument
        a: int128 = 21

.. code-block:: python

    @external
    def foo(a: int128):
        a = 4

    @external
    def bar():
        # `a` has not been declared within this function
        a += 12

.. _scoping-block:

Block Scopes
------------

Logical blocks created by ``for`` and ``if`` statements have their own scope. For example, the following contract is valid because ``x`` only exists within the block scopes for each branch of the ``if`` statement:

.. code-block:: python

    @external
    def foo(a: bool) -> int128:
        if a:
            x: int128 = 3
        else:
            x: bool = False

In a ``for`` statement, the target variable exists within the scope of the loop. For example, the following contract is valid because ``i`` is no longer available upon exiting the loop:

.. code-block:: python

    @external
    def foo(a: bool) -> int128:
        for i in [1, 2, 3]:
            pass
        i: bool = False

The following contract fails to compile because ``a`` has not been declared outside of the loop.

.. code-block:: python

    @external
    def foo(a: bool) -> int128:
        for i in [1, 2, 3]:
            a: int128 = i
        a += 3
.. _statements:

Statements
##########

Vyper's statements are syntactically similar to Python, with some notable exceptions.

Control Flow
============

break
-----

The ``break`` statement terminates the nearest enclosing ``for`` loop.

.. code-block:: python

    for i in [1, 2, 3, 4, 5]:
        if i == a:
            break

In the above example, the ``for`` loop terminates if ``i == a``.

continue
--------

The ``continue`` statement begins the next cycle of the nearest enclosing ``for`` loop.

.. code-block:: python

    for i in [1, 2, 3, 4, 5]:
        if i != a:
            continue
        ...

In the above example, the ``for`` loop begins the next cycle immediately whenever ``i != a``.

pass
----

``pass`` is a null operation — when it is executed, nothing happens. It is useful as a placeholder when a statement is required syntactically, but no code needs to be executed:

.. code-block:: python

    # this function does nothing (yet!)

    @external
    def foo():
        pass

return
------

``return`` leaves the current function call with the expression list (or None) as a return value.

.. code-block:: python

    return RETURN_VALUE

If a function has no return type, it is allowed to omit the ``return`` statement, otherwise, the function must end with a ``return`` statement, or another terminating action such as ``raise``.

It is not allowed to have additional, unreachable statements after a ``return`` statement.

Event Logging
=============

log
---

The ``log`` statement is used to log an event:

.. code-block:: python

    log MyEvent(...)

The event must have been previously declared.

See :ref:`Event Logging<event-logging>` for more information on events.

Assertions and Exceptions
=========================

Vyper uses state-reverting exceptions to handle errors. Exceptions trigger the ``REVERT`` opcode (``0xFD``) with the provided reason given as the error message. When an exception is raised the code stops operation, the contract's state is reverted to the state before the transaction took place and the remaining gas is returned to the transaction's sender. When an exception happen in a sub-call, it “bubbles up” (i.e., exceptions are rethrown) automatically.

If the reason string is set to ``UNREACHABLE``, an ``INVALID`` opcode (``0xFE``) is used instead of ``REVERT``. In this case, calls that revert do not receive a gas refund. This is not a recommended practice for general usage, but is available for interoperability with various tools that use the ``INVALID`` opcode to perform dynamic analysis.

raise
-----

The ``raise`` statement triggers an exception and reverts the current call.

.. code-block:: python

    raise "something went wrong"

The error string is not required. If it is provided, it is limited to 1024 bytes.

assert
------

The ``assert`` statement makes an assertion about a given condition. If the condition evaluates falsely, the transaction is reverted.

.. code-block:: python

    assert x > 5, "value too low"

The error string is not required. If it is provided, it is limited to 1024 bytes.

This method's behavior is equivalent to:

.. code-block:: python

    if not cond:
        raise "reason"
.. _contract_structure:

Structure of a Contract
#######################

Vyper contracts are contained within files. Each file contains exactly one contract.

This section provides a quick overview of the types of data present within a contract, with links to other sections where you can obtain more details.

.. _structure-versions:

Pragmas
==============

Vyper supports several source code directives to control compiler modes and help with build reproducibility.

Version Pragma
--------------

The version pragma ensures that a contract is only compiled by the intended compiler version, or range of versions. Version strings use `NPM <https://docs.npmjs.com/about-semantic-versioning>`_ style syntax. Starting from v0.4.0 and up, version strings will use `PEP440 version specifiers <https://peps.python.org/pep-0440/#version-specifiers>`_.

As of 0.3.10, the recommended way to specify the version pragma is as follows:

.. code-block:: python

    #pragma version ^0.3.0

.. note::

    Both pragma directive versions ``#pragma`` and ``# pragma`` are supported.

The following declaration is equivalent, and, prior to 0.3.10, was the only supported method to specify the compiler version:

.. code-block:: python

    # @version ^0.3.0


In the above examples, the contract will only compile with Vyper versions ``0.3.x``.

Optimization Mode
-----------------

The optimization mode can be one of ``"none"``, ``"codesize"``, or ``"gas"`` (default). For example, adding the following line to a contract will cause it to try to optimize for codesize:

.. code-block:: python

   #pragma optimize codesize

The optimization mode can also be set as a compiler option, which is documented in :ref:`optimization-mode`. If the compiler option conflicts with the source code pragma, an exception will be raised and compilation will not continue.

EVM Version
-----------------

The EVM version can be set with the ``evm-version`` pragma, which is documented in :ref:`evm-version`.


.. _structure-state-variables:

State Variables
===============

State variables are values which are permanently stored in contract storage. They are declared outside of the body of any functions, and initially contain the :ref:`default value<types-initial>` for their type.

.. code-block:: python

    storedData: int128

State variables are accessed via the :ref:`self<constants-self>` object.

.. code-block:: python

    self.storedData = 123

See the documentation on :ref:`Types<types>` or :ref:`Scoping and Declarations<scoping>` for more information.

.. _structure-functions:

Functions
=========

Functions are executable units of code within a contract.

.. code-block:: python

    @external
    def bid():
        ...

Functions may be called internally or externally depending on their :ref:`visibility <function-visibility>`. Functions may accept input arguments and return variables in order to pass values between them.

See the :ref:`Functions <control-structures-functions>` documentation for more information.

Events
======

Events provide an interface for the EVM's logging facilities. Events may be logged with specially indexed data structures that allow clients, including light clients, to efficiently search for them.

.. code-block:: python

    event Payment:
        amount: int128
        sender: indexed(address)

    total_paid: int128

    @external
    @payable
    def pay():
        self.total_paid += msg.value
        log Payment(msg.value, msg.sender)

See the :ref:`Event <event-logging>` documentation for more information.

Interfaces
==========

An interface is a set of function definitions used to enable calls between smart contracts. A contract interface defines all of that contract's externally available functions. By importing the interface, your contract now knows how to call these functions in other contracts.

Interfaces can be added to contracts either through inline definition, or by importing them from a separate file.

.. code-block:: python

    interface FooBar:
        def calculate() -> uint256: view
        def test1(): nonpayable

.. code-block:: python

    from foo import FooBar

Once defined, an interface can then be used to make external calls to a given address:

.. code-block:: python

    @external
    def test(some_address: address):
        FooBar(some_address).calculate()

See the :ref:`Interfaces <interfaces>` documentation for more information.

Structs
=======

A struct is a custom defined type that allows you to group several variables together:

.. code-block:: python

    struct MyStruct:
        value1: int128
        value2: decimal

See the :ref:`Structs <types-struct>` documentation for more information.
.. _style-guide:

Style Guide
###########

This document outlines the code style, project structure and practices followed by the Vyper development team.

.. note::

    Portions of the current codebase do not adhere to this style guide. We are in the process of a large-scale refactor and this guide is intended to outline the structure and best practices *during and beyond* this refactor. Refactored code and added functionality **must** adhere to this guide. Bugfixes and modifications to existing functionality **may** adopt the same style as the related code.

Project Organization
====================

    * Each subdirectory within Vyper **should** be a self-contained package representing a single pass of the compiler or other logical component.
    * Functionality intended to be called from modules outside of a package **must** be exposed within the base ``__init__.py``. All other functionality is for internal use only.
    * It **should** be possible to remove any package and replace it with another that exposes the same API, without breaking functionality in other packages.

Code Style
==========

All code **must** conform to the `PEP 8 style guide <https://www.python.org/dev/peps/pep-0008>`_ with the following exceptions:

    * Maximum line length of 100

We handle code formatting with `black <https://github.com/psf/black>`_ with the line-length option set to 80. This ensures a consistent style across the project and saves time by not having to be opinionated.

Naming Conventions
------------------

Names **must** adhere to `PEP 8 naming conventions <https://www.python.org/dev/peps/pep-0008/#prescriptive-naming-conventions>`_:

    * **Modules** have short, all-lowercase names. Underscores can be used in the module name if it improves readability.
    * **Class names** use the CapWords convention.
    * **Exceptions** follow the same conventions as other classes.
    * **Function** names are lowercase, with words separated by underscores when it improves readability.
    * **Method** names and **instance** variables follow the same conventions as functions.
    * **Constants** use all capital letters with underscores separating words.

Leading Underscores
*******************

A single leading underscore marks an object as private.

    * Classes and functions with one leading underscore are only used in the module where they are declared. They **must not** be imported.
    * Class attributes and methods with one leading underscore **must** only be accessed by methods within the same class.

Booleans
********

    * Boolean values **should** be prefixed with ``is_``.
    * Booleans **must not** represent *negative* properties, (e.g. ``is_not_set``). This can result in double-negative evaluations which are not intuitive for readers.
    * Methods that return a single boolean **should** use the :py:class:`@property<property>` decorator.

Methods
*******

The following conventions **should** be used when naming functions or methods. Consistent naming provides logical consistency throughout the codebase and makes it easier for future readers to understand what a method does (and does not) do.

    * ``get_``: For simple data retrieval without any side effects.
    * ``fetch_``: For retreivals that may have some sort of side effect.
    * ``build_``: For creation of a new object that is derived from some other data.
    * ``set_``: For adding a new value or modifying an existing one within an object.
    * ``add_``: For adding a new attribute or other value to an object. Raises an exception if the value already exists.
    * ``replace_``: For mutating an object. Should return ``None`` on success or raise an exception if something is wrong.
    * ``compare_``: For comparing values. Returns ``True`` or ``False``, does not raise an exception.
    * ``validate_``: Returns ``None`` or raises an exception if something is wrong.
    * ``from_``: For class methods that instantiate an object based on the given input data.

For other functionality, choose names that clearly communicate intent without being overly verbose. Focus on *what* the method does, not on *how* the method does it.

Imports
-------

Import sequencing is handled with `isort <https://github.com/timothycrosley/isort>`_. We follow these additional rules:

Standard Library Imports
************************

Standard libraries **should** be imported absolutely and without aliasing. Importing the library aids readability, as other users may be familiar with that library.

    .. code-block:: python

        # Good
        import os
        os.stat('.')

        # Bad
        from os import stat
        stat('.')

Internal Imports
****************

Internal imports are those between two modules inside the same Vyper package.

    * Internal imports **may** use either ``import`` or ``from ..`` syntax. The imported value **shoould** be a module, not an object. Importing modules instead of objects avoids circular dependency issues.
    * Internal imports **may** be aliased where it aids readability.
    * Internal imports **must** use absolute paths. Relative imports cause issues when the module is moved.

    .. code-block:: python

        # Good
        import vyper.ast.nodes as nodes
        from vyper.ast import nodes

        # Bad, `get_node` is a function
        from vyper.ast.nodes import get_node

        # Bad, do not use relative import paths
        from . import nodes

Cross-Package Imports
*********************

Cross-package imports are imports between one Vyper package and another.

    * Cross-package imports **must not** request anything beyond the root namespace of the target package.
    * Cross-package imports **may** be aliased where it aids readability.
    * Cross-package imports **may** use ``from [module] import [package]`` syntax.

    .. code-block:: python

        # Good
        from vyper.ast import fold
        from vyper import ast as vy_ast

        # Bad, do not import beyond the root namespace
        from vyper.ast.annotation import annotate_python_ast

Exceptions
----------

We use :ref:`custom exception classes <compiler-exceptions>` to indicate what has gone wrong during compilation.

    * All raised exceptions **must** use an exception class that appropriately describes what has gone wrong. When none fits, or when using a single exception class for an overly broad range of errors, consider creating a new class.
    * Builtin Python exceptions **must not** be raised intentionally. An unhandled builtin exception indicates a bug in the codebase.
    * Use :func:`CompilerPanic<CompilerPanic>` for errors that are not caused by the user.

Strings
-------

Strings substitutions **should** be performed via `formatted string literals <https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals>`_ rather than the ``str.format`` method or other techniques.

Type Annotations
----------------

    * All publicly exposed classes and methods **should** include `PEP 484 <https://www.python.org/dev/peps/pep-0484/>`_ annotations for all arguments and return values.
    * Type annotations **should** be included directly in the source. `Stub files <https://www.python.org/dev/peps/pep-0484/#stub-files>`_ **may** be used where there is a valid reason. Source files using stubs **must** still be annotated to aid readability.
    * Internal methods **should** include type annotations.

Tests
=====

We use the `pytest <https://docs.pytest.org/en/latest/>`_ framework for testing, and :ref:`eth-tester<testing-contracts-ethtester>` for our local development chain.

Best Practices
--------------

    * ``pytest`` functionality **should not** be imported with ``from ...`` style syntax, particularly :func:`pytest.raises<pytest.raises>`. Importing the library itself aids readability.
    * Tests **must not** be interdependent. We use ``xdist`` to execute tests in parallel. You **cannot** rely on which order tests will execute in, or that two tests will execute in the same process.
    * Test cases **should** be designed with a minimalistic approach. Each test should verify a single behavior. A good test is one with few assertions, and where it is immediately obvious exactly what is being tested.
    * Where logical, tests **should** be `parametrized <https://docs.pytest.org/en/latest/parametrize.html>`_ or use `property-based <https://hypothesis.works/>`_ testing.
    * Tests **must not** involve mocking.

Directory Structure
-------------------

Where possible, the test suite **should** copy the structure of main Vyper package. For example, test cases for ``vyper/context/types/`` should exist at ``tests/context/types/``.

Filenames
---------

Test files **must** use the following naming conventions:

    * ``test_[module].py``: When all tests for a module are contained in a single file.
    * ``test_[module]_[functionality].py``: When tests for a module are split across multiple files.

Fixtures
--------

    * Fixtures **should** be stored in ``conftest.py`` rather than the test file itself.
    * ``conftest.py`` files **must not** exist more than one subdirectory beyond the initial ``tests/`` directory.
    * The functionality of a fixture **must** be fully documented, either via docstrings or comments.

Documentation
=============

It is important to maintain comprehensive and up-to-date documentation for the Vyper language.

    * Documentation **must** accurately reflect the current state of the master branch on Github.
    * New functionality **must not** be added without corresponding documentation updates.

Writing Style
-------------

We use imperative, present tense to describe APIs: “return” not “returns”. One way to test if we have it right is to complete the following sentence:

    "If we call this API it will: ..."

For narrative style documentation, we prefer the use of first-person "we" form over second-person "you" form.

Additionally, we **recommend** the following best practices when writing documentation:

    * Use terms consistently.
    * Avoid ambiguous pronouns.
    * Eliminate unneeded words.
    * Establish key points at the start of a document.
    * Focus each paragraph on a single topic.
    * Focus each sentence on a single idea.
    * Use a numbered list when order is important and a bulleted list when order is irrelevant.
    * Introduce lists and tables appropriately.

Google's `technical writing courses <https://developers.google.com/tech-writing>`_ are a valuable resource. We recommend reviewing them before any significant documentation work.

API Directives
--------------

    * All API documentation **must** use standard Python `directives <https://www.sphinx-doc.org/en/master/usage/restructuredtext/domains.html#the-python-domain>`_.
    * Where possible, references to syntax **should** use appropriate `Python roles <https://www.sphinx-doc.org/en/master/usage/restructuredtext/domains.html#cross-referencing-syntax>`_.
    * External references **may** use `intersphinx roles <https://www.sphinx-doc.org/en/master/usage/extensions/intersphinx.html>`_.

Headers
-------

    * Each documentation section **must** begin with a `label <https://www.sphinx-doc.org/en/stable/usage/restructuredtext/roles.html#cross-referencing-arbitrary-locations>`_ of the same name as the filename for that section. For example, this section's filename is ``style-guide.rst``, so the RST opens with a label ``_style-guide``.
    * Section headers **should** use the following sequence, from top to bottom: ``#``, ``=``, ``-``, ``*``, ``^``.

Internal Documentation
======================

Internal documentation is vital to aid other contributors in understanding the layout of the Vyper codebase.

We handle internal documentation in the following ways:

    * A ``README.md`` **must** be included in each first-level subdirectory of the Vyper package. The readme explain the purpose, organization and control flow of the subdirectory.
    * All publicly exposed classes and methods **must** include detailed docstrings.
    * Internal methods **should** include docstrings, or at minimum comments.
    * Any code that may be considered "clever" or "magic" **must** include comments explaining exactly what is happening.

Docstrings **should** be formatted according to the `NumPy docstring style <https://numpydoc.readthedocs.io/en/latest/format.html>`_.

Commit Messages
===============

Contributors **should** adhere to the following standards and best practices when making commits to be merged into the Vyper codebase.

Maintainers  **may** request a rebase, or choose to squash merge pull requests that do not follow these standards.

Conventional Commits
--------------------

Commit messages **should** adhere to the `Conventional Commits <https://www.conventionalcommits.org/>`_ standard. A convetional commit message is structured as follows:

::

    <type>[optional scope]: <description>

    [optional body]

    [optional footer]

The commit contains the following elements, to communicate intent to the consumers of your library:

    * **fix**: a commit of the *type* ``fix`` patches a bug in your codebase (this correlates with ``PATCH`` in semantic versioning).
    * **feat**: a commit of the *type* ``feat`` introduces a new feature to the codebase (this correlates with ``MINOR`` in semantic versioning).
    * **BREAKING CHANGE**: a commit that has the text ``BREAKING CHANGE:`` at the beginning of its optional body or footer section introduces a breaking API change (correlating with ``MAJOR`` in semantic versioning). A BREAKING CHANGE can be part of commits of any *type*.

The use of commit types other than ``fix:`` and ``feat:`` is recommended. For example: ``docs:``, ``style:``, ``refactor:``, ``test:``, ``chore:``, or ``improvement:``. These tags are not mandated by the specification and have no implicit effect in semantic versioning.

Best Practices
--------------

We **recommend** the following best practices for commit messages (taken from `How To Write a Commit Message <https://chris.beams.io/posts/git-commit/>`_):

    * Limit the subject line to 50 characters.
    * Use imperative, present tense in the subject line.
    * Capitalize the subject line.
    * Do not end the subject line with a period.
    * Separate the subject from the body with a blank line.
    * Wrap the body at 72 characters.
    * Use the body to explain what and why vs. how.

Here's an example commit message adhering to the above practices::

    Summarize changes in around 50 characters or less

    More detailed explanatory text, if necessary. Wrap it to about 72
    characters or so. In some contexts, the first line is treated as the
    subject of the commit and the rest of the text as the body. The
    blank line separating the summary from the body is critical (unless
    you omit the body entirely); various tools like `log`, `shortlog`
    and `rebase` can get confused if you run the two together.

    Explain the problem that this commit is solving. Focus on why you
    are making this change as opposed to how (the code explains that).
    Are there side effects or other unintuitive consequences of this
    change? Here's the place to explain them.

    Further paragraphs come after blank lines.

     - Bullet points are okay, too

     - Typically a hyphen or asterisk is used for the bullet, preceded
       by a single space, with blank lines in between, but conventions
       vary here

    If you use an issue tracker, put references to them at the bottom,
    like this:

    Resolves: #XXX
    See also: #XXY, #XXXZ
.. _testing-contracts-brownie:

Testing with Brownie
####################

`Brownie <https://github.com/iamdefinitelyahuman/brownie>`_ is a Python-based development and testing framework for smart contracts. It includes a pytest plugin with fixtures that simplify testing your contract.

This section provides a quick overview of testing with Brownie. To learn more, you can view the Brownie documentation on `writing unit tests <https://eth-brownie.readthedocs.io/en/stable/tests-pytest-intro.html>`_ or join the `Ethereum Python Dev Discord <https://discord.gg/abJEARdx3Q>`_ ``#brownie`` channel.

Getting Started
===============

In order to use Brownie for testing you must first `initialize a new project <https://eth-brownie.readthedocs.io/en/stable/init.html>`_. Create a new directory for the project, and from within that directory type:

::

    $ brownie init

This will create an empty `project structure <https://eth-brownie.readthedocs.io/en/stable/structure.html#structure>`_ within the directory. Store your contract sources within the project's ``contracts/`` directory and your tests within ``tests/``.

Writing a Basic Test
====================

Assume the following simple contract ``Storage.vy``. It has a single integer variable and a function to set that value.

.. literalinclude:: ../examples/storage/storage.vy
    :language: python
    :linenos:

We create a test file ``tests/test_storage.py`` where we write our tests in pytest style.

.. code-block:: python
    :linenos:

    import pytest

    INITIAL_VALUE = 4


    @pytest.fixture
    def storage_contract(Storage, accounts):
        # deploy the contract with the initial value as a constructor argument
        yield Storage.deploy(INITIAL_VALUE, {'from': accounts[0]})


    def test_initial_state(storage_contract):
        # Check if the constructor of the contract is set up properly
        assert storage_contract.storedData() == INITIAL_VALUE


    def test_set(storage_contract, accounts):
        # set the value to 10
        storage_contract.set(10, {'from': accounts[0]})
        assert storage_contract.storedData() == 10  # Directly access storedData

        # set the value to -5
        storage_contract.set(-5, {'from': accounts[0]})
        assert storage_contract.storedData() == -5


In this example we are using two fixtures which are provided by Brownie:

* ``accounts`` provides access to the :py:class:`Accounts <brownie.network.account.Accounts>` container, containing all of your local accounts
* ``Storage`` is a dynamically named fixture that provides access to a :py:class:`ContractContainer <brownie.network.contract.ContractContainer>` object, used to deploy your contract

.. note::

    To run the tests, use the ``brownie test`` command from the root directory of your project.

Testing Events
==============

For the remaining examples, we expand our simple storage contract to include an event and two conditions for a failed transaction: ``AdvancedStorage.vy``

.. literalinclude:: ../examples/storage/advanced_storage.vy
    :linenos:
    :language: python

To test events, we examine the :py:class:`TransactionReceipt <brownie.network.transaction.TransactionReceipt>` object which is returned after each successful transaction. It contains an :py:class:`events <brownie.network.event.EventDict>` member with information about events that fired.

.. code-block:: python
    :linenos:

    import brownie

    INITIAL_VALUE = 4


    @pytest.fixture
    def adv_storage_contract(AdvancedStorage, accounts):
        yield AdvancedStorage.deploy(INITIAL_VALUE, {'from': accounts[0]})

    def test_events(adv_storage_contract, accounts):
        tx1 = adv_storage_contract.set(10, {'from': accounts[0]})
        tx2 = adv_storage_contract.set(20, {'from': accounts[1]})
        tx3 = adv_storage_contract.reset({'from': accounts[0]})

        # Check log contents
        assert len(tx1.events) == 1
        assert tx1.events[0]['value'] == 10

        assert len(tx2.events) == 1
        assert tx2.events[0]['setter'] == accounts[1]

        assert not tx3.events   # tx3 does not generate a log


Handling Reverted Transactions
==============================

Transactions that revert raise a :py:class:`VirtualMachineError <brownie.exceptions.VirtualMachineError>` exception. To write assertions around this you can use :py:class:`brownie.reverts <brownie.test.plugin.RevertContextManager>` as a context manager. It functions very similarly to :py:func:`pytest.raises <pytest.raises>`.

:py:class:`brownie.reverts <brownie.test.plugin.RevertContextManager>` optionally accepts a string as an argument. If given, the error string returned by the transaction must match it in order for the test to pass.


.. code-block:: python
    :linenos:

    import brownie

    INITIAL_VALUE = 4


    @pytest.fixture
    def adv_storage_contract(AdvancedStorage, accounts):
        yield AdvancedStorage.deploy(INITIAL_VALUE, {'from': accounts[0]})


    def test_failed_transactions(adv_storage_contract, accounts):
        # Try to set the storage to a negative amount
        with brownie.reverts("No negative values"):
            adv_storage_contract.set(-10, {"from": accounts[1]})

        # Lock the contract by storing more than 100. Then try to change the value

        adv_storage_contract.set(150, {"from": accounts[1]})
        with brownie.reverts("Storage is locked when 100 or more is stored"):
            adv_storage_contract.set(10, {"from": accounts[1]})

        # Reset the contract and try to change the value
        adv_storage_contract.reset({"from": accounts[1]})
        adv_storage_contract.set(10, {"from": accounts[1]})
        assert adv_storage_contract.storedData() == 10
.. _testing-contracts-ethtester:

Testing with Ethereum Tester
############################

`Ethereum Tester <https://github.com/ethereum/eth-tester>`_ is a tool suite for testing Ethereum based applications.

This section provides a quick overview of testing with ``eth-tester``. To learn more, you can view the documentation at the `Github repo <https://github.com/ethereum/eth-tester>`_ or join the `Gitter <https://gitter.im/ethereum/eth-tester>`_ channel.

Getting Started
===============

Prior to testing, the Vyper specific contract conversion and the blockchain related fixtures need to be set up. These fixtures will be used in every test file and should therefore be defined in `conftest.py <https://docs.pytest.org/en/latest/fixture.html#conftest-py-sharing-fixture-functions>`_.

.. note::

    Since the testing is done in the pytest framework, you can make use of `pytest.ini, tox.ini and setup.cfg <https://docs.pytest.org/en/latest/customize.html>`_ and you can use most IDEs' pytest plugins.

.. literalinclude:: ../tests/base_conftest.py
    :language: python
    :linenos:

The final two fixtures are optional and will be discussed later. The rest of this chapter assumes that you have this code set up in your ``conftest.py`` file.

Alternatively, you can import the fixtures to ``conftest.py`` or use `pytest plugins <https://docs.pytest.org/en/latest/plugins.html>`_.

Writing a Basic Test
====================

Assume the following simple contract ``storage.vy``. It has a single integer variable and a function to set that value.

.. literalinclude:: ../examples/storage/storage.vy
  :linenos:
  :language: python

We create a test file ``test_storage.py`` where we write our tests in pytest style.

.. literalinclude:: ../tests/examples/storage/test_storage.py
  :linenos:
  :language: python

First we create a fixture for the contract which will compile our contract and set up a Web3 contract object. We then use this fixture for our test functions to interact with the contract.

.. note::
    To run the tests, call ``pytest`` or ``python -m pytest`` from your project directory.

Events and Failed Transactions
==============================

To test events and failed transactions we expand our simple storage contract to include an event and two conditions for a failed transaction: ``advanced_storage.vy``

.. literalinclude:: ../examples/storage/advanced_storage.vy
  :linenos:
  :language: python

Next, we take a look at the two fixtures that will allow us to read the event logs and to check for failed transactions.

.. literalinclude:: ../tests/base_conftest.py
    :language: python
    :pyobject: assert_tx_failed

The fixture to assert failed transactions defaults to check for a ``TransactionFailed`` exception, but can be used to check for different exceptions too, as shown below. Also note that the chain gets reverted to the state before the failed transaction.

.. literalinclude:: ../tests/base_conftest.py
    :language: python
    :pyobject: get_logs

This fixture will return a tuple with all the logs for a certain event and transaction. The length of the tuple equals the number of events (of the specified type) logged and should be checked first.

Finally, we create a new file ``test_advanced_storage.py`` where we use the new fixtures to test failed transactions and events.

.. literalinclude:: ../tests/examples/storage/test_advanced_storage.py
  :linenos:
  :language: python
.. _testing-contracts:

Testing a Contract
##################

For testing Vyper contracts we recommend the use of `pytest <https://docs.pytest.org/en/latest/contents.html>`_ along with one of the following packages:

    * `Brownie <https://github.com/iamdefinitelyahuman/brownie>`_: A development and testing framework for smart contracts targeting the Ethereum Virtual Machine
    * `Ethereum Tester <https://github.com/ethereum/eth-tester>`_: A tool suite for testing ethereum applications

Example usage for each package is provided in the sections listed below.

.. toctree::
    :maxdepth: 2

    testing-contracts-brownie.rst
    testing-contracts-ethtester.rst
=====
Vyper
=====

.. toctree::
    :maxdepth: 2

    Overview <index.rst>

.. toctree::
    :caption: Getting Started
    :maxdepth: 2

    installing-vyper.rst
    vyper-by-example.rst

.. toctree::
    :caption: Language Description
    :maxdepth: 2

    structure-of-a-contract.rst
    types.rst
    constants-and-vars.rst
    statements.rst
    control-structures.rst
    scoping-and-declarations.rst
    built-in-functions.rst
    interfaces.rst
    event-logging.rst
    natspec.rst

.. toctree::
    :caption: Using the Compiler
    :maxdepth: 2

    compiling-a-contract.rst
    compiler-exceptions.rst
    deploying-contracts.rst
    testing-contracts.rst

.. toctree::
    :caption: Additional Resources
    :maxdepth: 2

    resources
    release-notes.rst
    contributing.rst
    style-guide.rst
    versioning.rst
.. index:: type

.. _types:

Types
#####

Vyper is a statically typed language. The type of each variable (state and local) must be specified or at least known at compile-time. Vyper provides several elementary types which can be combined to form complex types.

In addition, types can interact with each other in expressions containing operators.

.. index:: ! value

Value Types
===========

The following types are also called value types because variables of these
types will always be passed by value, i.e. they are always copied when they
are used as function arguments or in assignments.

.. index:: ! bool, ! true, ! false

Boolean
-------

**Keyword:** ``bool``

A boolean is a type to store a logical/truth value.

Values
******

The only possible values are the constants ``True`` and ``False``.

Operators
*********

====================  ===================
Operator              Description
====================  ===================
``not x``             Logical negation
``x and y``           Logical conjunction
``x or y``            Logical disjunction
``x == y``            Equality
``x != y``            Inequality
====================  ===================

Short-circuiting of boolean operators (``or`` and ``and``) is consistent with
the behavior of Python.

.. index:: ! intN, ! int, ! signed integer

Signed Integer (N bit)
------------------------

**Keyword:** ``intN`` (e.g., ``int128``)

A signed integer which can store positive and negative integers. ``N`` must be a multiple of 8 between 8 and 256 (inclusive).

Values
******

Signed integer values between -2\ :sup:`N-1` and (2\ :sup:`N-1` - 1), inclusive.

Integer literals cannot have a decimal point even if the decimal value is zero. For example, ``2.0`` cannot be interpreted as an integer.

Operators
*********

Comparisons
^^^^^^^^^^^

Comparisons return a boolean value.

==========  ================
Operator    Description
==========  ================
``x < y``   Less than
``x <= y``  Less than or equal to
``x == y``  Equals
``x != y``  Does not equal
``x >= y``  Greater than or equal to
``x > y``   Greater than
==========  ================

``x`` and ``y`` must both be of the same type.

Arithmetic Operators
^^^^^^^^^^^^^^^^^^^^

=============  ======================
Operator       Description
=============  ======================
``x + y``      Addition
``x - y``      Subtraction
``-x``         Unary minus/Negation
``x * y``      Multiplication
``x / y``      Division
``x**y``       Exponentiation
``x % y``      Modulo
=============  ======================

``x`` and ``y`` must both be of the same type.

Bitwise Operators
^^^^^^^^^^^^^^^^^

=============  ======================
Operator       Description
=============  ======================
``x & y``      Bitwise and
``x | y``      Bitwise or
``x ^ y``      Bitwise xor
=============  ======================

``x`` and ``y`` must be of the same type.

Shifts
^^^^^^^^^^^^^^^^^

=============  ======================
Operator       Description
=============  ======================
``x << y``     Left shift
``x >> y``     Right shift
=============  ======================

Shifting is only available for 256-bit wide types. That is, ``x`` must be ``int256``, and ``y`` can be any unsigned integer. The right shift for ``int256`` compiles to a signed right shift (EVM ``SAR`` instruction).


.. note::
   While at runtime shifts are unchecked (that is, they can be for any number of bits), to prevent common mistakes, the compiler is stricter at compile-time and will prevent out of bounds shifts. For instance, at runtime, ``1 << 257`` will evaluate to ``0``, while that expression at compile-time will raise an ``OverflowException``.


.. index:: ! uint, ! uintN, ! unsigned integer

Unsigned Integer (N bit)
--------------------------

**Keyword:** ``uintN`` (e.g., ``uint8``)

A unsigned integer which can store positive integers. ``N`` must be a multiple of 8 between 8 and 256 (inclusive).

Values
******

Integer values between 0 and (2\ :sup:`N`-1).

Integer literals cannot have a decimal point even if the decimal value is zero. For example, ``2.0`` cannot be interpreted as an integer.

.. note::
    Integer literals are interpreted as ``int256`` by default. In cases where ``uint8`` is more appropriate, such as assignment, the literal might be interpreted as ``uint8``. Example: ``_variable: uint8 = _literal``. In order to explicitly cast a literal to a ``uint8`` use ``convert(_literal, uint8)``.

Operators
*********

Comparisons
^^^^^^^^^^^

Comparisons return a boolean value.

==========  ================
Operator    Description
==========  ================
``x < y``   Less than
``x <= y``  Less than or equal to
``x == y``  Equals
``x != y``  Does not equal
``x >= y``  Greater than or equal to
``x > y``   Greater than
==========  ================

``x`` and ``y`` must be of the same type.

Arithmetic Operators
^^^^^^^^^^^^^^^^^^^^

===========================  ======================
Operator                     Description
===========================  ======================
``x + y``                    Addition
``x - y``                    Subtraction
``x * y``                    Multiplication
``x / y``                    Division
``x**y``                     Exponentiation
``x % y``                    Modulo
===========================  ======================

``x`` and ``y`` must be of the same type.

Bitwise Operators
^^^^^^^^^^^^^^^^^

=============  ======================
Operator       Description
=============  ======================
``x & y``      Bitwise and
``x | y``      Bitwise or
``x ^ y``      Bitwise xor
``~x``         Bitwise not
=============  ======================

``x`` and ``y`` must be of the same type.

.. note::
    The Bitwise ``not`` operator is currently only available for ``uint256`` type.

Shifts
^^^^^^^^^^^^^^^^^

=============  ======================
Operator       Description
=============  ======================
``x << y``     Left shift
``x >> y``     Right shift
=============  ======================

Shifting is only available for 256-bit wide types. That is, ``x`` must be ``uint256``, and ``y`` can be any unsigned integer. The right shift for ``uint256`` compiles to a signed right shift (EVM ``SHR`` instruction).


.. note::
   While at runtime shifts are unchecked (that is, they can be for any number of bits), to prevent common mistakes, the compiler is stricter at compile-time and will prevent out of bounds shifts. For instance, at runtime, ``1 << 257`` will evaluate to ``0``, while that expression at compile-time will raise an ``OverflowException``.



Decimals
--------

**Keyword:** ``decimal``

A decimal is a type to store a decimal fixed point value.

Values
******

A value with a precision of 10 decimal places between -18707220957835557353007165858768422651595.9365500928 (-2\ :sup:`167` / 10\ :sup:`10`) and 18707220957835557353007165858768422651595.9365500927 ((2\ :sup:`167` - 1) / 10\ :sup:`10`).

In order for a literal to be interpreted as ``decimal`` it must include a decimal point.

The ABI type (for computing method identifiers) of ``decimal`` is ``fixed168x10``.

Operators
*********

Comparisons
^^^^^^^^^^^

Comparisons return a boolean value.

==========  ================
Operator    Description
==========  ================
``x < y``   Less than
``x <= y``  Less or equal
``x == y``  Equals
``x != y``  Does not equal
``x >= y``  Greater or equal
``x > y``   Greater than
==========  ================

``x`` and ``y`` must be of the type ``decimal``.

Arithmetic Operators
^^^^^^^^^^^^^^^^^^^^

=============  ==========================================
Operator       Description
=============  ==========================================
``x + y``      Addition
``x - y``      Subtraction
``-x``         Unary minus/Negation
``x * y``      Multiplication
``x / y``      Division
``x % y``      Modulo
=============  ==========================================

``x`` and ``y`` must be of the type ``decimal``.

.. _address:

Address
-------

**Keyword:** ``address``

The address type holds an Ethereum address.

Values
******

An address type can hold an Ethereum address which equates to 20 bytes or 160 bits. Address literals must be written in hexadecimal notation with a leading ``0x`` and must be `checksummed <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md>`_.

.. _members-of-addresses:

Members
^^^^^^^

=============== =========== ==========================================================================
Member          Type        Description
=============== =========== ==========================================================================
``balance``     ``uint256`` Balance of an address
``codehash``    ``bytes32`` Keccak of code at an address, ``EMPTY_BYTES32`` if no contract is deployed
``codesize``    ``uint256`` Size of code deployed at an address, in bytes
``is_contract`` ``bool``    Boolean indicating if a contract is deployed at an address
``code``        ``Bytes``   Contract bytecode
=============== =========== ==========================================================================

Syntax as follows: ``_address.<member>``, where ``_address`` is of the type ``address`` and ``<member>`` is one of the above keywords.

.. note::

    Operations such as ``SELFDESTRUCT`` and ``CREATE2`` allow for the removal and replacement of bytecode at an address. You should never assume that values of address members will not change in the future.

.. note::

    ``_address.code`` requires the usage of :func:`slice <slice>` to explicitly extract a section of contract bytecode. If the extracted section exceeds the bounds of bytecode, this will throw. You can check the size of ``_address.code`` using ``_address.codesize``.

M-byte-wide Fixed Size Byte Array
----------------------

**Keyword:** ``bytesM``
This is an M-byte-wide byte array that is otherwise similar to dynamically sized byte arrays. On an ABI level, it is annotated as bytesM (e.g., bytes32).

**Example:**
::

    # Declaration
    hash: bytes32
    # Assignment
    self.hash = _hash

    some_method_id: bytes4 = 0x01abcdef

Operators
*********

====================================  ============================================================
Keyword                               Description
====================================  ============================================================
``keccak256(x)``                      Return the keccak256 hash as bytes32.
``concat(x, ...)``                    Concatenate multiple inputs.
``slice(x, start=_start, len=_len)``  Return a slice of ``_len`` starting at ``_start``.
====================================  ============================================================

Where ``x`` is a byte array and ``_start`` as well as ``_len`` are integer values.

.. index:: !bytes

Byte Arrays
-----------

**Keyword:** ``Bytes``

A byte array with a max size.

The syntax being ``Bytes[maxLen]``, where ``maxLen`` is an integer which denotes the maximum number of bytes.
On the ABI level the Fixed-size bytes array is annotated as ``bytes``.

Bytes literals may be given as bytes strings.

.. code-block:: python

    bytes_string: Bytes[100] = b"\x01"

.. index:: !string

Strings
-------

**Keyword:** ``String``

Fixed-size strings can hold strings with equal or fewer characters than the maximum length of the string.
On the ABI level the Fixed-size bytes array is annotated as ``string``.

.. code-block:: python

    example_str: String[100] = "Test String"

Enums
-----

**Keyword:** ``enum``

Enums are custom defined types. An enum must have at least one member, and can hold up to a maximum of 256 members.
The members are represented by ``uint256`` values in the form of 2\ :sup:`n` where ``n`` is the index of the member in the range ``0 <= n <= 255``.

.. code-block:: python

    # Defining an enum with two members
    enum Roles:
        ADMIN
        USER

    # Declaring an enum variable
    role: Roles = Roles.ADMIN

    # Returning a member
    return Roles.ADMIN

Operators
*********

Comparisons
^^^^^^^^^^^

Comparisons return a boolean value.

============== ================
Operator       Description
============== ================
``x == y``     Equals
``x != y``     Does not equal
``x in y``     x is in y
``x not in y`` x is not in y
============== ================

Bitwise Operators
^^^^^^^^^^^^^^^^^

=============  ======================
Operator       Description
=============  ======================
``x & y``      Bitwise and
``x | y``      Bitwise or
``x ^ y``      Bitwise xor
``~x``         Bitwise not
=============  ======================

Enum members can be combined using the above bitwise operators. While enum members have values that are power of two, enum member combinations may not.

The ``in`` and ``not in`` operators can be used in conjunction with enum member combinations to check for membership.

.. code-block:: python

    enum Roles:
        MANAGER
        ADMIN
        USER

    # Check for membership
    @external
    def foo(a: Roles) -> bool:
        return a in (Roles.MANAGER | Roles.USER)

    # Check not in
    @external
    def bar(a: Roles) -> bool:
        return a not in (Roles.MANAGER | Roles.USER)

Note that ``in`` is not the same as strict equality (``==``). ``in`` checks that *any* of the flags on two enum objects are simultaneously set, while ``==`` checks that two enum objects are bit-for-bit equal.

The following code uses bitwise operations to add and revoke permissions from a given ``Roles`` object.

.. code-block:: python
    @external
    def add_user(a: Roles) -> Roles:
        ret: Roles = a
        ret |= Roles.USER  # set the USER bit to 1
        return ret

    @external
    def revoke_user(a: Roles) -> Roles:
        ret: Roles = a
        ret &= ~Roles.USER  # set the USER bit to 0
        return ret

    @external
    def flip_user(a: Roles) -> Roles:
        ret: Roles = a
        ret ^= Roles.USER  # flip the user bit between 0 and 1
        return ret

.. index:: !reference

Reference Types
===============

Reference types are those whose components can be assigned to in-place without copying. For instance, array and struct members can be individually assigned to without overwriting the whole data structure.

.. note::

  In terms of the calling convention, reference types are passed by value, not by reference. That means that, a calling function does not need to worry about a callee modifying the data of a passed structure.

.. index:: !arrays

Fixed-size Lists
----------------

Fixed-size lists hold a finite number of elements which belong to a specified type.

Lists can be declared with ``_name: _ValueType[_Integer]``, except ``Bytes[N]``, ``String[N]`` and enums.

.. code-block:: python

    # Defining a list
    exampleList: int128[3]

    # Setting values
    exampleList = [10, 11, 12]
    exampleList[2] = 42

    # Returning a value
    return exampleList[0]

Multidimensional lists are also possible. The notation for the declaration is reversed compared to some other languages, but the access notation is not reversed.

A two dimensional list can be declared with ``_name: _ValueType[inner_size][outer_size]``. Elements can be accessed with ``_name[outer_index][inner_index]``.

.. code-block:: python

    # Defining a list with 2 rows and 5 columns and set all values to 0
    exampleList2D: int128[5][2] = empty(int128[5][2])

    # Setting a value for row the first row (0) and last column (4)
    exampleList2D[0][4] = 42

    # Setting values
    exampleList2D = [[10, 11, 12, 13, 14], [16, 17, 18, 19, 20]]

    # Returning the value in row 0 column 4 (in this case 14)
    return exampleList2D[0][4]

.. note::
    Defining an array in storage whose size is significantly larger than ``2**64`` can result in security vulnerabilities due to risk of overflow.

.. index:: !dynarrays

Dynamic Arrays
----------------

Dynamic arrays represent bounded arrays whose length can be modified at runtime, up to a bound specified in the type. They can be declared with ``_name: DynArray[_Type, _Integer]``, where ``_Type`` can be of value type or reference type (except mappings).

.. code-block:: python

    # Defining a list
    exampleList: DynArray[int128, 3]

    # Setting values
    exampleList = []
    # exampleList.pop()  # would revert!
    exampleList.append(42)  # exampleList now has length 1
    exampleList.append(120)  # exampleList now has length 2
    exampleList.append(356)  # exampleList now has length 3
    # exampleList.append(1)  # would revert!

    myValue: int128 = exampleList.pop()  # myValue == 356, exampleList now has length 2

    # myValue = exampleList[2]  # would revert!

    # Returning a value
    return exampleList[0]


.. note::
    Attempting to access data past the runtime length of an array, ``pop()`` an empty array or ``append()`` to a full array will result in a runtime ``REVERT``. Attempting to pass an array in calldata which is larger than the array bound will result in a runtime ``REVERT``.

.. note::
    To keep code easy to reason about, modifying an array while using it as an iterator is disallowed by the language. For instance, the following usage is not allowed:

    .. code-block:: python

        for item in self.my_array:
            self.my_array[0] = item

In the ABI, they are represented as ``_Type[]``. For instance, ``DynArray[int128, 3]`` gets represented as ``int128[]``, and ``DynArray[DynArray[int128, 3], 3]`` gets represented as ``int128[][]``.

.. note::
    Defining a dynamic array in storage whose size is significantly larger than ``2**64`` can result in security vulnerabilities due to risk of overflow.


.. _types-struct:

Structs
-------

Structs are custom defined types that can group several variables.

Struct types can be used inside mappings and arrays. Structs can contain arrays and other structs, but not mappings.

Struct members can be accessed via ``struct.argname``.

.. code-block:: python

    # Defining a struct
    struct MyStruct:
        value1: int128
        value2: decimal

    # Declaring a struct variable
    exampleStruct: MyStruct = MyStruct({value1: 1, value2: 2.0})

    # Accessing a value
    exampleStruct.value1 = 1

.. index:: !mapping

Mappings
--------

Mappings are `hash tables <https://en.wikipedia.org/wiki/Hash_table>`_ that are virtually initialized such that every possible key exists and is mapped to a value whose byte-representation is all zeros: a type's :ref:`default value <types-initial>`.

The key data is not stored in a mapping. Instead, its ``keccak256`` hash is used to look up a value. For this reason, mappings do not have a length or a concept of a key or value being "set".

Mapping types are declared as ``HashMap[_KeyType, _ValueType]``.

* ``_KeyType`` can be any base or bytes type. Mappings, arrays or structs are not supported as key types.
* ``_ValueType`` can actually be any type, including mappings.

.. note::
    Mappings are only allowed as state variables.

.. code-block:: python

   # Defining a mapping
   exampleMapping: HashMap[int128, decimal]

   # Accessing a value
   exampleMapping[0] = 10.1

.. note::

    Mappings have no concept of length and so cannot be iterated over.

.. index:: !initial

.. _types-initial:

Initial Values
==============

Unlike most programming languages, Vyper does not have a concept of ``null``. Instead, every variable type has a default value. To check if a variable is empty, you must compare it to the default value for its given type.

To reset a variable to its default value, assign to it the built-in ``empty()`` function which constructs a zero value for that type.

.. note::

    Memory variables must be assigned a value at the time they are declared.

Here you can find a list of all types and default values:

=========== ======================================================================
Type        Default Value
=========== ======================================================================
``address`` ``0x0000000000000000000000000000000000000000``
``bool``    ``False``
``bytes32`` ``0x0000000000000000000000000000000000000000000000000000000000000000``
``decimal`` ``0.0``
``uint8``   ``0``
``int128``  ``0``
``int256``  ``0``
``uint256`` ``0``
=========== ======================================================================

.. note::
    In ``Bytes``, the array starts with the bytes all set to ``'\x00'``.

.. note::
    In reference types, all the type's members are set to their initial values.


.. _type_conversions:

Type Conversions
================

All type conversions in Vyper must be made explicitly using the built-in ``convert(a: atype, btype)`` function. Type conversions in Vyper are designed to be safe and intuitive. All type conversions will check that the input is in bounds for the output type. The general principles are:

* Except for conversions involving decimals and bools, the input is bit-for-bit preserved.
* Conversions to bool map all nonzero inputs to 1.
* When converting from decimals to integers, the input is truncated towards zero.
* ``address`` types are treated as ``uint160``, except conversions with signed integers and decimals are not allowed.
* Converting between right-padded (``bytes``, ``Bytes``, ``String``) and left-padded types, results in a rotation to convert the padding. For instance, converting from ``bytes20`` to ``address`` would result in rotating the input by 12 bytes to the right.
* Converting between signed and unsigned integers reverts if the input is negative.
* Narrowing conversions (e.g., ``int256 -> int128``) check that the input is in bounds for the output type.
* Converting between bytes and int types results in sign-extension if the output type is signed. For instance, converting ``0xff`` (``bytes1``) to ``int8`` returns ``-1``.
* Converting between bytes and int types which have different sizes follows the rule of going through the closest integer type, first. For instance, ``bytes1 -> int16`` is like ``bytes1 -> int8 -> int16`` (signextend, then widen). ``uint8 -> bytes20`` is like ``uint8 -> uint160 -> bytes20`` (rotate left 12 bytes).
* Enums can be converted to and from ``uint256`` only.

A small Python reference implementation is maintained as part of Vyper's test suite, it can be found `here <https://github.com/vyperlang/vyper/blob/c4c6afd07801a0cc0038cdd4007cc43860c54193/tests/parser/functions/test_convert.py#L318>`_. The motivation and more detailed discussion of the rules can be found `here <https://github.com/vyperlang/vyper/issues/2507>`_.
.. _versioning:

Vyper Versioning Guideline
##########################

Motivation
==========

Vyper has different groups that are considered "users":

- Smart Contract Developers (Developers)
- Package Integrators (Integrators)
- Security Professionals (Auditors)

Each set of users must understand which changes to the compiler may require their
attention, and how these changes may impact their use of the compiler.
This guide defines what scope each compiler change may have and its potential impact based
on the type of user, so that users can stay informed about the progress of Vyper.

+-------------+----------------------------------------------+
|    Group    |             How they use Vyper               |
+=============+==============================================+
| Developers  | Write smart contracts in Vyper               |
+-------------+----------------------------------------------+
| Integrators | Integerating Vyper package or CLI into tools |
+-------------+----------------------------------------------+
| Auditors    | Aware of Vyper features and security issues  |
+-------------+----------------------------------------------+

A big part of Vyper's "public API" is the language grammar.
The syntax of the language is the main touchpoint all parties have with Vyper,
so it's important to discuss changes to the language from the viewpoint of dependability.
Users expect that all contracts written in an earlier version of Vyper will work seamlessly
with later versions, or that they will be reasonably informed when this isn't possible.
The Vyper package itself and its CLI utilities also has a fairly well-defined public API,
which consists of the available features in Vyper's
`exported package <https://github.com/vyperlang/vyper/blob/master/vyper/__init__.py>`_,
the top level modules under the package, and all CLI scripts.

Version Types
=============

This guide was adapted from `semantic versioning <https://semver.org/>`_.
It defines a format for version numbers that looks like ``MAJOR.MINOR.PATCH[-STAGE.DEVNUM]``.
We will periodically release updates according to this format, with the release decided via
the following guidelines.

Major Release ``X.0.0``
-----------------------

Changes to the grammar cannot be made in a backwards incompatible way without changing Major
versions (e.g. ``v1.x`` -> ``v2.x``).
It is to be expected that breaking changes to many features will occur when updating to a new Major release,
primarily for Developers that use Vyper to compile their contracts.
Major releases will have an audit performed prior to release (e.g. ``x.0.0`` releases) and all
``moderate`` or ``severe`` vulnerabilities will be addressed that are reported in the audit report.
``minor`` or ``informational`` vulnerabilities *should* be addressed as well, although this may be
left up to the maintainers of Vyper to decide.

+-------------+----------------------------------+
| Group       |               Look For           |
+=============+==================================+
| Developers  | Syntax deprecation, new features |
+-------------+----------------------------------+
| Integrators | No changes                       |
+-------------+----------------------------------+
| Auditors    | Audit report w/ resolved changes |
+-------------+----------------------------------+

Minor Release ``x.Y.0``
-----------------------

Minor version updates may add new features or fix a ``moderate`` or ``severe`` vulnerability,
and these will be detailed in the Release Notes for that release.
Minor releases may change the features or functionality offered by the package and CLI scripts in a
backwards-incompatible way that requires attention from an integrator.
Minor releases are required to fix a ``moderate`` or ``severe`` vulnerability,
but a ``minor`` or ``informational`` vulnerability can be fixed in Patch releases,
alongside documentation updates.

+-------------+------------------------------------+
| Group       |             Look For               |
+=============+====================================+
| Developers  | New features, security bug fixes   |
+-------------+------------------------------------+
| Integrators | Changes to external API            |
+-------------+------------------------------------+
| Auditors    | ``moderate`` or ``severe`` patches |
+-------------+------------------------------------+

Patch Release ``x.y.Z``
-----------------------

Patch version releases will be released to fix documentation issues, usage bugs,
and ``minor`` or ``informational`` vulnerabilities found in Vyper.
Patch releases should only update error messages and documentation issues
relating to its external API.

+-------------+----------------------------------------------+
| Group       |               Look For                       |
+=============+==============================================+
| Developers  | Doc updates, usage bug fixes, error messages |
+-------------+----------------------------------------------+
| Integrators | Doc updates, usage bug fixes, error messages |
+-------------+----------------------------------------------+
| Auditors    | ``minor`` or ``informational`` patches       |
+-------------+----------------------------------------------+

Vyper Security
--------------

As Vyper develops, it is very likely that we will encounter inconsistencies in how certain
language features can be used, and software bugs in the code the compiler generates.
Some of them may be quite serious, and can render a user's compiled contract vulnerable to
exploitation for financial gain.
As we become aware of these vulnerabilities, we will work according to our
`security policy <https://github.com/vyperlang/vyper/security/policy>`_ to resolve these issues,
and eventually will publish the details of all reported vulnerabilities
`here <https://github.com/vyperlang/vyper/security/advisories?state=published>`_.
Fixes for these issues will also be noted in the :ref:`Release Notes<release-notes>`.

Vyper *Next*
------------

There may be multiple Major versions in the process of development.
Work on new features that break compatibility with the existing grammar can
be maintained on a separate branch called ``next`` and represents the next
Major release of Vyper (provided in an unaudited state without Release Notes).
The work on the current branch will remain on the ``master`` branch with periodic
new releases using the process as mentioned above.

Any other branches of work outside of what is being tracked via ``master``
will use the ``-alpha.[release #]`` (Alpha) to denote WIP updates,
and ``-beta.[release #]`` (Beta) to describe work that is eventually intended for release.
``-rc.[release #]`` (Release Candidate) will only be used to denote candidate builds
prior to a Major release. An audit will be solicited for ``-rc.1`` builds,
and subsequent releases *may* incorporate feedback during the audit.
The last Release Candidate will become the next Major release,
and will be made available alongside the full audit report summarizing the findings.

Pull Requests
=============

Pull Requests can be opened against either ``master`` or ``next`` branch, depending on their content.
Changes that would increment a Minor or Patch release should target ``master``,
whereas changes to syntax (as detailed above) should be opened against ``next``.
The ``next`` branch will be periodically rebased against the ``master`` branch to pull in changes made
that were added to the latest supported version of Vyper.

Communication
=============

Major and Minor versions should be communicated on appropriate communications channels to end users,
and Patch updates will usually not be discussed, unless there is a relevant reason to do so.
Vyper by Example
################

.. index:: auction;open, open auction

Simple Open Auction
*******************

.. _simple_auction:

As an introductory example of a smart contract written in Vyper, we will begin
with a simple open auction contract. As we dive into the code,
it is important to remember that all Vyper syntax is valid Python3 syntax,
however not all Python3 functionality is available in Vyper.

In this contract, we will be looking at a simple open auction contract where
participants can submit bids during a limited time period. When the auction
period ends, a predetermined beneficiary will receive the amount of the highest
bid.

.. literalinclude:: ../examples/auctions/simple_open_auction.vy
  :language: python
  :linenos:

As you can see, this example only has a constructor, two methods to call, and
a few variables to manage the contract state. Believe it or not, this is all we
need for a basic implementation of an auction smart contract.

Let's get started!

.. literalinclude:: ../examples/auctions/simple_open_auction.vy
  :language: python
  :lineno-start: 3
  :lines: 3-17

We begin by declaring a few variables to keep track of our contract state.
We initialize a global variable ``beneficiary`` by calling ``public`` on the
datatype ``address``. The ``beneficiary`` will be the receiver of money from
the highest bidder.  We also initialize the variables ``auctionStart`` and
``auctionEnd`` with the datatype ``uint256`` to manage the open auction
period and ``highestBid`` with datatype ``uint256``, the smallest
denomination of ether, to manage auction state. The variable ``ended`` is a
boolean to determine whether the auction is officially over. The variable ``pendingReturns`` is a ``map`` which
enables the use of key-value pairs to keep proper track of the auctions withdrawal pattern.

You may notice all of the variables being passed into the ``public``
function. By declaring the variable *public*, the variable is
callable by external contracts. Initializing the variables without the ``public``
function defaults to a private declaration and thus only accessible to methods
within the same contract. The ``public`` function additionally creates a
‘getter’ function for the variable, accessible through an external call such as
``contract.beneficiary()``.

Now, the constructor.

.. literalinclude:: ../examples/auctions/simple_open_auction.vy
  :language: python
  :lineno-start: 22
  :lines: 22-27

The contract is initialized with three arguments: ``_beneficiary`` of type
``address``, ``_auction_start`` with type ``uint256`` and ``_bidding_time`` with
type ``uint256``, the time difference between the start and end of the auction. We
then store these three pieces of information into the contract variables
``self.beneficiary``, ``self.auctionStart`` and ``self.auctionEnd`` respectively.
Notice that we have access to the current time by calling ``block.timestamp``.
``block`` is an object available within any Vyper contract and provides information
about the block at the time of calling. Similar to ``block``, another important object
available to us within the contract is ``msg``, which provides information on the method
caller as we will soon see.

With initial setup out of the way, lets look at how our users can make bids.

.. literalinclude:: ../examples/auctions/simple_open_auction.vy
  :language: python
  :lineno-start: 33
  :lines: 33-46

The ``@payable`` decorator will allow a user to send some ether to the
contract in order to call the decorated method. In this case, a user wanting
to make a bid would call the ``bid()`` method while sending an amount equal
to their desired bid (not including gas fees). When calling any method within a
contract, we are provided with a built-in variable ``msg`` and we can access
the public address of any method caller with ``msg.sender``. Similarly, the
amount of ether a user sends can be accessed by calling ``msg.value``.

Here, we first check whether the current time is within the bidding period by
comparing with the auction's start and end times using the ``assert`` function
which takes any boolean statement. We also check to see if the new bid is greater
than the highest bid. If the three ``assert`` statements pass, we can safely continue
to the next lines; otherwise, the ``bid()`` method will throw an error and revert the
transaction. If the two ``assert`` statements and the check that the previous bid is
not equal to zero pass, we can safely conclude that we have a valid new highest bid.
We will send back the previous ``highestBid`` to the previous ``highestBidder`` and set
our new ``highestBid`` and ``highestBidder``.

.. literalinclude:: ../examples/auctions/simple_open_auction.vy
  :language: python
  :lineno-start: 60
  :lines: 60-85

With the ``endAuction()`` method, we check whether our current time is past
the ``auctionEnd`` time we set upon initialization of the contract. We also
check that ``self.ended`` had not previously been set to True. We do this
to prevent any calls to the method if the auction had already ended,
which could potentially be malicious if the check had not been made.
We then officially end the auction by setting ``self.ended`` to ``True``
and sending the highest bid amount to the beneficiary.

And there you have it - an open auction contract. Of course, this is a
simplified example with barebones functionality and can be improved.
Hopefully, this has provided some insight into the possibilities of Vyper.
As we move on to exploring more complex examples, we will encounter more
design patterns and features of the Vyper language.


And of course, no smart contract tutorial is complete without a note on
security.

.. note::
  It's always important to keep security in mind when designing a smart
  contract. As any application becomes more complex, the greater the potential for
  introducing new risks. Thus, it's always good practice to keep contracts as
  readable and simple as possible.

Whenever you're ready, let's turn it up a notch in the next example.


.. index:: auction;blind, blind auction

Blind Auction
*************

.. _blind_auction:


Before we dive into our other examples, let's briefly explore another type of
auction that you can build with Vyper. Similar to its counterpart_ written in
Solidity, this blind auction allows for an auction where there is no time pressure towards the end of the bidding period.

.. _counterpart: https://solidity.readthedocs.io/en/v0.5.0/solidity-by-example.html#id2

.. literalinclude:: ../examples/auctions/blind_auction.vy
  :language: python
  :linenos:

While this blind auction is almost functionally identical to the blind auction implemented in Solidity, the differences in their implementations help illustrate the differences between Solidity and Vyper.

.. literalinclude:: ../examples/auctions/blind_auction.vy
  :language: python
  :lineno-start: 28
  :lines: 28-30

One key difference is that, because Vyper does not allow for dynamic arrays, we
have limited the number of bids that can be placed by one address to 128 in this
example. Bidders who want to make more than this maximum number of bids would
need to do so from multiple addresses.


.. index:: purchases

Safe Remote Purchases
*********************

.. _safe_remote_purchases:

In this example, we have an escrow contract implementing a system for a trustless
transaction between a buyer and a seller. In this system, a seller posts an item
for sale and makes a deposit to the contract of twice the item's ``value``. At
this moment, the contract has a balance of 2 * ``value``. The seller can reclaim
the deposit and close the sale as long as a buyer has not yet made a purchase.
If a buyer is interested in making a purchase, they would make a payment and
submit an equal amount for deposit (totaling 2 * ``value``) into the contract
and locking the contract from further modification. At this moment, the contract
has a balance of 4 * ``value`` and the seller would send the item to buyer. Upon
the buyer's receipt of the item, the buyer will mark the item as received in the
contract, thereby returning the buyer's deposit (not payment), releasing the
remaining funds to the seller, and completing the transaction.

There are certainly others ways of designing a secure escrow system with less
overhead for both the buyer and seller, but for the purpose of this example,
we want to explore one way how an escrow system can be implemented trustlessly.

Let's go!

.. literalinclude:: ../examples/safe_remote_purchase/safe_remote_purchase.vy
  :language: python
  :linenos:

This is also a moderately short contract, however a little more complex in
logic. Let's break down this contract bit by bit.

.. literalinclude:: ../examples/safe_remote_purchase/safe_remote_purchase.vy
  :language: python
  :lineno-start: 16
  :lines: 16-19

Like the other contracts, we begin by declaring our global variables public with
their respective data types. Remember that the ``public`` function allows the
variables to be *readable* by an external caller, but not *writeable*.

.. literalinclude:: ../examples/safe_remote_purchase/safe_remote_purchase.vy
  :language: python
  :lineno-start: 22
  :lines: 22-29

With a ``@payable`` decorator on the constructor, the contract creator will be
required to make an initial deposit equal to twice the item's ``value`` to
initialize the contract, which will be later returned. This is in addition to
the gas fees needed to deploy the contract on the blockchain, which is not
returned. We ``assert`` that the deposit is divisible by 2 to ensure that the
seller deposited a valid amount. The constructor stores the item's value
in the contract variable ``self.value`` and saves the contract creator into
``self.seller``. The contract variable ``self.unlocked`` is initialized to
``True``.

.. literalinclude:: ../examples/safe_remote_purchase/safe_remote_purchase.vy
  :language: python
  :lineno-start: 31
  :lines: 31-36

The ``abort()`` method is a method only callable by the seller and while the
contract is still ``unlocked``—meaning it is callable only prior to any buyer
making a purchase. As we will see in the ``purchase()`` method that when
a buyer calls the ``purchase()`` method and sends a valid amount to the contract,
the contract will be locked and the seller will no longer be able to call
``abort()``.

When the seller calls ``abort()`` and if the ``assert`` statements pass, the
contract will call the ``selfdestruct()`` function and refunds the seller and
subsequently destroys the contract.

.. literalinclude:: ../examples/safe_remote_purchase/safe_remote_purchase.vy
  :language: python
  :lineno-start: 38
  :lines: 38-45

Like the constructor, the ``purchase()`` method has a ``@payable`` decorator,
meaning it can be called with a payment. For the buyer to make a valid
purchase, we must first ``assert`` that the contract's ``unlocked`` property is
``True`` and that the amount sent is equal to twice the item's value. We then
set the buyer to the ``msg.sender`` and lock the contract. At this point, the
contract has a balance equal to 4 times the item value and the seller must
send the item to the buyer.

.. literalinclude:: ../examples/safe_remote_purchase/safe_remote_purchase.vy
  :language: python
  :lineno-start: 47
  :lines: 47-61

Finally, upon the buyer's receipt of the item, the buyer can confirm their
receipt by calling the ``received()`` method to distribute the funds as
intended—where the seller receives 3/4 of the contract balance and the buyer
receives 1/4.

By calling ``received()``, we begin by checking that the contract is indeed
locked, ensuring that a buyer had previously paid. We also ensure that this
method is only callable by the buyer. If these two ``assert`` statements pass,
we refund the buyer their initial deposit and send the seller the remaining
funds. The contract is finally destroyed and the transaction is complete.

Whenever we’re ready, let’s move on to the next example.

.. index:: crowdfund

Crowdfund
*********

.. _crowdfund:

Now, let's explore a straightforward example for a crowdfunding contract where
prospective participants can contribute funds to a campaign. If the total
contribution to the campaign reaches or surpasses a predetermined funding goal,
the funds will be sent to the  beneficiary at the end of the campaign deadline.
Participants will be refunded their respective contributions if the total
funding does not reach its target goal.

.. literalinclude:: ../examples/crowdfund.vy
  :language: python
  :linenos:

Most of this code should be relatively straightforward after going through our
previous examples. Let's dive right in.

.. literalinclude:: ../examples/crowdfund.vy
  :language: python
  :lineno-start: 3
  :lines: 3-13

Like other examples, we begin by initiating our variables - except this time,
we're not calling them with the ``public`` function. Variables initiated this
way are, by default, private.

.. note::
  Unlike the existence of the function ``public()``, there is no equivalent
  ``private()`` function. Variables simply default to private if initiated
  without the ``public()`` function.

The ``funders`` variable is initiated as a mapping where the key is an address,
and the value is a number representing the contribution of each participant.
The ``beneficiary`` will be the final receiver of the funds
once the crowdfunding period is over—as determined by the ``deadline`` and
``timelimit`` variables. The ``goal`` variable is the target total contribution
of all participants.

.. literalinclude:: ../examples/crowdfund.vy
  :language: python
  :lineno-start: 9
  :lines: 9-15

Our constructor function takes 3 arguments: the beneficiary's address, the goal
in wei value, and the difference in time from start to finish of the
crowdfunding. We initialize the arguments as contract variables with their
corresponding names. Additionally, a ``self.deadline`` is initialized to set
a definitive end time for the crowdfunding period.

Now lets take a look at how a person can participate in the crowdfund.

.. literalinclude:: ../examples/crowdfund.vy
  :language: python
  :lineno-start: 17
  :lines: 17-23

Once again, we see the ``@payable`` decorator on a method, which allows a
person to send some ether along with a call to the method. In this case,
the ``participate()`` method accesses the sender's address with ``msg.sender``
and the corresponding amount sent with ``msg.value``. This information is stored
into a struct and then saved into the ``funders`` mapping with
``self.nextFunderIndex`` as the key. As more participants are added to the
mapping, ``self.nextFunderIndex`` increments appropriately to properly index
each participant.

.. literalinclude:: ../examples/crowdfund.vy
  :language: python
  :lineno-start: 25
  :lines: 25-31

The ``finalize()`` method is used to complete the crowdfunding process. However,
to complete the crowdfunding, the method first checks to see if the crowdfunding
period is over and that the balance has reached/passed its set goal. If those
two conditions pass, the contract calls the ``selfdestruct()`` function and
sends the collected funds to the beneficiary.

.. note::
  Notice that we have access to the total amount sent to the contract by
  calling ``self.balance``, a variable we never explicitly set. Similar to ``msg``
  and ``block``, ``self.balance`` is a built-in variable that's available in all
  Vyper contracts.

We can finalize the campaign if all goes well, but what happens if the
crowdfunding campaign isn't successful? We're going to need a way to refund
all the participants.

.. literalinclude:: ../examples/crowdfund.vy
  :language: python
  :lineno-start: 33
  :lines: 33-42

In the ``refund()`` method, we first check that the crowdfunding period is
indeed over and that the total collected balance is less than the ``goal`` with
the  ``assert`` statement . If those two conditions pass, we let users get their
funds back using the withdraw pattern.

.. index:: voting, ballot

Voting
******

In this contract, we will implement a system for participants to vote on a list
of proposals. The chairperson of the contract will be able to give each
participant the right to vote, and each participant may choose to vote, or
delegate their vote to another voter. Finally, a winning proposal will be
determined upon calling the ``winningProposals()`` method, which iterates through
all the proposals and returns the one with the greatest number of votes.

.. literalinclude:: ../examples/voting/ballot.vy
  :language: python
  :linenos:

As we can see, this is the contract of moderate length which we will dissect
section by section. Let’s begin!

.. literalinclude:: ../examples/voting/ballot.vy
  :language: python
  :lineno-start: 3
  :lines: 3-25

The variable ``voters`` is initialized as a mapping where the key is
the voter’s public address and the value is a struct describing the
voter’s properties: ``weight``, ``voted``, ``delegate``, and ``vote``, along
with their respective data types.

Similarly, the ``proposals`` variable is initialized as a ``public`` mapping
with ``int128`` as the key’s datatype and a struct to represent each proposal
with the properties ``name`` and ``vote_count``. Like our last example, we can
access any value by key’ing into the mapping with a number just as one would
with an index in an array.

Then, ``voterCount`` and ``chairperson`` are initialized as ``public`` with
their respective datatypes.

Let’s move onto the constructor.

.. literalinclude:: ../examples/voting/ballot.vy
  :language: python
  :lineno-start: 53
  :lines: 53-62

In the constructor, we hard-coded the contract to accept an
array argument of exactly two proposal names of type ``bytes32`` for the contracts
initialization. Because upon initialization, the ``__init__()`` method is called
by the contract creator, we have access to the contract creator’s address with
``msg.sender`` and store it in the contract variable ``self.chairperson``. We
also initialize the contract variable ``self.voter_count`` to zero to initially
represent the number of votes allowed. This value will be incremented as each
participant in the contract is given the right to vote by the method
``giveRightToVote()``, which we will explore next. We loop through the two
proposals from the argument and insert them into ``proposals`` mapping with
their respective index in the original array as its key.

Now that the initial setup is done, lets take a look at the functionality.

.. literalinclude:: ../examples/voting/ballot.vy
  :language: python
  :lineno-start: 66
  :lines: 66-75

.. note:: Throughout this contract, we use a pattern where ``@external`` functions return data from ``@internal`` functions that have the same name prepended with an underscore. This is because Vyper does not allow calls between external functions within the same contract. The internal function handles the logic and allows internal access, while the external function acts as a getter to allow external viewing.

We need a way to control who has the ability to vote. The method
``giveRightToVote()`` is a method callable by only the chairperson by taking
a voter address and granting it the right to vote by incrementing the voter's
``weight`` property. We sequentially check for 3 conditions using ``assert``.
The ``assert not`` function will check for falsy boolean values -
in this case, we want to know that the voter has not already voted. To represent
voting power, we will set their ``weight`` to ``1`` and we will keep track of the
total number of voters by incrementing ``voterCount``.

.. literalinclude:: ../examples/voting/ballot.vy
  :language: python
  :lineno-start: 120
  :lines: 120-135

In the method ``delegate``, firstly, we check to see that ``msg.sender`` has not
already voted and secondly, that the target delegate and the ``msg.sender`` are
not the same. Voters shouldn’t be able to delegate votes to themselves. We,
then, loop through all the voters to determine whether the person delegate to
had further delegated their vote to someone else in order to follow the
chain of delegation. We then mark the ``msg.sender`` as having voted if they
delegated their vote. We increment the proposal’s ``voterCount`` directly if
the delegate had already voted or increase the  delegate’s vote ``weight``
if the delegate has not yet voted.

.. literalinclude:: ../examples/voting/ballot.vy
  :language: python
  :lineno-start: 139
  :lines: 139-151

Now, let’s take a look at the logic inside the ``vote()`` method, which is
surprisingly simple. The method takes the key of the proposal in the ``proposals``
mapping as an argument, check that the method caller had not already voted,
sets the voter’s ``vote`` property to the proposal key, and increments the
proposals ``voteCount`` by the voter’s ``weight``.

With all the basic functionality complete, what’s left is simply returning
the winning proposal. To do this, we have two methods: ``winningProposal()``,
which returns the key of the proposal, and ``winnerName()``, returning the
name of the proposal. Notice the ``@view`` decorator on these two methods.
We do this because the two methods only read the blockchain state and do not
modify it. Remember, reading the blockchain state is free; modifying the state
costs gas. By having the ``@view`` decorator, we let the EVM know that this
is a read-only function and we benefit by saving gas fees.

.. literalinclude:: ../examples/voting/ballot.vy
  :language: python
  :lineno-start: 153
  :lines: 153-170

The ``_winningProposal()`` method returns the key of proposal in the ``proposals``
mapping. We will keep track of greatest number of votes and the winning
proposal with the variables ``winningVoteCount`` and ``winningProposal``,
respectively by looping through all the proposals.

``winningProposal()`` is an external function allowing access to ``_winningProposal()``.

.. literalinclude:: ../examples/voting/ballot.vy
  :language: python
  :lineno-start: 175
  :lines: 175-178

And finally, the ``winnerName()`` method returns the name of the proposal by
key’ing into the ``proposals`` mapping with the return result of the
``winningProposal()`` method.

And there you have it - a voting contract. Currently, many transactions
are needed to assign the rights to vote to all participants. As an exercise,
can we try to optimize this?

Now that we're familiar with basic contracts. Let's step up the difficulty.

.. index:: stock;company, company stock

Company Stock
*************

.. _company_stock:

This contract is just a tad bit more thorough than the ones we've previously
encountered. In this example, we are going to look at a comprehensive contract
that manages the holdings of all shares of a company. The contract allows for
a person to buy, sell and transfer shares of a company as well as allowing for
the company to pay a person in ether. The company, upon initialization of the
contract, holds all shares of the company at first but can sell them all.

Let's get started.

.. literalinclude:: ../examples/stock/company.vy
  :language: python
  :linenos:

.. note:: Throughout this contract, we use a pattern where ``@external`` functions return data from ``@internal`` functions that have the same name prepended with an underscore. This is because Vyper does not allow calls between external functions within the same contract. The internal function handles the logic, while the external function acts as a getter to allow viewing.

The contract contains a number of methods that modify the contract state as
well as a few 'getter' methods to read it. We first declare several events
that the contract logs. We then declare our global variables, followed by
function definitions.

.. literalinclude:: ../examples/stock/company.vy
  :language: python
  :lineno-start: 3
  :lines: 3-27

We initiate the ``company`` variable to be of type ``address`` that's public.
The ``totalShares`` variable is of type ``uint256``, which in this case
represents the total available shares of the company. The ``price`` variable
represents the wei value of a share and ``holdings`` is a mapping that maps an
address to the number of shares the address owns.

.. literalinclude:: ../examples/stock/company.vy
  :language: python
  :lineno-start: 29
  :lines: 29-40

In the constructor, we set up the contract to check for valid inputs during
the initialization of the contract via the two ``assert`` statements. If the
inputs are valid, the contract variables are set accordingly and the
company's address is initialized to hold all shares of the company in the
``holdings`` mapping.

.. literalinclude:: ../examples/stock/company.vy
  :language: python
  :lineno-start: 42
  :lines: 42-46

We will be seeing a few ``@view`` decorators in this contract—which is
used to decorate methods that simply read the contract state or return a simple
calculation on the contract state without modifying it. Remember, reading the
blockchain is free, writing on it is not. Since Vyper is a statically typed
language, we see an arrow following the definition of the ``_stockAvailable()``
method, which simply represents the data type which the function is expected
to return. In the method, we simply key into ``self.holdings`` with the
company's address and check it's holdings.  Because ``_stockAvailable()`` is an
internal method, we also include the ``stockAvailable()`` method to allow
external access.

Now, lets take a look at a method that lets a person buy stock from the
company's holding.

.. literalinclude:: ../examples/stock/company.vy
  :language: python
  :lineno-start: 51
  :lines: 51-64

The ``buyStock()`` method is a ``@payable`` method which takes an amount of
ether sent and calculates the ``buyOrder`` (the stock value equivalence at
the time of call). The number of shares is deducted from the company's holdings
and transferred to the sender's in the ``holdings`` mapping.

Now that people can buy shares, how do we check someone's holdings?

.. literalinclude:: ../examples/stock/company.vy
  :language: python
  :lineno-start: 66
  :lines: 66-71

The ``_getHolding()`` is another ``@view`` method that takes an ``address``
and returns its corresponding stock holdings by keying into ``self.holdings``.
Again, an external function ``getHolding()`` is included to allow access.

.. literalinclude:: ../examples/stock/company.vy
  :language: python
  :lineno-start: 72
  :lines: 72-76

To check the ether balance of the company, we can simply call the getter method
``cash()``.

.. literalinclude:: ../examples/stock/company.vy
  :language: python
  :lineno-start: 78
  :lines: 78-95

To sell a stock, we have the ``sellStock()`` method which takes a number of
stocks a person wishes to sell, and sends the equivalent value in ether to the
seller's address. We first ``assert`` that the number of stocks the person
wishes to sell is a value greater than ``0``. We also ``assert`` to see that
the user can only sell as much as the user owns and that the company has enough
ether to complete the sale. If all conditions are met, the holdings are deducted
from the seller and given to the company. The ethers are then sent to the seller.

.. literalinclude:: ../examples/stock/company.vy
  :language: python
  :lineno-start: 97
  :lines: 97-110

A stockholder can also transfer their stock to another stockholder with the
``transferStock()`` method. The method takes a receiver address and the number
of shares to send. It first ``asserts`` that the amount being sent is greater
than ``0`` and ``asserts`` whether the sender has enough stocks to send. If
both conditions are satisfied, the transfer is made.

.. literalinclude:: ../examples/stock/company.vy
  :language: python
  :lineno-start: 112
  :lines: 112-124

The company is also allowed to pay out an amount in ether to an address by
calling the ``payBill()`` method. This method should only be callable by the
company and thus first checks whether the method caller's address matches that
of the company. Another important condition to check is that the company has
enough funds to pay the amount. If both conditions satisfy, the contract
sends its ether to an address.

.. literalinclude:: ../examples/stock/company.vy
  :language: python
  :lineno-start: 126
  :lines: 126-130

We can also check how much the company has raised by multiplying the number of
shares the company has sold and the price of each share. Internally, we get
this value by calling the ``_debt()`` method. Externally it is accessed via ``debt()``.

.. literalinclude:: ../examples/stock/company.vy
  :language: python
  :lineno-start: 132
  :lines: 132-138

Finally, in this ``worth()`` method, we can check the worth of a company by
subtracting its debt from its ether balance.

This contract has been the most thorough example so far in terms of its
functionality and features. Yet despite the thoroughness of such a contract, the
logic remained simple. Hopefully, by now, the Vyper language has convinced you
of its capabilities and readability in writing smart contracts.
